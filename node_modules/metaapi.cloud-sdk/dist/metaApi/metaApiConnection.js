'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _terminalState = require('./terminalState');

var _terminalState2 = _interopRequireDefault(_terminalState);

var _memoryHistoryStorage = require('./memoryHistoryStorage');

var _memoryHistoryStorage2 = _interopRequireDefault(_memoryHistoryStorage);

var _synchronizationListener = require('../clients/metaApi/synchronizationListener');

var _synchronizationListener2 = _interopRequireDefault(_synchronizationListener);

var _timeoutError = require('../clients/timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

var _connectionHealthMonitor = require('./connectionHealthMonitor');

var _connectionHealthMonitor2 = _interopRequireDefault(_connectionHealthMonitor);

var _optionsValidator = require('../clients/optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exposes MetaApi MetaTrader API connection to consumers
 */
class MetaApiConnection extends _synchronizationListener2.default {

  /**
   * Constructs MetaApi MetaTrader Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
   */
  constructor(websocketClient, account, historyStorage, connectionRegistry, historyStartTime, refreshSubscriptionsOpts) {
    super();
    refreshSubscriptionsOpts = refreshSubscriptionsOpts || {};
    const validator = new _optionsValidator2.default();
    this._minSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.minDelayInSeconds, 1, 'refreshSubscriptionsOpts.minDelayInSeconds');
    this._maxSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.maxDelayInSeconds, 600, 'refreshSubscriptionsOpts.maxDelayInSeconds');
    this._websocketClient = websocketClient;
    this._account = account;
    this._connectionRegistry = connectionRegistry;
    this._historyStartTime = historyStartTime;
    this._terminalState = new _terminalState2.default();
    this._historyStorage = historyStorage || new _memoryHistoryStorage2.default(account.id, connectionRegistry.application);
    this._healthMonitor = new _connectionHealthMonitor2.default(this);
    this._websocketClient.addSynchronizationListener(account.id, this);
    this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
    this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
    this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
    this._websocketClient.addReconnectListener(this, account.id);
    this._subscriptions = {};
    this._stateByInstanceIndex = {};
    this._refreshMarketDataSubscriptionsJobs = {};
    this._synchronized = false;
    this._synchronizationListeners = [];
    this._logger = _logger2.default.getLogger('MetaApiConnection');
  }

  /**
   * Returns account information (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readAccountInformation/).
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */
  getAccountInformation() {
    return this._websocketClient.getAccountInformation(this._account.id);
  }

  /**
   * Returns positions (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPositions/).
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */
  getPositions() {
    return this._websocketClient.getPositions(this._account.id);
  }

  /**
   * Returns specific position (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPosition/).
   * @param {String} positionId position id
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */
  getPosition(positionId) {
    return this._websocketClient.getPosition(this._account.id, positionId);
  }

  /**
   * Returns open orders (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrders/).
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */
  getOrders() {
    return this._websocketClient.getOrders(this._account.id);
  }

  /**
   * Returns specific open order (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrder/).
   * @param {String} orderId order id (ticket number)
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */
  getOrder(orderId) {
    return this._websocketClient.getOrder(this._account.id, orderId);
  }

  /**
   * Returns the history of completed orders for a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTicket/).
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByTicket(ticket) {
    return this._websocketClient.getHistoryOrdersByTicket(this._account.id, ticket);
  }

  /**
   * Returns the history of completed orders for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByPosition/)
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByPosition(positionId) {
    return this._websocketClient.getHistoryOrdersByPosition(this._account.id, positionId);
  }

  /**
   * Returns the history of completed orders for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTimeRange/)
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByTimeRange(startTime, endTime, offset = 0, limit = 1000) {
    return this._websocketClient.getHistoryOrdersByTimeRange(this._account.id, startTime, endTime, offset, limit);
  }

  /**
   * Returns history deals with a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTicket/).
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByTicket(ticket) {
    return this._websocketClient.getDealsByTicket(this._account.id, ticket);
  }

  /**
   * Returns history deals for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByPosition/).
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByPosition(positionId) {
    return this._websocketClient.getDealsByPosition(this._account.id, positionId);
  }

  /**
   * Returns history deals with for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTimeRange/).
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByTimeRange(startTime, endTime, offset = 0, limit = 1000) {
    return this._websocketClient.getDealsByTimeRange(this._account.id, startTime, endTime, offset, limit);
  }

  /**
   * Clears the order and transaction history of a specified application so that it can be synchronized from scratch
   * (see https://metaapi.cloud/docs/client/websocket/api/removeHistory/).
   * @param {String} [application] application to remove history for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeHistory(application) {
    this._historyStorage.clear();
    return this._websocketClient.removeHistory(this._account.id, application);
  }

  /**
   * Clears the order and transaction history of a specified application and removes application (see
   * https://metaapi.cloud/docs/client/websocket/api/removeApplication/).
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */
  removeApplication() {
    this._historyStorage.clear();
    return this._websocketClient.removeApplication(this._account.id);
  }

  /**
   * Common trade options
   * @typedef {Object} TradeOptions
   * @property {String} [comment] optional order comment. The sum of the line lengths of the comment and the
   * clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} [magic] optional magic (expert id) number. If not set default value specified in account entity
   * will be used.
   * @property {Number} [slippage] optional slippage in points. Should be greater or equal to zero. In not set,
   * default value specified in account entity will be used. Slippage is ignored if execution mode set to
   * SYMBOL_TRADE_EXECUTION_MARKET in symbol specification. Not used for close by orders.
   */

  /**
   * Market trade options
   * @typedef {TradeOptions} MarketTradeOptions
   * @property {Array<String>} [fillingModes] optional allowed filling modes in the order of priority. Default is to
   * allow all filling modes and prefer ORDER_FILLING_FOK over ORDER_FILLING_IOC. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling for extra
   * explanation
   */

  /**
   * Pending order trade options
   * @typedef {TradeOptions} PendingTradeOptions
   * @property {ExpirationOptions} [expiration] optional pending order expiration settings. See Pending order expiration
   * settings section
   */

  /**
   * Pending order expiration settings
   * @typedef {Object} ExpirationOptions
   * @property {String} type pending order expiration type. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time for the list of
   * possible options. MetaTrader4 platform supports only ORDER_TIME_SPECIFIED expiration type. One of ORDER_TIME_GTC,
   * ORDER_TIME_DAY, ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY
   * @property {Date} [time] optional pending order expiration time. Ignored if expiration type is not one of
   * ORDER_TIME_DAY or ORDER_TIME_SPECIFIED
   */

  /**
   * Stop options
   * @typedef {Object} StopOptions
   * @property {number} value stop (SL or TP) value
   * @property {string} units stop units. ABSOLUTE_PRICE means the that the value of value field is a final stop value.
   * RELATIVE_* means that the value field value contains relative stop expressed either in price, points, account
   * currency or balance percentage. Default is ABSOLUTE_PRICE. Allowed values are ABSOLUTE_PRICE, RELATIVE_PRICE,
   * RELATIVE_POINTS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */

  /**
   * Creates a market buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createMarketBuyOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY', symbol, volume }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a market sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createMarketSellOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL', symbol, volume }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a limit buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {String} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createLimitBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_LIMIT', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a limit sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createLimitSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_LIMIT', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_STOP', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_STOP', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop limit buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopLimitBuyOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_STOP_LIMIT',
      symbol, volume, openPrice, stopLimitPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop limit sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopLimitSellOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_STOP_LIMIT',
      symbol, volume, openPrice, stopLimitPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Modifies a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  modifyPosition(positionId, stopLoss, takeProfit) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_MODIFY', positionId }, this._generateStopOptions(stopLoss, takeProfit)));
  }

  /**
   * Partially closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {number} volume volume to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePositionPartially(positionId, volume, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_PARTIAL', positionId,
      volume }, options || {}));
  }

  /**
   * Fully closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePosition(positionId, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_CLOSE_ID', positionId }, options || {}));
  }

  /**
   * Fully closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to close by opposite position
   * @param {string} oppositePositionId opposite position id to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closeBy(positionId, oppositePositionId, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_CLOSE_BY', positionId,
      closeByPositionId: oppositePositionId }, options || {}));
  }

  /**
   * Closes positions by a symbol(see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePositionsBySymbol(symbol, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITIONS_CLOSE_SYMBOL', symbol }, options || {}));
  }

  /**
   * Modifies a pending order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} orderId order id (ticket number)
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  modifyOrder(orderId, openPrice, stopLoss, takeProfit) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_MODIFY', orderId, openPrice }, this._generateStopOptions(stopLoss, takeProfit)));
  }

  /**
   * Cancels order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} orderId order id (ticket number)
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  cancelOrder(orderId) {
    return this._websocketClient.trade(this._account.id, { actionType: 'ORDER_CANCEL', orderId });
  }

  /**
   * Reconnects to the Metatrader terminal (see https://metaapi.cloud/docs/client/websocket/api/reconnect/).
   * @returns {Promise} promise which resolves when reconnection started
   */
  reconnect() {
    return this._websocketClient.reconnect(this._account.id);
  }

  /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */
  async synchronize(instanceIndex) {
    const instance = this.getInstanceNumber(instanceIndex);
    const host = this.getHostName(instanceIndex);
    let startingHistoryOrderTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
    let startingDealTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastDealTime(instance)).getTime()));
    let synchronizationId = _randomstring2.default.generate(32);
    this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
    const hashes = this.terminalState.getHashes(this._account.type);
    return this._websocketClient.synchronize(this._account.id, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime, hashes.specificationsMd5, hashes.positionsMd5, hashes.ordersMd5);
  }

  /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */
  async initialize() {
    await this._historyStorage.initialize();
  }

  /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */
  async subscribe() {
    if (!this._closed) {
      this._websocketClient.ensureSubscribe(this._account.id);
    }
  }

  /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {Number} instanceIndex instance index
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @returns {Promise} promise which resolves when subscription request was processed
   */
  async subscribeToMarketData(symbol, subscriptions, instanceIndex, timeoutInSeconds) {
    subscriptions = subscriptions || [{ type: 'quotes' }];
    if (this._subscriptions[symbol]) {
      const prevSubscriptions = this._subscriptions[symbol].subscriptions;
      subscriptions.forEach(subscription => {
        const index = subscription.type === 'candles' ? prevSubscriptions.findIndex(item => item.type === subscription.type && item.timeframe === subscription.timeframe) : prevSubscriptions.findIndex(item => item.type === subscription.type);
        if (index === -1) {
          prevSubscriptions.push(subscription);
        } else {
          prevSubscriptions[index] = subscription;
        }
      });
    } else {
      this._subscriptions[symbol] = { subscriptions };
    }
    await this._websocketClient.subscribeToMarketData(this._account.id, instanceIndex, symbol, subscriptions);
    return this.terminalState.waitForPrice(symbol, timeoutInSeconds);
  }

  /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @param {Number} instanceIndex instance index
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */
  unsubscribeFromMarketData(symbol, subscriptions, instanceIndex) {
    if (!subscriptions) {
      delete this._subscriptions[symbol];
    } else if (this._subscriptions[symbol]) {
      this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter(s => s.type === 'candles' ? !subscriptions.find(s2 => s.type === s2.type && s.timeframe === s2.timeframe) : !subscriptions.find(s2 => s.type === s2.type));
      if (!this._subscriptions[symbol].subscriptions.length) {
        delete this._subscriptions[symbol];
      }
    }
    return this._websocketClient.unsubscribeFromMarketData(this._account.id, instanceIndex, symbol, subscriptions);
  }

  /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  // eslint-disable-next-line complexity
  async onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
    let subscriptions = this._subscriptions[symbol];
    if (unsubscriptions && unsubscriptions.length) {
      if (subscriptions) {
        for (let subscription of unsubscriptions) {
          subscriptions = subscriptions.filter(s => s.type === subscription.type);
        }
      }
      this.unsubscribeFromMarketData(symbol, unsubscriptions);
    }
    if (updates && updates.length) {
      if (subscriptions) {
        for (let subscription of updates) {
          subscriptions.filter(s => s.type === subscription.type).forEach(s => s.intervalInMilliiseconds = subscription.intervalInMilliseconds);
        }
      }
      this.subscribeToMarketData(symbol, updates);
    }
    if (subscriptions && !subscriptions.length) {
      delete this._subscriptions[symbol];
    }
  }

  /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */
  get subscribedSymbols() {
    return (0, _keys2.default)(this._subscriptions);
  }

  /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */
  subscriptions(symbol) {
    return (this._subscriptions[symbol] || {}).subscriptions;
  }

  /**
   * Retrieves available symbols for an account (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbols/).
   * @param {String} symbol symbol to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */
  getSymbols() {
    return this._websocketClient.getSymbols(this._account.id);
  }

  /**
   * Retrieves specification for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolSpecification/).
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */
  getSymbolSpecification(symbol) {
    return this._websocketClient.getSymbolSpecification(this._account.id, symbol);
  }

  /**
   * Retrieves latest price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolPrice/).
   * @param {String} symbol symbol to retrieve price for
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */
  getSymbolPrice(symbol) {
    return this._websocketClient.getSymbolPrice(this._account.id, symbol);
  }

  /**
   * Retrieves latest candle for a symbol and timeframe (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readCandle/).
   * @param {String} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */
  getCandle(symbol, timeframe) {
    return this._websocketClient.getCandle(this._account.id, symbol, timeframe);
  }

  /**
   * Retrieves latest tick for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readTick/).
   * @param {String} symbol symbol to retrieve tick for
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */
  getTick(symbol) {
    return this._websocketClient.getTick(this._account.id, symbol);
  }

  /**
   * Retrieves latest order book for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readBook/).
   * @param {String} symbol symbol to retrieve order book for
   * @returns {Promise<MetatraderTick>} promise which resolves when order book is retrieved
   */
  getBook(symbol) {
    return this._websocketClient.getBook(this._account.id, symbol);
  }

  /**
   * Sends client uptime stats to the server.
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */
  saveUptime(uptime) {
    return this._websocketClient.saveUptime(this._account.id, uptime);
  }

  /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */
  get terminalState() {
    return this._terminalState;
  }

  /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */
  get historyStorage() {
    return this._historyStorage;
  }

  /**
   * Adds synchronization listener
   * @param {SynchronizationListener} listener synchronization listener to add
   */
  addSynchronizationListener(listener) {
    this._synchronizationListeners.push(listener);
    this._websocketClient.addSynchronizationListener(this._account.id, listener);
  }

  /**
   * Removes synchronization listener for specific account
   * @param {SynchronizationListener} listener synchronization listener to remove
   */
  removeSynchronizationListener(listener) {
    this._synchronizationListeners = this._synchronizationListeners.filter(l => l !== listener);
    this._websocketClient.removeSynchronizationListener(this._account.id, listener);
  }

  /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onConnected(instanceIndex, replicas) {
    let key = _randomstring2.default.generate(32);
    let state = this._getState(instanceIndex);
    state.shouldSynchronize = key;
    state.synchronizationRetryIntervalInSeconds = 1;
    state.synchronized = false;
    this._ensureSynchronized(instanceIndex, key);
    let indices = [];
    for (let i = 0; i < replicas; i++) {
      indices.push(i);
    }
    for (let e of (0, _entries2.default)(this._stateByInstanceIndex)) {
      if (!indices.includes(this.getInstanceNumber(e[1].instanceIndex))) {
        delete this._stateByInstanceIndex[e[0]];
      }
    }
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */
  async onDisconnected(instanceIndex) {
    let state = this._getState(instanceIndex);
    state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
    state.lastSynchronizationId = undefined;
    state.shouldSynchronize = undefined;
    state.synchronized = false;
    state.disconnected = true;
    const instance = this.getInstanceNumber(instanceIndex);
    delete this._refreshMarketDataSubscriptionsJobs[instance];
  }

  /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onDealsSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.dealsSynchronized[synchronizationId] = true;
  }

  /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.ordersSynchronized[synchronizationId] = true;
  }

  /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onAccountInformationUpdated(instanceIndex, accountInformation) {
    for (let symbol of this.subscribedSymbols) {
      if (!this._terminalState.price(symbol)) {
        const instance = this.getInstanceNumber(instanceIndex);
        _promise2.default.resolve(this.subscribeToMarketData(symbol, this._subscriptions[symbol].subscriptions, instance)).catch(err => this._logger.error('MetaApi websocket client for account ' + this._account.id + ':' + instanceIndex + ' failed to resubscribe to symbol ' + symbol, err));
      }
    }
  }

  /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */
  async onReconnected() {
    this._stateByInstanceIndex = {};
    this._refreshMarketDataSubscriptionsJobs = {};
  }

  /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onStreamClosed(instanceIndex) {
    delete this._stateByInstanceIndex[instanceIndex];
  }

  /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} specificationsUpdated whether specifications are going to be updated during synchronization
   * @param {Boolean} positionsUpdated whether positions are going to be updated during synchronization
   * @param {Boolean} ordersUpdated whether orders are going to be updated during synchronization
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onSynchronizationStarted(instanceIndex, specificationsUpdated, positionsUpdated, ordersUpdated) {
    const instance = this.getInstanceNumber(instanceIndex);
    delete this._refreshMarketDataSubscriptionsJobs[instance];
    let sessionId = _randomstring2.default.generate(32);
    this._refreshMarketDataSubscriptionsJobs[instance] = sessionId;
    await this._refreshMarketDataSubscriptions(instance, sessionId);
  }

  /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */
  async isSynchronized(instanceIndex, synchronizationId) {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => {
      if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
        return acc;
      }
      synchronizationId = synchronizationId || s.lastSynchronizationId;
      let synchronized = !!s.ordersSynchronized[synchronizationId] && !!s.dealsSynchronized[synchronizationId];
      return acc || synchronized;
    }, false);
  }

  /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @param {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @param {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */

  /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal withing timeout allowed
   */
  // eslint-disable-next-line complexity
  async waitSynchronized(opts) {
    opts = opts || {};
    let instanceIndex = opts.instanceIndex;
    let synchronizationId = opts.synchronizationId;
    let timeoutInSeconds = opts.timeoutInSeconds || 300;
    let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
    let applicationPattern = opts.applicationPattern || (this._account.application === 'CopyFactory' ? 'CopyFactory.*|RPC' : 'RPC');
    let startTime = Date.now();
    let synchronized;
    while (!(synchronized = await this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await new _promise2.default(res => setTimeout(res, intervalInMilliseconds));
    }
    let state;
    if (instanceIndex === undefined) {
      for (let s of (0, _values2.default)(this._stateByInstanceIndex)) {
        if (await this.isSynchronized(s.instanceIndex, synchronizationId)) {
          state = s;
          instanceIndex = s.instanceIndex;
        }
      }
    } else {
      state = (0, _values2.default)(this._stateByInstanceIndex).find(s => s.instanceIndex === instanceIndex);
    }
    if (!synchronized) {
      throw new _timeoutError2.default('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + this._account.id + ', synchronization id ' + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
    }
    let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
    await this._websocketClient.waitSynchronized(this._account.id, this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
  }

  /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */
  async close() {
    if (!this._closed) {
      this._logger.debug(`${this._account.id}: Closing connection`);
      this._stateByInstanceIndex = {};
      await this._websocketClient.unsubscribe(this._account.id);
      this._websocketClient.removeSynchronizationListener(this._account.id, this);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._terminalState);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._historyStorage);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._healthMonitor);
      for (let listener of this._synchronizationListeners) {
        this._websocketClient.removeSynchronizationListener(this._account.id, listener);
      }
      this._websocketClient.removeReconnectListener(this);
      this._connectionRegistry.remove(this._account.id);
      this._healthMonitor.stop();
      this._refreshMarketDataSubscriptionsJobs = {};
      this._closed = true;
    }
  }

  /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */
  get synchronized() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.synchronized, false);
  }

  /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */
  get account() {
    return this._account;
  }

  /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */
  get healthMonitor() {
    return this._healthMonitor;
  }

  async _refreshMarketDataSubscriptions(instanceNumber, session) {
    try {
      if (this._refreshMarketDataSubscriptionsJobs[instanceNumber] === session) {
        const subscriptionsList = [];
        (0, _keys2.default)(this._subscriptions).forEach(key => {
          const subscriptions = this.subscriptions(key);
          const subscriptionsItem = { symbol: key };
          if (subscriptions) {
            subscriptionsItem.subscriptions = subscriptions;
          }
          subscriptionsList.push(subscriptionsItem);
        });
        await this._websocketClient.refreshMarketDataSubscriptions(this._account.id, instanceNumber, subscriptionsList);
      }
    } catch (err) {
      this._logger.error(`Error refreshing market data subscriptions job for account ${this._account.id} ` + `${instanceNumber}`, err);
    } finally {
      if (this._refreshMarketDataSubscriptionsJobs[instanceNumber] === session) {
        let refreshInterval = (Math.random() * (this._maxSubscriptionRefreshInterval - this._minSubscriptionRefreshInterval) + this._minSubscriptionRefreshInterval) * 1000;
        setTimeout(() => this._refreshMarketDataSubscriptions(instanceNumber, session), refreshInterval);
      }
    }
  }

  _generateStopOptions(stopLoss, takeProfit) {
    let trade = {};
    if (typeof stopLoss === 'number') {
      trade.stopLoss = stopLoss;
    } else if (stopLoss) {
      trade.stopLoss = stopLoss.value;
      trade.stopLossUnits = stopLoss.units;
    }
    if (typeof takeProfit === 'number') {
      trade.takeProfit = takeProfit;
    } else if (takeProfit) {
      trade.takeProfit = takeProfit.value;
      trade.takeProfitUnits = takeProfit.units;
    }
    return trade;
  }

  async _ensureSynchronized(instanceIndex, key) {
    let state = this._getState(instanceIndex);
    if (state && !this._closed) {
      try {
        const synchronizationResult = await this.synchronize(instanceIndex);
        if (synchronizationResult) {
          state.synchronized = true;
          state.synchronizationRetryIntervalInSeconds = 1;
        }
      } catch (err) {
        this._logger.error('MetaApi websocket client for account ' + this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
        if (state.shouldSynchronize === key) {
          setTimeout(this._ensureSynchronized.bind(this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
          state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
        }
      }
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex['' + instanceIndex]) {
      this._stateByInstanceIndex['' + instanceIndex] = {
        instanceIndex,
        ordersSynchronized: {},
        dealsSynchronized: {},
        shouldSynchronize: undefined,
        synchronizationRetryIntervalInSeconds: 1,
        synchronized: false,
        lastDisconnectedSynchronizationId: undefined,
        lastSynchronizationId: undefined,
        disconnected: false
      };
    }
    return this._stateByInstanceIndex['' + instanceIndex];
  }

}
exports.default = MetaApiConnection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL21ldGFBcGlDb25uZWN0aW9uLmVzNiJdLCJuYW1lcyI6WyJNZXRhQXBpQ29ubmVjdGlvbiIsIlN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJhY2NvdW50IiwiaGlzdG9yeVN0b3JhZ2UiLCJjb25uZWN0aW9uUmVnaXN0cnkiLCJoaXN0b3J5U3RhcnRUaW1lIiwicmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIiwidmFsaWRhdG9yIiwiT3B0aW9uc1ZhbGlkYXRvciIsIl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJ2YWxpZGF0ZU5vblplcm8iLCJtaW5EZWxheUluU2Vjb25kcyIsIl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJtYXhEZWxheUluU2Vjb25kcyIsIl93ZWJzb2NrZXRDbGllbnQiLCJfYWNjb3VudCIsIl9jb25uZWN0aW9uUmVnaXN0cnkiLCJfaGlzdG9yeVN0YXJ0VGltZSIsIl90ZXJtaW5hbFN0YXRlIiwiVGVybWluYWxTdGF0ZSIsIl9oaXN0b3J5U3RvcmFnZSIsIk1lbW9yeUhpc3RvcnlTdG9yYWdlIiwiaWQiLCJhcHBsaWNhdGlvbiIsIl9oZWFsdGhNb25pdG9yIiwiQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IiLCJhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImFkZFJlY29ubmVjdExpc3RlbmVyIiwiX3N1YnNjcmlwdGlvbnMiLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zSm9icyIsIl9zeW5jaHJvbml6ZWQiLCJfc3luY2hyb25pemF0aW9uTGlzdGVuZXJzIiwiX2xvZ2dlciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiLCJnZXRBY2NvdW50SW5mb3JtYXRpb24iLCJnZXRQb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsInBvc2l0aW9uSWQiLCJnZXRPcmRlcnMiLCJnZXRPcmRlciIsIm9yZGVySWQiLCJnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQiLCJ0aWNrZXQiLCJnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbiIsImdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZSIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJvZmZzZXQiLCJsaW1pdCIsImdldERlYWxzQnlUaWNrZXQiLCJnZXREZWFsc0J5UG9zaXRpb24iLCJnZXREZWFsc0J5VGltZVJhbmdlIiwicmVtb3ZlSGlzdG9yeSIsImNsZWFyIiwicmVtb3ZlQXBwbGljYXRpb24iLCJjcmVhdGVNYXJrZXRCdXlPcmRlciIsInN5bWJvbCIsInZvbHVtZSIsInN0b3BMb3NzIiwidGFrZVByb2ZpdCIsIm9wdGlvbnMiLCJ0cmFkZSIsImFjdGlvblR5cGUiLCJfZ2VuZXJhdGVTdG9wT3B0aW9ucyIsImNyZWF0ZU1hcmtldFNlbGxPcmRlciIsImNyZWF0ZUxpbWl0QnV5T3JkZXIiLCJvcGVuUHJpY2UiLCJjcmVhdGVMaW1pdFNlbGxPcmRlciIsImNyZWF0ZVN0b3BCdXlPcmRlciIsImNyZWF0ZVN0b3BTZWxsT3JkZXIiLCJjcmVhdGVTdG9wTGltaXRCdXlPcmRlciIsInN0b3BMaW1pdFByaWNlIiwiY3JlYXRlU3RvcExpbWl0U2VsbE9yZGVyIiwibW9kaWZ5UG9zaXRpb24iLCJjbG9zZVBvc2l0aW9uUGFydGlhbGx5IiwiY2xvc2VQb3NpdGlvbiIsImNsb3NlQnkiLCJvcHBvc2l0ZVBvc2l0aW9uSWQiLCJjbG9zZUJ5UG9zaXRpb25JZCIsImNsb3NlUG9zaXRpb25zQnlTeW1ib2wiLCJtb2RpZnlPcmRlciIsImNhbmNlbE9yZGVyIiwicmVjb25uZWN0Iiwic3luY2hyb25pemUiLCJpbnN0YW5jZUluZGV4IiwiaW5zdGFuY2UiLCJnZXRJbnN0YW5jZU51bWJlciIsImhvc3QiLCJnZXRIb3N0TmFtZSIsInN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSIsIkRhdGUiLCJNYXRoIiwibWF4IiwiZ2V0VGltZSIsImxhc3RIaXN0b3J5T3JkZXJUaW1lIiwic3RhcnRpbmdEZWFsVGltZSIsImxhc3REZWFsVGltZSIsInN5bmNocm9uaXphdGlvbklkIiwicmFuZG9tc3RyaW5nIiwiZ2VuZXJhdGUiLCJfZ2V0U3RhdGUiLCJsYXN0U3luY2hyb25pemF0aW9uSWQiLCJoYXNoZXMiLCJ0ZXJtaW5hbFN0YXRlIiwiZ2V0SGFzaGVzIiwidHlwZSIsInNwZWNpZmljYXRpb25zTWQ1IiwicG9zaXRpb25zTWQ1Iiwib3JkZXJzTWQ1IiwiaW5pdGlhbGl6ZSIsInN1YnNjcmliZSIsIl9jbG9zZWQiLCJlbnN1cmVTdWJzY3JpYmUiLCJzdWJzY3JpYmVUb01hcmtldERhdGEiLCJzdWJzY3JpcHRpb25zIiwidGltZW91dEluU2Vjb25kcyIsInByZXZTdWJzY3JpcHRpb25zIiwiZm9yRWFjaCIsInN1YnNjcmlwdGlvbiIsImluZGV4IiwiZmluZEluZGV4IiwiaXRlbSIsInRpbWVmcmFtZSIsInB1c2giLCJ3YWl0Rm9yUHJpY2UiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwiZmlsdGVyIiwicyIsImZpbmQiLCJzMiIsImxlbmd0aCIsIm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZCIsInVwZGF0ZXMiLCJ1bnN1YnNjcmlwdGlvbnMiLCJpbnRlcnZhbEluTWlsbGlpc2Vjb25kcyIsImludGVydmFsSW5NaWxsaXNlY29uZHMiLCJzdWJzY3JpYmVkU3ltYm9scyIsImdldFN5bWJvbHMiLCJnZXRTeW1ib2xTcGVjaWZpY2F0aW9uIiwiZ2V0U3ltYm9sUHJpY2UiLCJnZXRDYW5kbGUiLCJnZXRUaWNrIiwiZ2V0Qm9vayIsInNhdmVVcHRpbWUiLCJ1cHRpbWUiLCJsaXN0ZW5lciIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwibCIsIm9uQ29ubmVjdGVkIiwicmVwbGljYXMiLCJrZXkiLCJzdGF0ZSIsInNob3VsZFN5bmNocm9uaXplIiwic3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyIsInN5bmNocm9uaXplZCIsIl9lbnN1cmVTeW5jaHJvbml6ZWQiLCJpbmRpY2VzIiwiaSIsImUiLCJpbmNsdWRlcyIsIm9uRGlzY29ubmVjdGVkIiwibGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkIiwidW5kZWZpbmVkIiwiZGlzY29ubmVjdGVkIiwib25EZWFsc1N5bmNocm9uaXplZCIsImRlYWxzU3luY2hyb25pemVkIiwib25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkIiwib3JkZXJzU3luY2hyb25pemVkIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkIiwiYWNjb3VudEluZm9ybWF0aW9uIiwicHJpY2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsIm9uUmVjb25uZWN0ZWQiLCJvblN0cmVhbUNsb3NlZCIsIm9uU3luY2hyb25pemF0aW9uU3RhcnRlZCIsInNwZWNpZmljYXRpb25zVXBkYXRlZCIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwic2Vzc2lvbklkIiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsImlzU3luY2hyb25pemVkIiwicmVkdWNlIiwiYWNjIiwid2FpdFN5bmNocm9uaXplZCIsIm9wdHMiLCJhcHBsaWNhdGlvblBhdHRlcm4iLCJub3ciLCJyZXMiLCJzZXRUaW1lb3V0IiwiVGltZW91dEVycm9yIiwidGltZUxlZnRJblNlY29uZHMiLCJjbG9zZSIsImRlYnVnIiwidW5zdWJzY3JpYmUiLCJyZW1vdmVSZWNvbm5lY3RMaXN0ZW5lciIsInJlbW92ZSIsInN0b3AiLCJoZWFsdGhNb25pdG9yIiwiaW5zdGFuY2VOdW1iZXIiLCJzZXNzaW9uIiwic3Vic2NyaXB0aW9uc0xpc3QiLCJzdWJzY3JpcHRpb25zSXRlbSIsInJlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsInJlZnJlc2hJbnRlcnZhbCIsInJhbmRvbSIsInZhbHVlIiwic3RvcExvc3NVbml0cyIsInVuaXRzIiwidGFrZVByb2ZpdFVuaXRzIiwic3luY2hyb25pemF0aW9uUmVzdWx0IiwiYmluZCIsIm1pbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdlLE1BQU1BLGlCQUFOLFNBQWdDQyxpQ0FBaEMsQ0FBd0Q7O0FBRXJFOzs7Ozs7Ozs7O0FBVUFDLGNBQVlDLGVBQVosRUFBNkJDLE9BQTdCLEVBQXNDQyxjQUF0QyxFQUFzREMsa0JBQXRELEVBQTBFQyxnQkFBMUUsRUFDRUMsd0JBREYsRUFDNEI7QUFDMUI7QUFDQUEsK0JBQTJCQSw0QkFBNEIsRUFBdkQ7QUFDQSxVQUFNQyxZQUFZLElBQUlDLDBCQUFKLEVBQWxCO0FBQ0EsU0FBS0MsK0JBQUwsR0FBdUNGLFVBQVVHLGVBQVYsQ0FBMEJKLHlCQUF5QkssaUJBQW5ELEVBQXNFLENBQXRFLEVBQ3JDLDRDQURxQyxDQUF2QztBQUVBLFNBQUtDLCtCQUFMLEdBQXVDTCxVQUFVRyxlQUFWLENBQTBCSix5QkFBeUJPLGlCQUFuRCxFQUFzRSxHQUF0RSxFQUNyQyw0Q0FEcUMsQ0FBdkM7QUFFQSxTQUFLQyxnQkFBTCxHQUF3QmIsZUFBeEI7QUFDQSxTQUFLYyxRQUFMLEdBQWdCYixPQUFoQjtBQUNBLFNBQUtjLG1CQUFMLEdBQTJCWixrQkFBM0I7QUFDQSxTQUFLYSxpQkFBTCxHQUF5QlosZ0JBQXpCO0FBQ0EsU0FBS2EsY0FBTCxHQUFzQixJQUFJQyx1QkFBSixFQUF0QjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJqQixrQkFBa0IsSUFBSWtCLDhCQUFKLENBQXlCbkIsUUFBUW9CLEVBQWpDLEVBQXFDbEIsbUJBQW1CbUIsV0FBeEQsQ0FBekM7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLElBQUlDLGlDQUFKLENBQTRCLElBQTVCLENBQXRCO0FBQ0EsU0FBS1gsZ0JBQUwsQ0FBc0JZLDBCQUF0QixDQUFpRHhCLFFBQVFvQixFQUF6RCxFQUE2RCxJQUE3RDtBQUNBLFNBQUtSLGdCQUFMLENBQXNCWSwwQkFBdEIsQ0FBaUR4QixRQUFRb0IsRUFBekQsRUFBNkQsS0FBS0osY0FBbEU7QUFDQSxTQUFLSixnQkFBTCxDQUFzQlksMEJBQXRCLENBQWlEeEIsUUFBUW9CLEVBQXpELEVBQTZELEtBQUtGLGVBQWxFO0FBQ0EsU0FBS04sZ0JBQUwsQ0FBc0JZLDBCQUF0QixDQUFpRHhCLFFBQVFvQixFQUF6RCxFQUE2RCxLQUFLRSxjQUFsRTtBQUNBLFNBQUtWLGdCQUFMLENBQXNCYSxvQkFBdEIsQ0FBMkMsSUFBM0MsRUFBaUR6QixRQUFRb0IsRUFBekQ7QUFDQSxTQUFLTSxjQUFMLEdBQXNCLEVBQXRCO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLQyxtQ0FBTCxHQUEyQyxFQUEzQztBQUNBLFNBQUtDLGFBQUwsR0FBcUIsS0FBckI7QUFDQSxTQUFLQyx5QkFBTCxHQUFpQyxFQUFqQztBQUNBLFNBQUtDLE9BQUwsR0FBZUMsaUJBQWNDLFNBQWQsQ0FBd0IsbUJBQXhCLENBQWY7QUFDRDs7QUFFRDs7Ozs7QUFLQUMsMEJBQXdCO0FBQ3RCLFdBQU8sS0FBS3RCLGdCQUFMLENBQXNCc0IscUJBQXRCLENBQTRDLEtBQUtyQixRQUFMLENBQWNPLEVBQTFELENBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQWUsaUJBQWU7QUFDYixXQUFPLEtBQUt2QixnQkFBTCxDQUFzQnVCLFlBQXRCLENBQW1DLEtBQUt0QixRQUFMLENBQWNPLEVBQWpELENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFnQixjQUFZQyxVQUFaLEVBQXdCO0FBQ3RCLFdBQU8sS0FBS3pCLGdCQUFMLENBQXNCd0IsV0FBdEIsQ0FBa0MsS0FBS3ZCLFFBQUwsQ0FBY08sRUFBaEQsRUFBb0RpQixVQUFwRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0FDLGNBQVk7QUFDVixXQUFPLEtBQUsxQixnQkFBTCxDQUFzQjBCLFNBQXRCLENBQWdDLEtBQUt6QixRQUFMLENBQWNPLEVBQTlDLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFtQixXQUFTQyxPQUFULEVBQWtCO0FBQ2hCLFdBQU8sS0FBSzVCLGdCQUFMLENBQXNCMkIsUUFBdEIsQ0FBK0IsS0FBSzFCLFFBQUwsQ0FBY08sRUFBN0MsRUFBaURvQixPQUFqRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BQywyQkFBeUJDLE1BQXpCLEVBQWlDO0FBQy9CLFdBQU8sS0FBSzlCLGdCQUFMLENBQXNCNkIsd0JBQXRCLENBQStDLEtBQUs1QixRQUFMLENBQWNPLEVBQTdELEVBQWlFc0IsTUFBakUsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQUMsNkJBQTJCTixVQUEzQixFQUF1QztBQUNyQyxXQUFPLEtBQUt6QixnQkFBTCxDQUFzQitCLDBCQUF0QixDQUFpRCxLQUFLOUIsUUFBTCxDQUFjTyxFQUEvRCxFQUFtRWlCLFVBQW5FLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0FPLDhCQUE0QkMsU0FBNUIsRUFBdUNDLE9BQXZDLEVBQWdEQyxTQUFTLENBQXpELEVBQTREQyxRQUFRLElBQXBFLEVBQTBFO0FBQ3hFLFdBQU8sS0FBS3BDLGdCQUFMLENBQXNCZ0MsMkJBQXRCLENBQWtELEtBQUsvQixRQUFMLENBQWNPLEVBQWhFLEVBQW9FeUIsU0FBcEUsRUFBK0VDLE9BQS9FLEVBQXdGQyxNQUF4RixFQUFnR0MsS0FBaEcsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQUMsbUJBQWlCUCxNQUFqQixFQUF5QjtBQUN2QixXQUFPLEtBQUs5QixnQkFBTCxDQUFzQnFDLGdCQUF0QixDQUF1QyxLQUFLcEMsUUFBTCxDQUFjTyxFQUFyRCxFQUF5RHNCLE1BQXpELENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFRLHFCQUFtQmIsVUFBbkIsRUFBK0I7QUFDN0IsV0FBTyxLQUFLekIsZ0JBQUwsQ0FBc0JzQyxrQkFBdEIsQ0FBeUMsS0FBS3JDLFFBQUwsQ0FBY08sRUFBdkQsRUFBMkRpQixVQUEzRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBYyxzQkFBb0JOLFNBQXBCLEVBQStCQyxPQUEvQixFQUF3Q0MsU0FBUyxDQUFqRCxFQUFvREMsUUFBUSxJQUE1RCxFQUFrRTtBQUNoRSxXQUFPLEtBQUtwQyxnQkFBTCxDQUFzQnVDLG1CQUF0QixDQUEwQyxLQUFLdEMsUUFBTCxDQUFjTyxFQUF4RCxFQUE0RHlCLFNBQTVELEVBQXVFQyxPQUF2RSxFQUFnRkMsTUFBaEYsRUFBd0ZDLEtBQXhGLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFJLGdCQUFjL0IsV0FBZCxFQUEyQjtBQUN6QixTQUFLSCxlQUFMLENBQXFCbUMsS0FBckI7QUFDQSxXQUFPLEtBQUt6QyxnQkFBTCxDQUFzQndDLGFBQXRCLENBQW9DLEtBQUt2QyxRQUFMLENBQWNPLEVBQWxELEVBQXNEQyxXQUF0RCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0FpQyxzQkFBb0I7QUFDbEIsU0FBS3BDLGVBQUwsQ0FBcUJtQyxLQUFyQjtBQUNBLFdBQU8sS0FBS3pDLGdCQUFMLENBQXNCMEMsaUJBQXRCLENBQXdDLEtBQUt6QyxRQUFMLENBQWNPLEVBQXRELENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7QUFTQTs7Ozs7OztBQU9BOzs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFVQW1DLHVCQUFxQkMsTUFBckIsRUFBNkJDLE1BQTdCLEVBQXFDQyxRQUFyQyxFQUErQ0MsVUFBL0MsRUFBMkRDLFVBQVUsRUFBckUsRUFBeUU7QUFDdkUsV0FBTyxLQUFLaEQsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSxnQkFBYixFQUErQk4sTUFBL0IsRUFBdUNDLE1BQXZDLEVBQWQsRUFDbkQsS0FBS00sb0JBQUwsQ0FBMEJMLFFBQTFCLEVBQW9DQyxVQUFwQyxDQURtRCxFQUNGQyxXQUFXLEVBRFQsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7Ozs7O0FBVUFJLHdCQUFzQlIsTUFBdEIsRUFBOEJDLE1BQTlCLEVBQXNDQyxRQUF0QyxFQUFnREMsVUFBaEQsRUFBNERDLFVBQVUsRUFBdEUsRUFBMEU7QUFDeEUsV0FBTyxLQUFLaEQsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSxpQkFBYixFQUFnQ04sTUFBaEMsRUFBd0NDLE1BQXhDLEVBQWQsRUFDbkQsS0FBS00sb0JBQUwsQ0FBMEJMLFFBQTFCLEVBQW9DQyxVQUFwQyxDQURtRCxFQUNGQyxXQUFXLEVBRFQsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7Ozs7OztBQVdBSyxzQkFBb0JULE1BQXBCLEVBQTRCQyxNQUE1QixFQUFvQ1MsU0FBcEMsRUFBK0NSLFFBQS9DLEVBQXlEQyxVQUF6RCxFQUFxRUMsVUFBVSxFQUEvRSxFQUFtRjtBQUNqRixXQUFPLEtBQUtoRCxnQkFBTCxDQUFzQmlELEtBQXRCLENBQTRCLEtBQUtoRCxRQUFMLENBQWNPLEVBQTFDLEVBQThDLHNCQUFjLEVBQUMwQyxZQUFZLHNCQUFiLEVBQXFDTixNQUFyQztBQUNqRUMsWUFEaUUsRUFDekRTLFNBRHlELEVBQWQsRUFDL0IsS0FBS0gsb0JBQUwsQ0FBMEJMLFFBQTFCLEVBQW9DQyxVQUFwQyxDQUQrQixFQUNrQkMsV0FBVyxFQUQ3QixDQUE5QyxDQUFQO0FBRUQ7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0FPLHVCQUFxQlgsTUFBckIsRUFBNkJDLE1BQTdCLEVBQXFDUyxTQUFyQyxFQUFnRFIsUUFBaEQsRUFBMERDLFVBQTFELEVBQXNFQyxVQUFVLEVBQWhGLEVBQW9GO0FBQ2xGLFdBQU8sS0FBS2hELGdCQUFMLENBQXNCaUQsS0FBdEIsQ0FBNEIsS0FBS2hELFFBQUwsQ0FBY08sRUFBMUMsRUFBOEMsc0JBQWMsRUFBQzBDLFlBQVksdUJBQWIsRUFBc0NOLE1BQXRDO0FBQ2pFQyxZQURpRSxFQUN6RFMsU0FEeUQsRUFBZCxFQUMvQixLQUFLSCxvQkFBTCxDQUEwQkwsUUFBMUIsRUFBb0NDLFVBQXBDLENBRCtCLEVBQ2tCQyxXQUFXLEVBRDdCLENBQTlDLENBQVA7QUFFRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQVEscUJBQW1CWixNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNTLFNBQW5DLEVBQThDUixRQUE5QyxFQUF3REMsVUFBeEQsRUFBb0VDLFVBQVUsRUFBOUUsRUFBa0Y7QUFDaEYsV0FBTyxLQUFLaEQsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSxxQkFBYixFQUFvQ04sTUFBcEM7QUFDakVDLFlBRGlFLEVBQ3pEUyxTQUR5RCxFQUFkLEVBQy9CLEtBQUtILG9CQUFMLENBQTBCTCxRQUExQixFQUFvQ0MsVUFBcEMsQ0FEK0IsRUFDa0JDLFdBQVcsRUFEN0IsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7Ozs7OztBQVdBUyxzQkFBb0JiLE1BQXBCLEVBQTRCQyxNQUE1QixFQUFvQ1MsU0FBcEMsRUFBK0NSLFFBQS9DLEVBQXlEQyxVQUF6RCxFQUFxRUMsVUFBVSxFQUEvRSxFQUFtRjtBQUNqRixXQUFPLEtBQUtoRCxnQkFBTCxDQUFzQmlELEtBQXRCLENBQTRCLEtBQUtoRCxRQUFMLENBQWNPLEVBQTFDLEVBQThDLHNCQUFjLEVBQUMwQyxZQUFZLHNCQUFiLEVBQXFDTixNQUFyQztBQUNqRUMsWUFEaUUsRUFDekRTLFNBRHlELEVBQWQsRUFDL0IsS0FBS0gsb0JBQUwsQ0FBMEJMLFFBQTFCLEVBQW9DQyxVQUFwQyxDQUQrQixFQUNrQkMsV0FBVyxFQUQ3QixDQUE5QyxDQUFQO0FBRUQ7O0FBRUQ7Ozs7Ozs7Ozs7OztBQVlBVSwwQkFBd0JkLE1BQXhCLEVBQWdDQyxNQUFoQyxFQUF3Q1MsU0FBeEMsRUFBbURLLGNBQW5ELEVBQW1FYixRQUFuRSxFQUE2RUMsVUFBN0UsRUFBeUZDLFVBQVUsRUFBbkcsRUFBdUc7QUFDckcsV0FBTyxLQUFLaEQsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSwyQkFBYjtBQUNqRU4sWUFEaUUsRUFDekRDLE1BRHlELEVBQ2pEUyxTQURpRCxFQUN0Q0ssY0FEc0MsRUFBZCxFQUNQLEtBQUtSLG9CQUFMLENBQTBCTCxRQUExQixFQUFvQ0MsVUFBcEMsQ0FETyxFQUMwQ0MsV0FBVyxFQURyRCxDQUE5QyxDQUFQO0FBRUQ7O0FBRUQ7Ozs7Ozs7Ozs7OztBQVlBWSwyQkFBeUJoQixNQUF6QixFQUFpQ0MsTUFBakMsRUFBeUNTLFNBQXpDLEVBQW9ESyxjQUFwRCxFQUFvRWIsUUFBcEUsRUFBOEVDLFVBQTlFLEVBQTBGQyxVQUFVLEVBQXBHLEVBQXdHO0FBQ3RHLFdBQU8sS0FBS2hELGdCQUFMLENBQXNCaUQsS0FBdEIsQ0FBNEIsS0FBS2hELFFBQUwsQ0FBY08sRUFBMUMsRUFBOEMsc0JBQWMsRUFBQzBDLFlBQVksNEJBQWI7QUFDakVOLFlBRGlFLEVBQ3pEQyxNQUR5RCxFQUNqRFMsU0FEaUQsRUFDdENLLGNBRHNDLEVBQWQsRUFDUCxLQUFLUixvQkFBTCxDQUEwQkwsUUFBMUIsRUFBb0NDLFVBQXBDLENBRE8sRUFDMENDLFdBQVcsRUFEckQsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7OztBQVFBYSxpQkFBZXBDLFVBQWYsRUFBMkJxQixRQUEzQixFQUFxQ0MsVUFBckMsRUFBaUQ7QUFDL0MsV0FBTyxLQUFLL0MsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSxpQkFBYixFQUFnQ3pCLFVBQWhDLEVBQWQsRUFDbkQsS0FBSzBCLG9CQUFMLENBQTBCTCxRQUExQixFQUFvQ0MsVUFBcEMsQ0FEbUQsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7OztBQVFBZSx5QkFBdUJyQyxVQUF2QixFQUFtQ29CLE1BQW5DLEVBQTJDRyxVQUFVLEVBQXJELEVBQXlEO0FBQ3ZELFdBQU8sS0FBS2hELGdCQUFMLENBQXNCaUQsS0FBdEIsQ0FBNEIsS0FBS2hELFFBQUwsQ0FBY08sRUFBMUMsRUFBOEMsc0JBQWMsRUFBQzBDLFlBQVksa0JBQWIsRUFBaUN6QixVQUFqQztBQUNqRW9CLFlBRGlFLEVBQWQsRUFDMUNHLFdBQVcsRUFEK0IsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7O0FBT0FlLGdCQUFjdEMsVUFBZCxFQUEwQnVCLFVBQVUsRUFBcEMsRUFBd0M7QUFDdEMsV0FBTyxLQUFLaEQsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSxtQkFBYixFQUFrQ3pCLFVBQWxDLEVBQWQsRUFDbkR1QixXQUFXLEVBRHdDLENBQTlDLENBQVA7QUFFRDs7QUFFRDs7Ozs7Ozs7QUFRQWdCLFVBQVF2QyxVQUFSLEVBQW9Cd0Msa0JBQXBCLEVBQXdDakIsVUFBVSxFQUFsRCxFQUFzRDtBQUNwRCxXQUFPLEtBQUtoRCxnQkFBTCxDQUFzQmlELEtBQXRCLENBQTRCLEtBQUtoRCxRQUFMLENBQWNPLEVBQTFDLEVBQThDLHNCQUFjLEVBQUMwQyxZQUFZLG1CQUFiLEVBQWtDekIsVUFBbEM7QUFDakV5Qyx5QkFBbUJELGtCQUQ4QyxFQUFkLEVBQ1hqQixXQUFXLEVBREEsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7O0FBT0FtQix5QkFBdUJ2QixNQUF2QixFQUErQkksVUFBVSxFQUF6QyxFQUE2QztBQUMzQyxXQUFPLEtBQUtoRCxnQkFBTCxDQUFzQmlELEtBQXRCLENBQTRCLEtBQUtoRCxRQUFMLENBQWNPLEVBQTFDLEVBQThDLHNCQUFjLEVBQUMwQyxZQUFZLHdCQUFiLEVBQXVDTixNQUF2QyxFQUFkLEVBQ25ESSxXQUFXLEVBRHdDLENBQTlDLENBQVA7QUFFRDs7QUFFRDs7Ozs7Ozs7O0FBU0FvQixjQUFZeEMsT0FBWixFQUFxQjBCLFNBQXJCLEVBQWdDUixRQUFoQyxFQUEwQ0MsVUFBMUMsRUFBc0Q7QUFDcEQsV0FBTyxLQUFLL0MsZ0JBQUwsQ0FBc0JpRCxLQUF0QixDQUE0QixLQUFLaEQsUUFBTCxDQUFjTyxFQUExQyxFQUE4QyxzQkFBYyxFQUFDMEMsWUFBWSxjQUFiLEVBQTZCdEIsT0FBN0IsRUFBc0MwQixTQUF0QyxFQUFkLEVBQ25ELEtBQUtILG9CQUFMLENBQTBCTCxRQUExQixFQUFvQ0MsVUFBcEMsQ0FEbUQsQ0FBOUMsQ0FBUDtBQUVEOztBQUVEOzs7Ozs7QUFNQXNCLGNBQVl6QyxPQUFaLEVBQXFCO0FBQ25CLFdBQU8sS0FBSzVCLGdCQUFMLENBQXNCaUQsS0FBdEIsQ0FBNEIsS0FBS2hELFFBQUwsQ0FBY08sRUFBMUMsRUFBOEMsRUFBQzBDLFlBQVksY0FBYixFQUE2QnRCLE9BQTdCLEVBQTlDLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBMEMsY0FBWTtBQUNWLFdBQU8sS0FBS3RFLGdCQUFMLENBQXNCc0UsU0FBdEIsQ0FBZ0MsS0FBS3JFLFFBQUwsQ0FBY08sRUFBOUMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxRQUFNK0QsV0FBTixDQUFrQkMsYUFBbEIsRUFBaUM7QUFDL0IsVUFBTUMsV0FBVyxLQUFLQyxpQkFBTCxDQUF1QkYsYUFBdkIsQ0FBakI7QUFDQSxVQUFNRyxPQUFPLEtBQUtDLFdBQUwsQ0FBaUJKLGFBQWpCLENBQWI7QUFDQSxRQUFJSywyQkFBMkIsSUFBSUMsSUFBSixDQUFTQyxLQUFLQyxHQUFMLENBQ3RDLENBQUMsS0FBSzdFLGlCQUFMLElBQTBCLElBQUkyRSxJQUFKLENBQVMsQ0FBVCxDQUEzQixFQUF3Q0csT0FBeEMsRUFEc0MsRUFFdEMsQ0FBQyxNQUFNLEtBQUszRSxlQUFMLENBQXFCNEUsb0JBQXJCLENBQTBDVCxRQUExQyxDQUFQLEVBQTREUSxPQUE1RCxFQUZzQyxDQUFULENBQS9CO0FBSUEsUUFBSUUsbUJBQW1CLElBQUlMLElBQUosQ0FBU0MsS0FBS0MsR0FBTCxDQUM5QixDQUFDLEtBQUs3RSxpQkFBTCxJQUEwQixJQUFJMkUsSUFBSixDQUFTLENBQVQsQ0FBM0IsRUFBd0NHLE9BQXhDLEVBRDhCLEVBRTlCLENBQUMsTUFBTSxLQUFLM0UsZUFBTCxDQUFxQjhFLFlBQXJCLENBQWtDWCxRQUFsQyxDQUFQLEVBQW9EUSxPQUFwRCxFQUY4QixDQUFULENBQXZCO0FBSUEsUUFBSUksb0JBQW9CQyx1QkFBYUMsUUFBYixDQUFzQixFQUF0QixDQUF4QjtBQUNBLFNBQUtDLFNBQUwsQ0FBZWhCLGFBQWYsRUFBOEJpQixxQkFBOUIsR0FBc0RKLGlCQUF0RDtBQUNBLFVBQU1LLFNBQVMsS0FBS0MsYUFBTCxDQUFtQkMsU0FBbkIsQ0FBNkIsS0FBSzNGLFFBQUwsQ0FBYzRGLElBQTNDLENBQWY7QUFDQSxXQUFPLEtBQUs3RixnQkFBTCxDQUFzQnVFLFdBQXRCLENBQWtDLEtBQUt0RSxRQUFMLENBQWNPLEVBQWhELEVBQW9EaUUsUUFBcEQsRUFBOERFLElBQTlELEVBQW9FVSxpQkFBcEUsRUFDTFIsd0JBREssRUFDcUJNLGdCQURyQixFQUN1Q08sT0FBT0ksaUJBRDlDLEVBQ2lFSixPQUFPSyxZQUR4RSxFQUNzRkwsT0FBT00sU0FEN0YsQ0FBUDtBQUVEOztBQUVEOzs7O0FBSUEsUUFBTUMsVUFBTixHQUFtQjtBQUNqQixVQUFNLEtBQUszRixlQUFMLENBQXFCMkYsVUFBckIsRUFBTjtBQUNEOztBQUVEOzs7O0FBSUEsUUFBTUMsU0FBTixHQUFrQjtBQUNoQixRQUFHLENBQUMsS0FBS0MsT0FBVCxFQUFrQjtBQUNoQixXQUFLbkcsZ0JBQUwsQ0FBc0JvRyxlQUF0QixDQUFzQyxLQUFLbkcsUUFBTCxDQUFjTyxFQUFwRDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxRQUFNNkYscUJBQU4sQ0FBNEJ6RCxNQUE1QixFQUFvQzBELGFBQXBDLEVBQW1EOUIsYUFBbkQsRUFBa0UrQixnQkFBbEUsRUFBb0Y7QUFDbEZELG9CQUFnQkEsaUJBQWlCLENBQUMsRUFBQ1QsTUFBTSxRQUFQLEVBQUQsQ0FBakM7QUFDQSxRQUFHLEtBQUsvRSxjQUFMLENBQW9COEIsTUFBcEIsQ0FBSCxFQUFnQztBQUM5QixZQUFNNEQsb0JBQW9CLEtBQUsxRixjQUFMLENBQW9COEIsTUFBcEIsRUFBNEIwRCxhQUF0RDtBQUNBQSxvQkFBY0csT0FBZCxDQUFzQkMsZ0JBQWdCO0FBQ3BDLGNBQU1DLFFBQVFELGFBQWFiLElBQWIsS0FBc0IsU0FBdEIsR0FDWlcsa0JBQWtCSSxTQUFsQixDQUE0QkMsUUFBUUEsS0FBS2hCLElBQUwsS0FBY2EsYUFBYWIsSUFBM0IsSUFDbENnQixLQUFLQyxTQUFMLEtBQW1CSixhQUFhSSxTQURsQyxDQURZLEdBR1pOLGtCQUFrQkksU0FBbEIsQ0FBNEJDLFFBQVFBLEtBQUtoQixJQUFMLEtBQWNhLGFBQWFiLElBQS9ELENBSEY7QUFJQSxZQUFHYyxVQUFVLENBQUMsQ0FBZCxFQUFnQjtBQUNkSCw0QkFBa0JPLElBQWxCLENBQXVCTCxZQUF2QjtBQUNELFNBRkQsTUFFTztBQUNMRiw0QkFBa0JHLEtBQWxCLElBQTJCRCxZQUEzQjtBQUNEO0FBQ0YsT0FWRDtBQVdELEtBYkQsTUFhTztBQUNMLFdBQUs1RixjQUFMLENBQW9COEIsTUFBcEIsSUFBOEIsRUFBQzBELGFBQUQsRUFBOUI7QUFDRDtBQUNELFVBQU0sS0FBS3RHLGdCQUFMLENBQXNCcUcscUJBQXRCLENBQTRDLEtBQUtwRyxRQUFMLENBQWNPLEVBQTFELEVBQThEZ0UsYUFBOUQsRUFBNkU1QixNQUE3RSxFQUFxRjBELGFBQXJGLENBQU47QUFDQSxXQUFPLEtBQUtYLGFBQUwsQ0FBbUJxQixZQUFuQixDQUFnQ3BFLE1BQWhDLEVBQXdDMkQsZ0JBQXhDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQVUsNEJBQTBCckUsTUFBMUIsRUFBa0MwRCxhQUFsQyxFQUFpRDlCLGFBQWpELEVBQWdFO0FBQzlELFFBQUksQ0FBQzhCLGFBQUwsRUFBb0I7QUFDbEIsYUFBTyxLQUFLeEYsY0FBTCxDQUFvQjhCLE1BQXBCLENBQVA7QUFDRCxLQUZELE1BRU8sSUFBSSxLQUFLOUIsY0FBTCxDQUFvQjhCLE1BQXBCLENBQUosRUFBaUM7QUFDdEMsV0FBSzlCLGNBQUwsQ0FBb0I4QixNQUFwQixFQUE0QjBELGFBQTVCLEdBQTRDLEtBQUt4RixjQUFMLENBQW9COEIsTUFBcEIsRUFBNEIwRCxhQUE1QixDQUN6Q1ksTUFEeUMsQ0FDbENDLEtBQUtBLEVBQUV0QixJQUFGLEtBQVcsU0FBWCxHQUNYLENBQUNTLGNBQWNjLElBQWQsQ0FBbUJDLE1BQU1GLEVBQUV0QixJQUFGLEtBQVd3QixHQUFHeEIsSUFBZCxJQUFzQnNCLEVBQUVMLFNBQUYsS0FBZ0JPLEdBQUdQLFNBQWxFLENBRFUsR0FFWCxDQUFDUixjQUFjYyxJQUFkLENBQW1CQyxNQUFNRixFQUFFdEIsSUFBRixLQUFXd0IsR0FBR3hCLElBQXZDLENBSHVDLENBQTVDO0FBSUEsVUFBSSxDQUFDLEtBQUsvRSxjQUFMLENBQW9COEIsTUFBcEIsRUFBNEIwRCxhQUE1QixDQUEwQ2dCLE1BQS9DLEVBQXVEO0FBQ3JELGVBQU8sS0FBS3hHLGNBQUwsQ0FBb0I4QixNQUFwQixDQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU8sS0FBSzVDLGdCQUFMLENBQXNCaUgseUJBQXRCLENBQWdELEtBQUtoSCxRQUFMLENBQWNPLEVBQTlELEVBQWtFZ0UsYUFBbEUsRUFBaUY1QixNQUFqRixFQUF5RjBELGFBQXpGLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNBLFFBQU1pQix3QkFBTixDQUErQi9DLGFBQS9CLEVBQThDNUIsTUFBOUMsRUFBc0Q0RSxPQUF0RCxFQUErREMsZUFBL0QsRUFBZ0Y7QUFDOUUsUUFBSW5CLGdCQUFnQixLQUFLeEYsY0FBTCxDQUFvQjhCLE1BQXBCLENBQXBCO0FBQ0EsUUFBSTZFLG1CQUFtQkEsZ0JBQWdCSCxNQUF2QyxFQUErQztBQUM3QyxVQUFJaEIsYUFBSixFQUFtQjtBQUNqQixhQUFLLElBQUlJLFlBQVQsSUFBeUJlLGVBQXpCLEVBQTBDO0FBQ3hDbkIsMEJBQWdCQSxjQUFjWSxNQUFkLENBQXFCQyxLQUFLQSxFQUFFdEIsSUFBRixLQUFXYSxhQUFhYixJQUFsRCxDQUFoQjtBQUNEO0FBQ0Y7QUFDRCxXQUFLb0IseUJBQUwsQ0FBK0JyRSxNQUEvQixFQUF1QzZFLGVBQXZDO0FBQ0Q7QUFDRCxRQUFJRCxXQUFXQSxRQUFRRixNQUF2QixFQUErQjtBQUM3QixVQUFJaEIsYUFBSixFQUFtQjtBQUNqQixhQUFLLElBQUlJLFlBQVQsSUFBeUJjLE9BQXpCLEVBQWtDO0FBQ2hDbEIsd0JBQWNZLE1BQWQsQ0FBcUJDLEtBQUtBLEVBQUV0QixJQUFGLEtBQVdhLGFBQWFiLElBQWxELEVBQ0dZLE9BREgsQ0FDV1UsS0FBS0EsRUFBRU8sdUJBQUYsR0FBNEJoQixhQUFhaUIsc0JBRHpEO0FBRUQ7QUFDRjtBQUNELFdBQUt0QixxQkFBTCxDQUEyQnpELE1BQTNCLEVBQW1DNEUsT0FBbkM7QUFDRDtBQUNELFFBQUlsQixpQkFBaUIsQ0FBQ0EsY0FBY2dCLE1BQXBDLEVBQTRDO0FBQzFDLGFBQU8sS0FBS3hHLGNBQUwsQ0FBb0I4QixNQUFwQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7OztBQUlBLE1BQUlnRixpQkFBSixHQUF3QjtBQUN0QixXQUFPLG9CQUFZLEtBQUs5RyxjQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0F3RixnQkFBYzFELE1BQWQsRUFBc0I7QUFDcEIsV0FBTyxDQUFDLEtBQUs5QixjQUFMLENBQW9COEIsTUFBcEIsS0FBK0IsRUFBaEMsRUFBb0MwRCxhQUEzQztBQUNEOztBQUVEOzs7Ozs7QUFNQXVCLGVBQWE7QUFDWCxXQUFPLEtBQUs3SCxnQkFBTCxDQUFzQjZILFVBQXRCLENBQWlDLEtBQUs1SCxRQUFMLENBQWNPLEVBQS9DLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFzSCx5QkFBdUJsRixNQUF2QixFQUErQjtBQUM3QixXQUFPLEtBQUs1QyxnQkFBTCxDQUFzQjhILHNCQUF0QixDQUE2QyxLQUFLN0gsUUFBTCxDQUFjTyxFQUEzRCxFQUErRG9DLE1BQS9ELENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFtRixpQkFBZW5GLE1BQWYsRUFBdUI7QUFDckIsV0FBTyxLQUFLNUMsZ0JBQUwsQ0FBc0IrSCxjQUF0QixDQUFxQyxLQUFLOUgsUUFBTCxDQUFjTyxFQUFuRCxFQUF1RG9DLE1BQXZELENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0FvRixZQUFVcEYsTUFBVixFQUFrQmtFLFNBQWxCLEVBQTZCO0FBQzNCLFdBQU8sS0FBSzlHLGdCQUFMLENBQXNCZ0ksU0FBdEIsQ0FBZ0MsS0FBSy9ILFFBQUwsQ0FBY08sRUFBOUMsRUFBa0RvQyxNQUFsRCxFQUEwRGtFLFNBQTFELENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUFtQixVQUFRckYsTUFBUixFQUFnQjtBQUNkLFdBQU8sS0FBSzVDLGdCQUFMLENBQXNCaUksT0FBdEIsQ0FBOEIsS0FBS2hJLFFBQUwsQ0FBY08sRUFBNUMsRUFBZ0RvQyxNQUFoRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1Bc0YsVUFBUXRGLE1BQVIsRUFBZ0I7QUFDZCxXQUFPLEtBQUs1QyxnQkFBTCxDQUFzQmtJLE9BQXRCLENBQThCLEtBQUtqSSxRQUFMLENBQWNPLEVBQTVDLEVBQWdEb0MsTUFBaEQsQ0FBUDtBQUNEOztBQUVEOzs7OztBQUtBdUYsYUFBV0MsTUFBWCxFQUFtQjtBQUNqQixXQUFPLEtBQUtwSSxnQkFBTCxDQUFzQm1JLFVBQXRCLENBQWlDLEtBQUtsSSxRQUFMLENBQWNPLEVBQS9DLEVBQW1ENEgsTUFBbkQsQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSXpDLGFBQUosR0FBb0I7QUFDbEIsV0FBTyxLQUFLdkYsY0FBWjtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSWYsY0FBSixHQUFxQjtBQUNuQixXQUFPLEtBQUtpQixlQUFaO0FBQ0Q7O0FBRUQ7Ozs7QUFJQU0sNkJBQTJCeUgsUUFBM0IsRUFBcUM7QUFDbkMsU0FBS25ILHlCQUFMLENBQStCNkYsSUFBL0IsQ0FBb0NzQixRQUFwQztBQUNBLFNBQUtySSxnQkFBTCxDQUFzQlksMEJBQXRCLENBQWlELEtBQUtYLFFBQUwsQ0FBY08sRUFBL0QsRUFBbUU2SCxRQUFuRTtBQUNEOztBQUVEOzs7O0FBSUFDLGdDQUE4QkQsUUFBOUIsRUFBd0M7QUFDdEMsU0FBS25ILHlCQUFMLEdBQWlDLEtBQUtBLHlCQUFMLENBQStCZ0csTUFBL0IsQ0FBc0NxQixLQUFLQSxNQUFNRixRQUFqRCxDQUFqQztBQUNBLFNBQUtySSxnQkFBTCxDQUFzQnNJLDZCQUF0QixDQUFvRCxLQUFLckksUUFBTCxDQUFjTyxFQUFsRSxFQUFzRTZILFFBQXRFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFFBQU1HLFdBQU4sQ0FBa0JoRSxhQUFsQixFQUFpQ2lFLFFBQWpDLEVBQTJDO0FBQ3pDLFFBQUlDLE1BQU1wRCx1QkFBYUMsUUFBYixDQUFzQixFQUF0QixDQUFWO0FBQ0EsUUFBSW9ELFFBQVEsS0FBS25ELFNBQUwsQ0FBZWhCLGFBQWYsQ0FBWjtBQUNBbUUsVUFBTUMsaUJBQU4sR0FBMEJGLEdBQTFCO0FBQ0FDLFVBQU1FLHFDQUFOLEdBQThDLENBQTlDO0FBQ0FGLFVBQU1HLFlBQU4sR0FBcUIsS0FBckI7QUFDQSxTQUFLQyxtQkFBTCxDQUF5QnZFLGFBQXpCLEVBQXdDa0UsR0FBeEM7QUFDQSxRQUFJTSxVQUFVLEVBQWQ7QUFDQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSVIsUUFBcEIsRUFBOEJRLEdBQTlCLEVBQW1DO0FBQ2pDRCxjQUFRakMsSUFBUixDQUFha0MsQ0FBYjtBQUNEO0FBQ0QsU0FBSyxJQUFJQyxDQUFULElBQWMsdUJBQWUsS0FBS25JLHFCQUFwQixDQUFkLEVBQTBEO0FBQ3hELFVBQUksQ0FBQ2lJLFFBQVFHLFFBQVIsQ0FBaUIsS0FBS3pFLGlCQUFMLENBQXVCd0UsRUFBRSxDQUFGLEVBQUsxRSxhQUE1QixDQUFqQixDQUFMLEVBQW1FO0FBQ2pFLGVBQU8sS0FBS3pELHFCQUFMLENBQTJCbUksRUFBRSxDQUFGLENBQTNCLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7QUFJQSxRQUFNRSxjQUFOLENBQXFCNUUsYUFBckIsRUFBb0M7QUFDbEMsUUFBSW1FLFFBQVEsS0FBS25ELFNBQUwsQ0FBZWhCLGFBQWYsQ0FBWjtBQUNBbUUsVUFBTVUsaUNBQU4sR0FBMENWLE1BQU1sRCxxQkFBaEQ7QUFDQWtELFVBQU1sRCxxQkFBTixHQUE4QjZELFNBQTlCO0FBQ0FYLFVBQU1DLGlCQUFOLEdBQTBCVSxTQUExQjtBQUNBWCxVQUFNRyxZQUFOLEdBQXFCLEtBQXJCO0FBQ0FILFVBQU1ZLFlBQU4sR0FBcUIsSUFBckI7QUFDQSxVQUFNOUUsV0FBVyxLQUFLQyxpQkFBTCxDQUF1QkYsYUFBdkIsQ0FBakI7QUFDQSxXQUFPLEtBQUt4RCxtQ0FBTCxDQUF5Q3lELFFBQXpDLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFFBQU0rRSxtQkFBTixDQUEwQmhGLGFBQTFCLEVBQXlDYSxpQkFBekMsRUFBNEQ7QUFDMUQsUUFBSXNELFFBQVEsS0FBS25ELFNBQUwsQ0FBZWhCLGFBQWYsQ0FBWjtBQUNBbUUsVUFBTWMsaUJBQU4sQ0FBd0JwRSxpQkFBeEIsSUFBNkMsSUFBN0M7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFFBQU1xRSwyQkFBTixDQUFrQ2xGLGFBQWxDLEVBQWlEYSxpQkFBakQsRUFBb0U7QUFDbEUsUUFBSXNELFFBQVEsS0FBS25ELFNBQUwsQ0FBZWhCLGFBQWYsQ0FBWjtBQUNBbUUsVUFBTWdCLGtCQUFOLENBQXlCdEUsaUJBQXpCLElBQThDLElBQTlDO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFFBQU11RSwyQkFBTixDQUFrQ3BGLGFBQWxDLEVBQWlEcUYsa0JBQWpELEVBQXFFO0FBQ25FLFNBQUksSUFBSWpILE1BQVIsSUFBa0IsS0FBS2dGLGlCQUF2QixFQUEwQztBQUN4QyxVQUFHLENBQUMsS0FBS3hILGNBQUwsQ0FBb0IwSixLQUFwQixDQUEwQmxILE1BQTFCLENBQUosRUFBdUM7QUFDckMsY0FBTTZCLFdBQVcsS0FBS0MsaUJBQUwsQ0FBdUJGLGFBQXZCLENBQWpCO0FBQ0EsMEJBQVF1RixPQUFSLENBQWdCLEtBQUsxRCxxQkFBTCxDQUEyQnpELE1BQTNCLEVBQW1DLEtBQUs5QixjQUFMLENBQW9COEIsTUFBcEIsRUFBNEIwRCxhQUEvRCxFQUE4RTdCLFFBQTlFLENBQWhCLEVBQ0d1RixLQURILENBQ1NDLE9BQU8sS0FBSzlJLE9BQUwsQ0FBYStJLEtBQWIsQ0FBbUIsMENBQTBDLEtBQUtqSyxRQUFMLENBQWNPLEVBQXhELEdBQy9CLEdBRCtCLEdBQ3pCZ0UsYUFEeUIsR0FDVCxtQ0FEUyxHQUM2QjVCLE1BRGhELEVBQ3dEcUgsR0FEeEQsQ0FEaEI7QUFHRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7QUFJQSxRQUFNRSxhQUFOLEdBQXNCO0FBQ3BCLFNBQUtwSixxQkFBTCxHQUE2QixFQUE3QjtBQUNBLFNBQUtDLG1DQUFMLEdBQTJDLEVBQTNDO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsUUFBTW9KLGNBQU4sQ0FBcUI1RixhQUFyQixFQUFvQztBQUNsQyxXQUFPLEtBQUt6RCxxQkFBTCxDQUEyQnlELGFBQTNCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxRQUFNNkYsd0JBQU4sQ0FBK0I3RixhQUEvQixFQUE4QzhGLHFCQUE5QyxFQUFxRUMsZ0JBQXJFLEVBQXVGQyxhQUF2RixFQUFzRztBQUNwRyxVQUFNL0YsV0FBVyxLQUFLQyxpQkFBTCxDQUF1QkYsYUFBdkIsQ0FBakI7QUFDQSxXQUFPLEtBQUt4RCxtQ0FBTCxDQUF5Q3lELFFBQXpDLENBQVA7QUFDQSxRQUFJZ0csWUFBWW5GLHVCQUFhQyxRQUFiLENBQXNCLEVBQXRCLENBQWhCO0FBQ0EsU0FBS3ZFLG1DQUFMLENBQXlDeUQsUUFBekMsSUFBcURnRyxTQUFyRDtBQUNBLFVBQU0sS0FBS0MsK0JBQUwsQ0FBcUNqRyxRQUFyQyxFQUErQ2dHLFNBQS9DLENBQU47QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxRQUFNRSxjQUFOLENBQXFCbkcsYUFBckIsRUFBb0NhLGlCQUFwQyxFQUF1RDtBQUNyRCxXQUFPLHNCQUFjLEtBQUt0RSxxQkFBbkIsRUFBMEM2SixNQUExQyxDQUFpRCxDQUFDQyxHQUFELEVBQU0xRCxDQUFOLEtBQVk7QUFDbEUsVUFBSTNDLGtCQUFrQjhFLFNBQWxCLElBQStCbkMsRUFBRTNDLGFBQUYsS0FBb0JBLGFBQXZELEVBQXNFO0FBQ3BFLGVBQU9xRyxHQUFQO0FBQ0Q7QUFDRHhGLDBCQUFvQkEscUJBQXFCOEIsRUFBRTFCLHFCQUEzQztBQUNBLFVBQUlxRCxlQUFlLENBQUMsQ0FBQzNCLEVBQUV3QyxrQkFBRixDQUFxQnRFLGlCQUFyQixDQUFGLElBQTZDLENBQUMsQ0FBQzhCLEVBQUVzQyxpQkFBRixDQUFvQnBFLGlCQUFwQixDQUFsRTtBQUNBLGFBQU93RixPQUFPL0IsWUFBZDtBQUNELEtBUE0sRUFPSixLQVBJLENBQVA7QUFRRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTs7Ozs7O0FBTUE7QUFDQSxRQUFNZ0MsZ0JBQU4sQ0FBdUJDLElBQXZCLEVBQTZCO0FBQzNCQSxXQUFPQSxRQUFRLEVBQWY7QUFDQSxRQUFJdkcsZ0JBQWdCdUcsS0FBS3ZHLGFBQXpCO0FBQ0EsUUFBSWEsb0JBQW9CMEYsS0FBSzFGLGlCQUE3QjtBQUNBLFFBQUlrQixtQkFBbUJ3RSxLQUFLeEUsZ0JBQUwsSUFBeUIsR0FBaEQ7QUFDQSxRQUFJb0IseUJBQXlCb0QsS0FBS3BELHNCQUFMLElBQStCLElBQTVEO0FBQ0EsUUFBSXFELHFCQUFxQkQsS0FBS0Msa0JBQUwsS0FDdEIsS0FBSy9LLFFBQUwsQ0FBY1EsV0FBZCxLQUE4QixhQUE5QixHQUE4QyxtQkFBOUMsR0FBb0UsS0FEOUMsQ0FBekI7QUFFQSxRQUFJd0IsWUFBWTZDLEtBQUttRyxHQUFMLEVBQWhCO0FBQ0EsUUFBSW5DLFlBQUo7QUFDQSxXQUFPLEVBQUVBLGVBQWUsTUFBTSxLQUFLNkIsY0FBTCxDQUFvQm5HLGFBQXBCLEVBQW1DYSxpQkFBbkMsQ0FBdkIsS0FDSnBELFlBQVlzRSxtQkFBbUIsSUFBaEMsR0FBd0N6QixLQUFLbUcsR0FBTCxFQUQxQyxFQUNzRDtBQUNwRCxZQUFNLHNCQUFZQyxPQUFPQyxXQUFXRCxHQUFYLEVBQWdCdkQsc0JBQWhCLENBQW5CLENBQU47QUFDRDtBQUNELFFBQUlnQixLQUFKO0FBQ0EsUUFBSW5FLGtCQUFrQjhFLFNBQXRCLEVBQWlDO0FBQy9CLFdBQUssSUFBSW5DLENBQVQsSUFBYyxzQkFBYyxLQUFLcEcscUJBQW5CLENBQWQsRUFBeUQ7QUFDdkQsWUFBSSxNQUFNLEtBQUs0SixjQUFMLENBQW9CeEQsRUFBRTNDLGFBQXRCLEVBQXFDYSxpQkFBckMsQ0FBVixFQUFtRTtBQUNqRXNELGtCQUFReEIsQ0FBUjtBQUNBM0MsMEJBQWdCMkMsRUFBRTNDLGFBQWxCO0FBQ0Q7QUFDRjtBQUNGLEtBUEQsTUFPTztBQUNMbUUsY0FBUSxzQkFBYyxLQUFLNUgscUJBQW5CLEVBQTBDcUcsSUFBMUMsQ0FBK0NELEtBQUtBLEVBQUUzQyxhQUFGLEtBQW9CQSxhQUF4RSxDQUFSO0FBQ0Q7QUFDRCxRQUFJLENBQUNzRSxZQUFMLEVBQW1CO0FBQ2pCLFlBQU0sSUFBSXNDLHNCQUFKLENBQWlCLHdFQUNyQixLQUFLbkwsUUFBTCxDQUFjTyxFQURPLEdBQ0YsdUJBREUsSUFDeUI2RSxxQkFBc0JzRCxTQUFTQSxNQUFNbEQscUJBQXJDLElBQzNDa0QsU0FBU0EsTUFBTVUsaUNBRkcsQ0FBakIsQ0FBTjtBQUdEO0FBQ0QsUUFBSWdDLG9CQUFvQnRHLEtBQUtDLEdBQUwsQ0FBUyxDQUFULEVBQVl1QixtQkFBbUIsQ0FBQ3pCLEtBQUttRyxHQUFMLEtBQWFoSixTQUFkLElBQTJCLElBQTFELENBQXhCO0FBQ0EsVUFBTSxLQUFLakMsZ0JBQUwsQ0FBc0I4SyxnQkFBdEIsQ0FBdUMsS0FBSzdLLFFBQUwsQ0FBY08sRUFBckQsRUFBeUQsS0FBS2tFLGlCQUFMLENBQXVCRixhQUF2QixDQUF6RCxFQUNKd0csa0JBREksRUFDZ0JLLGlCQURoQixDQUFOO0FBRUQ7O0FBRUQ7OztBQUdBLFFBQU1DLEtBQU4sR0FBYztBQUNaLFFBQUksQ0FBQyxLQUFLbkYsT0FBVixFQUFtQjtBQUNqQixXQUFLaEYsT0FBTCxDQUFhb0ssS0FBYixDQUFvQixHQUFFLEtBQUt0TCxRQUFMLENBQWNPLEVBQUcsc0JBQXZDO0FBQ0EsV0FBS08scUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxZQUFNLEtBQUtmLGdCQUFMLENBQXNCd0wsV0FBdEIsQ0FBa0MsS0FBS3ZMLFFBQUwsQ0FBY08sRUFBaEQsQ0FBTjtBQUNBLFdBQUtSLGdCQUFMLENBQXNCc0ksNkJBQXRCLENBQW9ELEtBQUtySSxRQUFMLENBQWNPLEVBQWxFLEVBQXNFLElBQXRFO0FBQ0EsV0FBS1IsZ0JBQUwsQ0FBc0JzSSw2QkFBdEIsQ0FBb0QsS0FBS3JJLFFBQUwsQ0FBY08sRUFBbEUsRUFBc0UsS0FBS0osY0FBM0U7QUFDQSxXQUFLSixnQkFBTCxDQUFzQnNJLDZCQUF0QixDQUFvRCxLQUFLckksUUFBTCxDQUFjTyxFQUFsRSxFQUFzRSxLQUFLRixlQUEzRTtBQUNBLFdBQUtOLGdCQUFMLENBQXNCc0ksNkJBQXRCLENBQW9ELEtBQUtySSxRQUFMLENBQWNPLEVBQWxFLEVBQXNFLEtBQUtFLGNBQTNFO0FBQ0EsV0FBSyxJQUFJMkgsUUFBVCxJQUFxQixLQUFLbkgseUJBQTFCLEVBQXFEO0FBQ25ELGFBQUtsQixnQkFBTCxDQUFzQnNJLDZCQUF0QixDQUFvRCxLQUFLckksUUFBTCxDQUFjTyxFQUFsRSxFQUFzRTZILFFBQXRFO0FBQ0Q7QUFDRCxXQUFLckksZ0JBQUwsQ0FBc0J5TCx1QkFBdEIsQ0FBOEMsSUFBOUM7QUFDQSxXQUFLdkwsbUJBQUwsQ0FBeUJ3TCxNQUF6QixDQUFnQyxLQUFLekwsUUFBTCxDQUFjTyxFQUE5QztBQUNBLFdBQUtFLGNBQUwsQ0FBb0JpTCxJQUFwQjtBQUNBLFdBQUszSyxtQ0FBTCxHQUEyQyxFQUEzQztBQUNBLFdBQUttRixPQUFMLEdBQWUsSUFBZjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7QUFJQSxNQUFJMkMsWUFBSixHQUFtQjtBQUNqQixXQUFPLHNCQUFjLEtBQUsvSCxxQkFBbkIsRUFBMEM2SixNQUExQyxDQUFpRCxDQUFDQyxHQUFELEVBQU0xRCxDQUFOLEtBQVkwRCxPQUFPMUQsRUFBRTJCLFlBQXRFLEVBQW9GLEtBQXBGLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUkxSixPQUFKLEdBQWM7QUFDWixXQUFPLEtBQUthLFFBQVo7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUkyTCxhQUFKLEdBQW9CO0FBQ2xCLFdBQU8sS0FBS2xMLGNBQVo7QUFDRDs7QUFFRCxRQUFNZ0ssK0JBQU4sQ0FBc0NtQixjQUF0QyxFQUFzREMsT0FBdEQsRUFBK0Q7QUFDN0QsUUFBSTtBQUNGLFVBQUksS0FBSzlLLG1DQUFMLENBQXlDNkssY0FBekMsTUFBNkRDLE9BQWpFLEVBQTBFO0FBQ3hFLGNBQU1DLG9CQUFvQixFQUExQjtBQUNBLDRCQUFZLEtBQUtqTCxjQUFqQixFQUFpQzJGLE9BQWpDLENBQXlDaUMsT0FBTztBQUM5QyxnQkFBTXBDLGdCQUFnQixLQUFLQSxhQUFMLENBQW1Cb0MsR0FBbkIsQ0FBdEI7QUFDQSxnQkFBTXNELG9CQUFvQixFQUFDcEosUUFBUThGLEdBQVQsRUFBMUI7QUFDQSxjQUFHcEMsYUFBSCxFQUFrQjtBQUNoQjBGLDhCQUFrQjFGLGFBQWxCLEdBQWtDQSxhQUFsQztBQUNEO0FBQ0R5Riw0QkFBa0JoRixJQUFsQixDQUF1QmlGLGlCQUF2QjtBQUNELFNBUEQ7QUFRQSxjQUFNLEtBQUtoTSxnQkFBTCxDQUFzQmlNLDhCQUF0QixDQUFxRCxLQUFLaE0sUUFBTCxDQUFjTyxFQUFuRSxFQUF1RXFMLGNBQXZFLEVBQ0pFLGlCQURJLENBQU47QUFFRDtBQUNGLEtBZEQsQ0FjRSxPQUFPOUIsR0FBUCxFQUFZO0FBQ1osV0FBSzlJLE9BQUwsQ0FBYStJLEtBQWIsQ0FBb0IsOERBQTZELEtBQUtqSyxRQUFMLENBQWNPLEVBQUcsR0FBL0UsR0FDbEIsR0FBRXFMLGNBQWUsRUFEbEIsRUFDcUI1QixHQURyQjtBQUVELEtBakJELFNBaUJVO0FBQ1IsVUFBSSxLQUFLakosbUNBQUwsQ0FBeUM2SyxjQUF6QyxNQUE2REMsT0FBakUsRUFBMEU7QUFDeEUsWUFBSUksa0JBQWtCLENBQUNuSCxLQUFLb0gsTUFBTCxNQUFpQixLQUFLck0sK0JBQUwsR0FDdEMsS0FBS0gsK0JBRGdCLElBQ21CLEtBQUtBLCtCQUR6QixJQUM0RCxJQURsRjtBQUVBd0wsbUJBQVcsTUFBTSxLQUFLVCwrQkFBTCxDQUFxQ21CLGNBQXJDLEVBQXFEQyxPQUFyRCxDQUFqQixFQUFnRkksZUFBaEY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQvSSx1QkFBcUJMLFFBQXJCLEVBQStCQyxVQUEvQixFQUEyQztBQUN6QyxRQUFJRSxRQUFRLEVBQVo7QUFDQSxRQUFJLE9BQU9ILFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaENHLFlBQU1ILFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0QsS0FGRCxNQUVPLElBQUlBLFFBQUosRUFBYztBQUNuQkcsWUFBTUgsUUFBTixHQUFpQkEsU0FBU3NKLEtBQTFCO0FBQ0FuSixZQUFNb0osYUFBTixHQUFzQnZKLFNBQVN3SixLQUEvQjtBQUNEO0FBQ0QsUUFBSSxPQUFPdkosVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQ0UsWUFBTUYsVUFBTixHQUFtQkEsVUFBbkI7QUFDRCxLQUZELE1BRU8sSUFBSUEsVUFBSixFQUFnQjtBQUNyQkUsWUFBTUYsVUFBTixHQUFtQkEsV0FBV3FKLEtBQTlCO0FBQ0FuSixZQUFNc0osZUFBTixHQUF3QnhKLFdBQVd1SixLQUFuQztBQUNEO0FBQ0QsV0FBT3JKLEtBQVA7QUFDRDs7QUFFRCxRQUFNOEYsbUJBQU4sQ0FBMEJ2RSxhQUExQixFQUF5Q2tFLEdBQXpDLEVBQThDO0FBQzVDLFFBQUlDLFFBQVEsS0FBS25ELFNBQUwsQ0FBZWhCLGFBQWYsQ0FBWjtBQUNBLFFBQUltRSxTQUFTLENBQUMsS0FBS3hDLE9BQW5CLEVBQTRCO0FBQzFCLFVBQUk7QUFDRixjQUFNcUcsd0JBQXdCLE1BQU0sS0FBS2pJLFdBQUwsQ0FBaUJDLGFBQWpCLENBQXBDO0FBQ0EsWUFBR2dJLHFCQUFILEVBQTBCO0FBQ3hCN0QsZ0JBQU1HLFlBQU4sR0FBcUIsSUFBckI7QUFDQUgsZ0JBQU1FLHFDQUFOLEdBQThDLENBQTlDO0FBQ0Q7QUFDRixPQU5ELENBTUUsT0FBT29CLEdBQVAsRUFBWTtBQUNaLGFBQUs5SSxPQUFMLENBQWErSSxLQUFiLENBQW1CLDBDQUEwQyxLQUFLakssUUFBTCxDQUFjTyxFQUF4RCxHQUNqQixHQURpQixHQUNYZ0UsYUFEVyxHQUNLLHdCQUR4QixFQUNrRHlGLEdBRGxEO0FBRUEsWUFBSXRCLE1BQU1DLGlCQUFOLEtBQTRCRixHQUFoQyxFQUFxQztBQUNuQ3lDLHFCQUFXLEtBQUtwQyxtQkFBTCxDQUF5QjBELElBQXpCLENBQThCLElBQTlCLEVBQW9DakksYUFBcEMsRUFBbURrRSxHQUFuRCxDQUFYLEVBQ0VDLE1BQU1FLHFDQUFOLEdBQThDLElBRGhEO0FBRUFGLGdCQUFNRSxxQ0FBTixHQUE4QzlELEtBQUsySCxHQUFMLENBQVMvRCxNQUFNRSxxQ0FBTixHQUE4QyxDQUF2RCxFQUEwRCxHQUExRCxDQUE5QztBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEckQsWUFBVWhCLGFBQVYsRUFBeUI7QUFDdkIsUUFBSSxDQUFDLEtBQUt6RCxxQkFBTCxDQUEyQixLQUFLeUQsYUFBaEMsQ0FBTCxFQUFxRDtBQUNuRCxXQUFLekQscUJBQUwsQ0FBMkIsS0FBS3lELGFBQWhDLElBQWlEO0FBQy9DQSxxQkFEK0M7QUFFL0NtRiw0QkFBb0IsRUFGMkI7QUFHL0NGLDJCQUFtQixFQUg0QjtBQUkvQ2IsMkJBQW1CVSxTQUo0QjtBQUsvQ1QsK0NBQXVDLENBTFE7QUFNL0NDLHNCQUFjLEtBTmlDO0FBTy9DTywyQ0FBbUNDLFNBUFk7QUFRL0M3RCwrQkFBdUI2RCxTQVJ3QjtBQVMvQ0Msc0JBQWM7QUFUaUMsT0FBakQ7QUFXRDtBQUNELFdBQU8sS0FBS3hJLHFCQUFMLENBQTJCLEtBQUt5RCxhQUFoQyxDQUFQO0FBQ0Q7O0FBMy9Cb0U7a0JBQWxEeEYsaUIiLCJmaWxlIjoibWV0YUFwaUNvbm5lY3Rpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUZXJtaW5hbFN0YXRlIGZyb20gJy4vdGVybWluYWxTdGF0ZSc7XG5pbXBvcnQgTWVtb3J5SGlzdG9yeVN0b3JhZ2UgZnJvbSAnLi9tZW1vcnlIaXN0b3J5U3RvcmFnZSc7XG5pbXBvcnQgU3luY2hyb25pemF0aW9uTGlzdGVuZXIgZnJvbSAnLi4vY2xpZW50cy9tZXRhQXBpL3N5bmNocm9uaXphdGlvbkxpc3RlbmVyJztcbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vY2xpZW50cy90aW1lb3V0RXJyb3InO1xuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuaW1wb3J0IENvbm5lY3Rpb25IZWFsdGhNb25pdG9yIGZyb20gJy4vY29ubmVjdGlvbkhlYWx0aE1vbml0b3InO1xuaW1wb3J0IE9wdGlvbnNWYWxpZGF0b3IgZnJvbSAnLi4vY2xpZW50cy9vcHRpb25zVmFsaWRhdG9yJztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5cbi8qKlxuICogRXhwb3NlcyBNZXRhQXBpIE1ldGFUcmFkZXIgQVBJIGNvbm5lY3Rpb24gdG8gY29uc3VtZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGFBcGlDb25uZWN0aW9uIGV4dGVuZHMgU3luY2hyb25pemF0aW9uTGlzdGVuZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgTWV0YVRyYWRlciBBcGkgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IHdlYnNvY2tldENsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudH0gYWNjb3VudCBNZXRhVHJhZGVyIGFjY291bnQgaWQgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0ge0hpc3RvcnlTdG9yYWdlfSBoaXN0b3J5U3RvcmFnZSB0ZXJtaW5hbCBoaXN0b3J5IHN0b3JhZ2UuIEJ5IGRlZmF1bHQgYW4gaW5zdGFuY2Ugb2YgTWVtb3J5SGlzdG9yeVN0b3JhZ2VcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25SZWdpc3RyeX0gY29ubmVjdGlvblJlZ2lzdHJ5IG1ldGF0cmFkZXIgYWNjb3VudCBjb25uZWN0aW9uIHJlZ2lzdHJ5XG4gICAqIEBwYXJhbSB7RGF0ZX0gW2hpc3RvcnlTdGFydFRpbWVdIGhpc3Rvcnkgc3RhcnQgc3luYyB0aW1lXG4gICAqIEBwYXJhbSB7UmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzfSBbcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzXSBzdWJzY3JpcHRpb25zIHJlZnJlc2ggb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2Vic29ja2V0Q2xpZW50LCBhY2NvdW50LCBoaXN0b3J5U3RvcmFnZSwgY29ubmVjdGlvblJlZ2lzdHJ5LCBoaXN0b3J5U3RhcnRUaW1lLFxuICAgIHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzID0gcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIHx8IHt9O1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgdGhpcy5fbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWluRGVsYXlJblNlY29uZHMsIDEsXG4gICAgICAncmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzLm1pbkRlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4U3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWF4RGVsYXlJblNlY29uZHMsIDYwMCxcbiAgICAgICdyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWF4RGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQgPSB3ZWJzb2NrZXRDbGllbnQ7XG4gICAgdGhpcy5fYWNjb3VudCA9IGFjY291bnQ7XG4gICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5ID0gY29ubmVjdGlvblJlZ2lzdHJ5O1xuICAgIHRoaXMuX2hpc3RvcnlTdGFydFRpbWUgPSBoaXN0b3J5U3RhcnRUaW1lO1xuICAgIHRoaXMuX3Rlcm1pbmFsU3RhdGUgPSBuZXcgVGVybWluYWxTdGF0ZSgpO1xuICAgIHRoaXMuX2hpc3RvcnlTdG9yYWdlID0gaGlzdG9yeVN0b3JhZ2UgfHwgbmV3IE1lbW9yeUhpc3RvcnlTdG9yYWdlKGFjY291bnQuaWQsIGNvbm5lY3Rpb25SZWdpc3RyeS5hcHBsaWNhdGlvbik7XG4gICAgdGhpcy5faGVhbHRoTW9uaXRvciA9IG5ldyBDb25uZWN0aW9uSGVhbHRoTW9uaXRvcih0aGlzKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcyk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMuX3Rlcm1pbmFsU3RhdGUpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl9oaXN0b3J5U3RvcmFnZSk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMuX2hlYWx0aE1vbml0b3IpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRSZWNvbm5lY3RMaXN0ZW5lcih0aGlzLCBhY2NvdW50LmlkKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnNKb2JzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemVkID0gZmFsc2U7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlDb25uZWN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGluZm9ybWF0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRBY2NvdW50SW5mb3JtYXRpb24vKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0QWNjb3VudEluZm9ybWF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudEluZm9ybWF0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcG9zaXRpb25zIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRQb3NpdGlvbnMvKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhcnJheSBvZiBvcGVuIHBvc2l0aW9uc1xuICAgKi9cbiAgZ2V0UG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0UG9zaXRpb25zKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgcG9zaXRpb24gKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFBvc2l0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWV0YXRyYWRlclBvc2l0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBNZXRhVHJhZGVyIHBvc2l0aW9uIGZvdW5kXG4gICAqL1xuICBnZXRQb3NpdGlvbihwb3NpdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRQb3NpdGlvbih0aGlzLl9hY2NvdW50LmlkLCBwb3NpdGlvbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9wZW4gb3JkZXJzIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlcnMvKS5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyT3JkZXI+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcGVuIE1ldGFUcmFkZXIgb3JkZXJzXG4gICAqL1xuICBnZXRPcmRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRPcmRlcnModGhpcy5fYWNjb3VudC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzcGVjaWZpYyBvcGVuIG9yZGVyIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlci8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyT3JkZXI+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1ldGF0cmFkZXIgb3JkZXIgZm91bmRcbiAgICovXG4gIGdldE9yZGVyKG9yZGVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldE9yZGVyKHRoaXMuX2FjY291bnQuaWQsIG9yZGVySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3Rvcnkgb2YgY29tcGxldGVkIG9yZGVycyBmb3IgYSBzcGVjaWZpYyB0aWNrZXQgbnVtYmVyIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5VGlja2V0LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAob3JkZXIgaWQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0KHRpY2tldCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0KHRoaXMuX2FjY291bnQuaWQsIHRpY2tldCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5UG9zaXRpb24vKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKHBvc2l0aW9uSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKHRoaXMuX2FjY291bnQuaWQsIHBvc2l0aW9uSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3Rvcnkgb2YgY29tcGxldGVkIG9yZGVycyBmb3IgYSBzcGVjaWZpYyB0aW1lIHJhbmdlIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlLylcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0ID0gMCwgbGltaXQgPSAxMDAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UodGhpcy5fYWNjb3VudC5pZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGVhbHMgd2l0aCBhIHNwZWNpZmljIHRpY2tldCBudW1iZXIgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWREZWFsc0J5VGlja2V0LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAoZGVhbCBpZCBmb3IgTVQ1IG9yIG9yZGVyIGlkIGZvciBNVDQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlUaWNrZXQodGlja2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXREZWFsc0J5VGlja2V0KHRoaXMuX2FjY291bnQuaWQsIHRpY2tldCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVBvc2l0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlQb3NpdGlvbihwb3NpdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXREZWFsc0J5UG9zaXRpb24odGhpcy5fYWNjb3VudC5pZCwgcG9zaXRpb25JZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlUaW1lUmFuZ2UvKS5cbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlUaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQgPSAwLCBsaW1pdCA9IDEwMDApIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldERlYWxzQnlUaW1lUmFuZ2UodGhpcy5fYWNjb3VudC5pZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIG9yZGVyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5IG9mIGEgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIHNvIHRoYXQgaXQgY2FuIGJlIHN5bmNocm9uaXplZCBmcm9tIHNjcmF0Y2hcbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZW1vdmVIaXN0b3J5LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYXBwbGljYXRpb25dIGFwcGxpY2F0aW9uIHRvIHJlbW92ZSBoaXN0b3J5IGZvclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWRcbiAgICovXG4gIHJlbW92ZUhpc3RvcnkoYXBwbGljYXRpb24pIHtcbiAgICB0aGlzLl9oaXN0b3J5U3RvcmFnZS5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlSGlzdG9yeSh0aGlzLl9hY2NvdW50LmlkLCBhcHBsaWNhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcmRlciBhbmQgdHJhbnNhY3Rpb24gaGlzdG9yeSBvZiBhIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBhbmQgcmVtb3ZlcyBhcHBsaWNhdGlvbiAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlbW92ZUFwcGxpY2F0aW9uLykuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGhpc3RvcnkgaXMgY2xlYXJlZCBhbmQgYXBwbGljYXRpb24gaXMgcmVtb3ZlZFxuICAgKi9cbiAgcmVtb3ZlQXBwbGljYXRpb24oKSB7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFwcGxpY2F0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1vbiB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYWRlT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbW1lbnRdIG9wdGlvbmFsIG9yZGVyIGNvbW1lbnQuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGUgY29tbWVudCBhbmQgdGhlXG4gICAqIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIG9wdGlvbmFsIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYWdpY10gb3B0aW9uYWwgbWFnaWMgKGV4cGVydCBpZCkgbnVtYmVyLiBJZiBub3Qgc2V0IGRlZmF1bHQgdmFsdWUgc3BlY2lmaWVkIGluIGFjY291bnQgZW50aXR5XG4gICAqIHdpbGwgYmUgdXNlZC5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzbGlwcGFnZV0gb3B0aW9uYWwgc2xpcHBhZ2UgaW4gcG9pbnRzLiBTaG91bGQgYmUgZ3JlYXRlciBvciBlcXVhbCB0byB6ZXJvLiBJbiBub3Qgc2V0LFxuICAgKiBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiBhY2NvdW50IGVudGl0eSB3aWxsIGJlIHVzZWQuIFNsaXBwYWdlIGlzIGlnbm9yZWQgaWYgZXhlY3V0aW9uIG1vZGUgc2V0IHRvXG4gICAqIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fTUFSS0VUIGluIHN5bWJvbCBzcGVjaWZpY2F0aW9uLiBOb3QgdXNlZCBmb3IgY2xvc2UgYnkgb3JkZXJzLlxuICAgKi9cblxuICAvKipcbiAgICogTWFya2V0IHRyYWRlIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge1RyYWRlT3B0aW9uc30gTWFya2V0VHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gW2ZpbGxpbmdNb2Rlc10gb3B0aW9uYWwgYWxsb3dlZCBmaWxsaW5nIG1vZGVzIGluIHRoZSBvcmRlciBvZiBwcmlvcml0eS4gRGVmYXVsdCBpcyB0b1xuICAgKiBhbGxvdyBhbGwgZmlsbGluZyBtb2RlcyBhbmQgcHJlZmVyIE9SREVSX0ZJTExJTkdfRk9LIG92ZXIgT1JERVJfRklMTElOR19JT0MuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfZmlsbGluZyBmb3IgZXh0cmFcbiAgICogZXhwbGFuYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIFBlbmRpbmcgb3JkZXIgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7VHJhZGVPcHRpb25zfSBQZW5kaW5nVHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7RXhwaXJhdGlvbk9wdGlvbnN9IFtleHBpcmF0aW9uXSBvcHRpb25hbCBwZW5kaW5nIG9yZGVyIGV4cGlyYXRpb24gc2V0dGluZ3MuIFNlZSBQZW5kaW5nIG9yZGVyIGV4cGlyYXRpb25cbiAgICogc2V0dGluZ3Mgc2VjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogUGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHNldHRpbmdzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEV4cGlyYXRpb25PcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiB0eXBlLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX3RpbWUgZm9yIHRoZSBsaXN0IG9mXG4gICAqIHBvc3NpYmxlIG9wdGlvbnMuIE1ldGFUcmFkZXI0IHBsYXRmb3JtIHN1cHBvcnRzIG9ubHkgT1JERVJfVElNRV9TUEVDSUZJRUQgZXhwaXJhdGlvbiB0eXBlLiBPbmUgb2YgT1JERVJfVElNRV9HVEMsXG4gICAqIE9SREVSX1RJTUVfREFZLCBPUkRFUl9USU1FX1NQRUNJRklFRCwgT1JERVJfVElNRV9TUEVDSUZJRURfREFZXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW3RpbWVdIG9wdGlvbmFsIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiB0aW1lLiBJZ25vcmVkIGlmIGV4cGlyYXRpb24gdHlwZSBpcyBub3Qgb25lIG9mXG4gICAqIE9SREVSX1RJTUVfREFZIG9yIE9SREVSX1RJTUVfU1BFQ0lGSUVEXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTdG9wIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge09iamVjdH0gU3RvcE9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZhbHVlIHN0b3AgKFNMIG9yIFRQKSB2YWx1ZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5pdHMgc3RvcCB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIHZhbHVlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCB2YWx1ZS5cbiAgICogUkVMQVRJVkVfKiBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmaWVsZCB2YWx1ZSBjb250YWlucyByZWxhdGl2ZSBzdG9wIGV4cHJlc3NlZCBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgYWNjb3VudFxuICAgKiBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIEFsbG93ZWQgdmFsdWVzIGFyZSBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsXG4gICAqIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfQ1VSUkVOQ1ksIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBidXkgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZJywgc3ltYm9sLCB2b2x1bWV9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFya2V0IHNlbGwgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRTZWxsT3JkZXIoc3ltYm9sLCB2b2x1bWUsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLCBzeW1ib2wsIHZvbHVtZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBidXkgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIGxpbWl0IHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVMaW1pdEJ1eU9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGltaXQgc2VsbCBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTExfTElNSVQnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3AgYnV5IG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wQnV5T3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3Agc2VsbCBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1BlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlU3RvcFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCBPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3AgbGltaXQgYnV5IG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1BfTElNSVQnLFxuICAgICAgc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExpbWl0UHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdG9wIGxpbWl0IHNlbGwgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0b3BMaW1pdFByaWNlIHRoZSBsaW1pdCBvcmRlciBwcmljZSBmb3IgdGhlIHN0b3AgbGltaXQgb3JkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BMaW1pdFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTF9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBtb2RpZnlQb3NpdGlvbihwb3NpdGlvbklkLCBzdG9wTG9zcywgdGFrZVByb2ZpdCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX01PRElGWScsIHBvc2l0aW9uSWR9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY2xvc2VzIGEgcG9zaXRpb24gKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZCB0byBtb2RpZnlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSB2b2x1bWUgdG8gY2xvc2VcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VQb3NpdGlvblBhcnRpYWxseShwb3NpdGlvbklkLCB2b2x1bWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX1BBUlRJQUwnLCBwb3NpdGlvbklkLFxuICAgICAgdm9sdW1lfSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGNsb3NlcyBhIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb24ocG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCBPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnUE9TSVRJT05fQ0xPU0VfSUQnLCBwb3NpdGlvbklkfSxcbiAgICAgIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBjbG9zZXMgYSBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIGNsb3NlIGJ5IG9wcG9zaXRlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHBvc2l0ZVBvc2l0aW9uSWQgb3Bwb3NpdGUgcG9zaXRpb24gaWQgdG8gY2xvc2VcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VCeShwb3NpdGlvbklkLCBvcHBvc2l0ZVBvc2l0aW9uSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0JZJywgcG9zaXRpb25JZCxcbiAgICAgIGNsb3NlQnlQb3NpdGlvbklkOiBvcHBvc2l0ZVBvc2l0aW9uSWR9LCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHBvc2l0aW9ucyBieSBhIHN5bWJvbChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VQb3NpdGlvbnNCeVN5bWJvbChzeW1ib2wsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OU19DTE9TRV9TWU1CT0wnLCBzeW1ib2x9LFxuICAgICAgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcGVuZGluZyBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIG1vZGlmeU9yZGVyKG9yZGVySWQsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9NT0RJRlknLCBvcmRlcklkLCBvcGVuUHJpY2V9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yZGVySWQgb3JkZXIgaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjYW5jZWxPcmRlcihvcmRlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCB7YWN0aW9uVHlwZTogJ09SREVSX0NBTkNFTCcsIG9yZGVySWR9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbm5lY3RzIHRvIHRoZSBNZXRhdHJhZGVyIHRlcm1pbmFsIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVjb25uZWN0LykuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gcmVjb25uZWN0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlY29ubmVjdCh0aGlzLl9hY2NvdW50LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgdGVybWluYWwgdG8gc3RhcnQgc3luY2hyb25pemF0aW9uIHByb2Nlc3NcbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L3N5bmNocm9uaXppbmcvc3luY2hyb25pemUvKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICBhc3luYyBzeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGhvc3QgPSB0aGlzLmdldEhvc3ROYW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGxldCBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUgPSBuZXcgRGF0ZShNYXRoLm1heChcbiAgICAgICh0aGlzLl9oaXN0b3J5U3RhcnRUaW1lIHx8IG5ldyBEYXRlKDApKS5nZXRUaW1lKCksXG4gICAgICAoYXdhaXQgdGhpcy5faGlzdG9yeVN0b3JhZ2UubGFzdEhpc3RvcnlPcmRlclRpbWUoaW5zdGFuY2UpKS5nZXRUaW1lKClcbiAgICApKTtcbiAgICBsZXQgc3RhcnRpbmdEZWFsVGltZSA9IG5ldyBEYXRlKE1hdGgubWF4KFxuICAgICAgKHRoaXMuX2hpc3RvcnlTdGFydFRpbWUgfHwgbmV3IERhdGUoMCkpLmdldFRpbWUoKSxcbiAgICAgIChhd2FpdCB0aGlzLl9oaXN0b3J5U3RvcmFnZS5sYXN0RGVhbFRpbWUoaW5zdGFuY2UpKS5nZXRUaW1lKClcbiAgICApKTtcbiAgICBsZXQgc3luY2hyb25pemF0aW9uSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmxhc3RTeW5jaHJvbml6YXRpb25JZCA9IHN5bmNocm9uaXphdGlvbklkO1xuICAgIGNvbnN0IGhhc2hlcyA9IHRoaXMudGVybWluYWxTdGF0ZS5nZXRIYXNoZXModGhpcy5fYWNjb3VudC50eXBlKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnN5bmNocm9uaXplKHRoaXMuX2FjY291bnQuaWQsIGluc3RhbmNlLCBob3N0LCBzeW5jaHJvbml6YXRpb25JZCxcbiAgICAgIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSwgaGFzaGVzLnNwZWNpZmljYXRpb25zTWQ1LCBoYXNoZXMucG9zaXRpb25zTWQ1LCBoYXNoZXMub3JkZXJzTWQ1KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBtZXRhIGFwaSBjb25uZWN0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBtZXRhIGFwaSBjb25uZWN0aW9uIGlzIGluaXRpYWxpemVkXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgc3Vic2NyaXB0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzdWJzY3JpcHRpb24gaXMgaW5pdGlhdGVkXG4gICAqL1xuICBhc3luYyBzdWJzY3JpYmUoKSB7XG4gICAgaWYoIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZSh0aGlzLl9hY2NvdW50LmlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3N1YnNjcmliZVRvTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlLiBQbGVhc2VcbiAgICogbm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgb24gc2VydmVyLXNpZGUgeWV0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gdGltZW91dCB0byB3YWl0IGZvciBwcmljZXMgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIGluc3RhbmNlSW5kZXgsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucyB8fCBbe3R5cGU6ICdxdW90ZXMnfV07XG4gICAgaWYodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICBjb25zdCBwcmV2U3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zO1xuICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YnNjcmlwdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaXB0aW9uLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUgJiYgXG4gICAgICAgICAgICBpdGVtLnRpbWVmcmFtZSA9PT0gc3Vic2NyaXB0aW9uLnRpbWVmcmFtZSkgOlxuICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICBpZihpbmRleCA9PT0gLTEpe1xuICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2U3Vic2NyaXB0aW9uc1tpbmRleF0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC5zdWJzY3JpYmVUb01hcmtldERhdGEodGhpcy5fYWNjb3VudC5pZCwgaW5zdGFuY2VJbmRleCwgc3ltYm9sLCBzdWJzY3JpcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy50ZXJtaW5hbFN0YXRlLndhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIG1hcmtldCBkYXRhIG9mIHNwZWNpZmllZCBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L21hcmtldERhdGFTdHJlYW1pbmcvdW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFVbnN1YnNjcmlwdGlvbj59IHN1YnNjcmlwdGlvbnMgYXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyB0byBjYW5jZWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlSW5kZXggaW5zdGFuY2UgaW5kZXhcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCBzdWJzY3JpcHRpb25zLCBpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zXG4gICAgICAgIC5maWx0ZXIocyA9PiBzLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgICFzdWJzY3JpcHRpb25zLmZpbmQoczIgPT4gcy50eXBlID09PSBzMi50eXBlICYmIHMudGltZWZyYW1lID09PSBzMi50aW1lZnJhbWUpIDogXG4gICAgICAgICAgIXN1YnNjcmlwdGlvbnMuZmluZChzMiA9PiBzLnR5cGUgPT09IHMyLnR5cGUpKTtcbiAgICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBpbnN0YW5jZUluZGV4LCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBzdWJzY3JpcHRpb24gZG93bmdyYWRlIGhhcyBvY2N1cnJlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB1cGRhdGUgc3Vic2NyaXB0aW9ucyBmb3JcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gdXBkYXRlcyBhcnJheSBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb24gdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVVuc3Vic2NyaXB0aW9uPn0gdW5zdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkKGluc3RhbmNlSW5kZXgsIHN5bWJvbCwgdXBkYXRlcywgdW5zdWJzY3JpcHRpb25zKSB7XG4gICAgbGV0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgaWYgKHVuc3Vic2NyaXB0aW9ucyAmJiB1bnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBzdWJzY3JpcHRpb24gb2YgdW5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnMuZmlsdGVyKHMgPT4gcy50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YShzeW1ib2wsIHVuc3Vic2NyaXB0aW9ucyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVzICYmIHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBzdWJzY3JpcHRpb24gb2YgdXBkYXRlcykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZmlsdGVyKHMgPT4gcy50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHMgPT4gcy5pbnRlcnZhbEluTWlsbGlpc2Vjb25kcyA9IHN1YnNjcmlwdGlvbi5pbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zdWJzY3JpYmVUb01hcmtldERhdGEoc3ltYm9sLCB1cGRhdGVzKTtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmlwdGlvbnMgJiYgIXN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgdGhlIHN5bWJvbHMgY29ubmVjdGlvbiBpcyBzdWJzY3JpYmVkIHRvXG4gICAqIEByZXR1cm5zIHtBcnJheTxTdHJpbmc+fSBsaXN0IG9mIHRoZSBzeW1ib2xzIGNvbm5lY3Rpb24gaXMgc3Vic2NyaWJlZCB0b1xuICAgKi9cbiAgZ2V0IHN1YnNjcmliZWRTeW1ib2xzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN1YnNjcmlwdGlvbnMgZm9yIGEgc3ltYm9sXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHN1YnNjcmlwdGlvbnMgZm9yXG4gICAqIEByZXR1cm5zIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gbGlzdCBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb25zIGZvciB0aGUgc3ltYm9sXG4gICAqL1xuICBzdWJzY3JpcHRpb25zKHN5bWJvbCkge1xuICAgIHJldHVybiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IHt9KS5zdWJzY3JpcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhdmFpbGFibGUgc3ltYm9scyBmb3IgYW4gYWNjb3VudCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9scy8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzeW1ib2xzIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bWJvbHMgYXJlIHJldHJpZXZlZFxuICAgKi9cbiAgZ2V0U3ltYm9scygpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldFN5bWJvbHModGhpcy5fYWNjb3VudC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHNwZWNpZmljYXRpb24gZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xTcGVjaWZpY2F0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNwZWNpZmljYXRpb24gaXMgcmV0cmlldmVkXG4gICAqL1xuICBnZXRTeW1ib2xTcGVjaWZpY2F0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbih0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3QgcHJpY2UgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xQcmljZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBwcmljZSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclN5bWJvbFByaWNlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHByaWNlIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgZ2V0U3ltYm9sUHJpY2Uoc3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRTeW1ib2xQcmljZSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3QgY2FuZGxlIGZvciBhIHN5bWJvbCBhbmQgdGltZWZyYW1lIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRDYW5kbGUvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgY2FuZGxlIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZWZyYW1lIGRlZmluZXMgdGhlIHRpbWVmcmFtZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGNhbmRsZSBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXMgZm9yXG4gICAqIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWQgdmFsdWVzXG4gICAqIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQ2FuZGxlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNhbmRsZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGdldENhbmRsZShzeW1ib2wsIHRpbWVmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0Q2FuZGxlKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCwgdGltZWZyYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IHRpY2sgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRUaWNrLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2sgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUaWNrPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRpY2sgaXMgcmV0cmlldmVkXG4gICAqL1xuICBnZXRUaWNrKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0VGljayh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3Qgb3JkZXIgYm9vayBmb3IgYSBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZEJvb2svKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgb3JkZXIgYm9vayBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRpY2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gb3JkZXIgYm9vayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGdldEJvb2soc3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRCb29rKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHVwdGltZSBzdGF0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdXB0aW1lIHVwdGltZSBzdGF0aXN0aWNzIHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHVwdGltZSBzdGF0aXN0aWNzIGlzIHN1Ym1pdHRlZFxuICAgKi9cbiAgc2F2ZVVwdGltZSh1cHRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnNhdmVVcHRpbWUodGhpcy5fYWNjb3VudC5pZCwgdXB0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICogQHJldHVybnMge1Rlcm1pbmFsU3RhdGV9IGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICovXG4gIGdldCB0ZXJtaW5hbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXJtaW5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqIEByZXR1cm5zIHtIaXN0b3J5U3RvcmFnZX0gbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqL1xuICBnZXQgaGlzdG9yeVN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcnlTdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uTGlzdGVuZXJ9IGxpc3RlbmVyIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciB0byBhZGRcbiAgICovXG4gIGFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgZm9yIHNwZWNpZmljIGFjY291bnRcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25MaXN0ZW5lcn0gbGlzdGVuZXIgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwbGljYXMgbnVtYmVyIG9mIGFjY291bnQgcmVwbGljYXMgbGF1bmNoZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkNvbm5lY3RlZChpbnN0YW5jZUluZGV4LCByZXBsaWNhcykge1xuICAgIGxldCBrZXkgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0ga2V5O1xuICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSAxO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpO1xuICAgIGxldCBpbmRpY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXBsaWNhczsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuICAgIGZvciAobGV0IGUgb2YgT2JqZWN0LmVudHJpZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpKSB7XG4gICAgICBpZiAoIWluZGljZXMuaW5jbHVkZXModGhpcy5nZXRJbnN0YW5jZU51bWJlcihlWzFdLmluc3RhbmNlSW5kZXgpKSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbZVswXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKi9cbiAgYXN5bmMgb25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCA9IHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZDtcbiAgICBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUuc2hvdWxkU3luY2hyb25pemUgPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUuc3luY2hyb25pemVkID0gZmFsc2U7XG4gICAgc3RhdGUuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uc0pvYnNbaW5zdGFuY2VdO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bmNocm9uaXphdGlvbiBvZiBoaXN0b3J5IGRlYWxzIG9uIGEgTWV0YVRyYWRlciBhY2NvdW50IGhhdmUgZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW5cbiAgICogaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25EZWFsc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmRlYWxzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3Rvcnkgb3JkZXJzIG9uIGEgTWV0YVRyYWRlciBhY2NvdW50IGhhdmUgZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW5cbiAgICogaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvbiBpcyB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbn0gYWNjb3VudEluZm9ybWF0aW9uIHVwZGF0ZWQgTWV0YVRyYWRlciBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGFjY291bnRJbmZvcm1hdGlvbikge1xuICAgIGZvcihsZXQgc3ltYm9sIG9mIHRoaXMuc3Vic2NyaWJlZFN5bWJvbHMpIHtcbiAgICAgIGlmKCF0aGlzLl90ZXJtaW5hbFN0YXRlLnByaWNlKHN5bWJvbCkpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5zdWJzY3JpYmVUb01hcmtldERhdGEoc3ltYm9sLCB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucywgaW5zdGFuY2UpKVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZm9yIGFjY291bnQgJyArIHRoaXMuX2FjY291bnQuaWQgK1xuICAgICAgICAgICAgJzonICsgaW5zdGFuY2VJbmRleCArICcgZmFpbGVkIHRvIHJlc3Vic2NyaWJlIHRvIHN5bWJvbCAnICsgc3ltYm9sLCBlcnIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YUFwaSB3ZWJzb2NrZXQgQVBJIHJlc3RvcmVkIGFmdGVyIGEgZGlzY29ubmVjdFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqL1xuICBhc3luYyBvblJlY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4ID0ge307XG4gICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zSm9icyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN0cmVhbSBmb3IgYW4gaW5zdGFuY2UgaW5kZXggaXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25TdHJlYW1DbG9zZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb24gaXMgc3RhcnRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNwZWNpZmljYXRpb25zVXBkYXRlZCB3aGV0aGVyIHNwZWNpZmljYXRpb25zIGFyZSBnb2luZyB0byBiZSB1cGRhdGVkIGR1cmluZyBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBwb3NpdGlvbnNVcGRhdGVkIHdoZXRoZXIgcG9zaXRpb25zIGFyZSBnb2luZyB0byBiZSB1cGRhdGVkIGR1cmluZyBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBvcmRlcnNVcGRhdGVkIHdoZXRoZXIgb3JkZXJzIGFyZSBnb2luZyB0byBiZSB1cGRhdGVkIGR1cmluZyBzeW5jaHJvbml6YXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNVcGRhdGVkLCBwb3NpdGlvbnNVcGRhdGVkLCBvcmRlcnNVcGRhdGVkKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnNKb2JzW2luc3RhbmNlXTtcbiAgICBsZXQgc2Vzc2lvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnNKb2JzW2luc3RhbmNlXSA9IHNlc3Npb25JZDtcbiAgICBhd2FpdCB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMoaW5zdGFuY2UsIHNlc3Npb25JZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIG9wdGlvbmFsIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZFxuICAgKiBieSBkZWZhdWx0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYSBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXJcbiAgICogdGVybWluYWxcbiAgICovXG4gIGFzeW5jIGlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2VJbmRleCAhPT0gdW5kZWZpbmVkICYmIHMuaW5zdGFuY2VJbmRleCAhPT0gaW5zdGFuY2VJbmRleCkge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgc3luY2hyb25pemF0aW9uSWQgPSBzeW5jaHJvbml6YXRpb25JZCB8fCBzLmxhc3RTeW5jaHJvbml6YXRpb25JZDtcbiAgICAgIGxldCBzeW5jaHJvbml6ZWQgPSAhIXMub3JkZXJzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSAmJiAhIXMuZGVhbHNTeW5jaHJvbml6ZWRbc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgcmV0dXJuIGFjYyB8fCBzeW5jaHJvbml6ZWQ7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFN5bmNocm9uaXphdGlvbk9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFthcHBsaWNhdGlvblBhdHRlcm5dIGFwcGxpY2F0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCBkZWZhdWx0IGlzIC4qXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3luY2hyb25pemF0aW9uSWRdIHN5bmNocm9uaXphdGlvbiBpZCwgbGFzdCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZCB3aWxsIGJlIHVzZWQgYnlcbiAgICogZGVmYXVsdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2luc3RhbmNlSW5kZXhdIGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgdG8gZW5zdXJlIHN5bmNocm9uaXphdGlvbiBvbiwgZGVmYXVsdCBpcyB0byB3YWl0XG4gICAqIGZvciB0aGUgZmlyc3QgaW5zdGFuY2UgdG8gc3luY2hyb25pemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ludGVydmFsSW5NaWxsaXNlY29uZHNdIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25PcHRpb25zfSBzeW5jaHJvbml6YXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29tcGxldGVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYXBwbGljYXRpb24gZmFpbGVkIHRvIHN5bmNocm9uaXplIHdpdGggdGhlIHRlbWluYWwgd2l0aGluZyB0aW1lb3V0IGFsbG93ZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIHdhaXRTeW5jaHJvbml6ZWQob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGxldCBpbnN0YW5jZUluZGV4ID0gb3B0cy5pbnN0YW5jZUluZGV4O1xuICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IG9wdHMuc3luY2hyb25pemF0aW9uSWQ7XG4gICAgbGV0IHRpbWVvdXRJblNlY29uZHMgPSBvcHRzLnRpbWVvdXRJblNlY29uZHMgfHwgMzAwO1xuICAgIGxldCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gb3B0cy5pbnRlcnZhbEluTWlsbGlzZWNvbmRzIHx8IDEwMDA7XG4gICAgbGV0IGFwcGxpY2F0aW9uUGF0dGVybiA9IG9wdHMuYXBwbGljYXRpb25QYXR0ZXJuIHx8XG4gICAgICAodGhpcy5fYWNjb3VudC5hcHBsaWNhdGlvbiA9PT0gJ0NvcHlGYWN0b3J5JyA/ICdDb3B5RmFjdG9yeS4qfFJQQycgOiAnUlBDJyk7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHN5bmNocm9uaXplZDtcbiAgICB3aGlsZSAoIShzeW5jaHJvbml6ZWQgPSBhd2FpdCB0aGlzLmlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkgJiZcbiAgICAgIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIGludGVydmFsSW5NaWxsaXNlY29uZHMpKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlO1xuICAgIGlmIChpbnN0YW5jZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAobGV0IHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkpIHtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuaXNTeW5jaHJvbml6ZWQocy5pbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkpIHtcbiAgICAgICAgICBzdGF0ZSA9IHM7XG4gICAgICAgICAgaW5zdGFuY2VJbmRleCA9IHMuaW5zdGFuY2VJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZpbmQocyA9PiBzLmluc3RhbmNlSW5kZXggPT09IGluc3RhbmNlSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoIXN5bmNocm9uaXplZCkge1xuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIE1ldGFBcGkgdG8gc3luY2hyb25pemUgdG8gTWV0YVRyYWRlciBhY2NvdW50ICcgK1xuICAgICAgICB0aGlzLl9hY2NvdW50LmlkICsgJywgc3luY2hyb25pemF0aW9uIGlkICcgKyAoc3luY2hyb25pemF0aW9uSWQgfHwgKHN0YXRlICYmIHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZCkgfHxcbiAgICAgICAgICAoc3RhdGUgJiYgc3RhdGUubGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkKSkpO1xuICAgIH1cbiAgICBsZXQgdGltZUxlZnRJblNlY29uZHMgPSBNYXRoLm1heCgwLCB0aW1lb3V0SW5TZWNvbmRzIC0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMCk7XG4gICAgYXdhaXQgdGhpcy5fd2Vic29ja2V0Q2xpZW50LndhaXRTeW5jaHJvbml6ZWQodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KSxcbiAgICAgIGFwcGxpY2F0aW9uUGF0dGVybiwgdGltZUxlZnRJblNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi4gVGhlIGluc3RhbmNlIG9mIHRoZSBjbGFzcyBzaG91bGQgbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgaW52b2tlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06IENsb3NpbmcgY29ubmVjdGlvbmApO1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC51bnN1YnNjcmliZSh0aGlzLl9hY2NvdW50LmlkKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl9oaXN0b3J5U3RvcmFnZSk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGVhbHRoTW9uaXRvcik7XG4gICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcih0aGlzKTtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5yZW1vdmUodGhpcy5fYWNjb3VudC5pZCk7XG4gICAgICB0aGlzLl9oZWFsdGhNb25pdG9yLnN0b3AoKTtcbiAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uc0pvYnMgPSB7fTtcbiAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3luY2hyb25pemF0aW9uIHN0YXR1c1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBzeW5jaHJvbml6YXRpb24gc3RhdHVzXG4gICAqL1xuICBnZXQgc3luY2hyb25pemVkKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5yZWR1Y2UoKGFjYywgcykgPT4gYWNjIHx8IHMuc3luY2hyb25pemVkLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhQXBpIGFjY291bnRcbiAgICogQHJldHVybiB7TWV0YXRyYWRlckFjY291bnR9IE1ldGFBcGkgYWNjb3VudFxuICAgKi9cbiAgZ2V0IGFjY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25uZWN0aW9uIGhlYWx0aCBtb25pdG9yIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yfSBjb25uZWN0aW9uIGhlYWx0aCBtb25pdG9yIGluc3RhbmNlXG4gICAqL1xuICBnZXQgaGVhbHRoTW9uaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhbHRoTW9uaXRvcjtcbiAgfVxuXG4gIGFzeW5jIF9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMoaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uc0pvYnNbaW5zdGFuY2VOdW1iZXJdID09PSBzZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNMaXN0ID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zKGtleSk7XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uc0l0ZW0gPSB7c3ltYm9sOiBrZXl9O1xuICAgICAgICAgIGlmKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnNJdGVtLnN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzY3JpcHRpb25zTGlzdC5wdXNoKHN1YnNjcmlwdGlvbnNJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC5yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnModGhpcy5fYWNjb3VudC5pZCwgaW5zdGFuY2VOdW1iZXIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvciByZWZyZXNoaW5nIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgam9iIGZvciBhY2NvdW50ICR7dGhpcy5fYWNjb3VudC5pZH0gYCArXG4gICAgICBgJHtpbnN0YW5jZU51bWJlcn1gLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zSm9ic1tpbnN0YW5jZU51bWJlcl0gPT09IHNlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlZnJlc2hJbnRlcnZhbCA9IChNYXRoLnJhbmRvbSgpICogKHRoaXMuX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCAtIFxuICAgICAgICAgIHRoaXMuX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCkgKyB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwpICogMTAwMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMoaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pLCByZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlID0ge307XG4gICAgaWYgKHR5cGVvZiBzdG9wTG9zcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3M7XG4gICAgfSBlbHNlIGlmIChzdG9wTG9zcykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcy52YWx1ZTtcbiAgICAgIHRyYWRlLnN0b3BMb3NzVW5pdHMgPSBzdG9wTG9zcy51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWtlUHJvZml0ID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQ7XG4gICAgfSBlbHNlIGlmICh0YWtlUHJvZml0KSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdC52YWx1ZTtcbiAgICAgIHRyYWRlLnRha2VQcm9maXRVbml0cyA9IHRha2VQcm9maXQudW5pdHM7XG4gICAgfVxuICAgIHJldHVybiB0cmFkZTtcbiAgfVxuXG4gIGFzeW5jIF9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwga2V5KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN5bmNocm9uaXphdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY2hyb25pemUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgIGlmKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ01ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBmb3IgYWNjb3VudCAnICsgdGhpcy5fYWNjb3VudC5pZCArXG4gICAgICAgICAgJzonICsgaW5zdGFuY2VJbmRleCArICcgZmFpbGVkIHRvIHN5bmNocm9uaXplJywgZXJyKTtcbiAgICAgICAgaWYgKHN0YXRlLnNob3VsZFN5bmNocm9uaXplID09PSBrZXkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZC5iaW5kKHRoaXMsIGluc3RhbmNlSW5kZXgsIGtleSksXG4gICAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IE1hdGgubWluKHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAyLCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF0gPSB7XG4gICAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICAgIG9yZGVyc1N5bmNocm9uaXplZDoge30sXG4gICAgICAgIGRlYWxzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgc2hvdWxkU3luY2hyb25pemU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kczogMSxcbiAgICAgICAgc3luY2hyb25pemVkOiBmYWxzZSxcbiAgICAgICAgbGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3RTeW5jaHJvbml6YXRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XTtcbiAgfVxuXG59XG4iXX0=