'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _cryptoJs = require('crypto-js');

var _cryptoJs2 = _interopRequireDefault(_cryptoJs);

var _synchronizationListener = require('../clients/metaApi/synchronizationListener');

var _synchronizationListener2 = _interopRequireDefault(_synchronizationListener);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Responsible for storing a local copy of remote terminal state
 */
class TerminalState extends _synchronizationListener2.default {

  /**
   * Constructs the instance of terminal state class
   */
  constructor() {
    super();
    this._stateByInstanceIndex = {};
    this._waitForPriceResolves = {};
  }

  /**
   * Returns true if MetaApi have connected to MetaTrader terminal
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal
   */
  get connected() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.connected, false);
  }

  /**
   * Returns true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to broker
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to
   * broker
   */
  get connectedToBroker() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.connectedToBroker, false);
  }

  /**
   * Returns a local copy of account information
   * @returns {MetatraderAccountInformation} local copy of account information
   */
  get accountInformation() {
    return this._getBestState().accountInformation;
  }

  /**
   * Returns a local copy of MetaTrader positions opened
   * @returns {Array<MetatraderPosition>} a local copy of MetaTrader positions opened
   */
  get positions() {
    return this._getBestState().positions;
  }

  /**
   * Returns a local copy of MetaTrader orders opened
   * @returns {Array<MetatraderOrder>} a local copy of MetaTrader orders opened
   */
  get orders() {
    return this._getBestState().orders;
  }

  /**
   * Returns a local copy of symbol specifications available in MetaTrader trading terminal
   * @returns {Array<MetatraderSymbolSpecification>} a local copy of symbol specifications available in MetaTrader
   * trading terminal
   */
  get specifications() {
    return (0, _values2.default)(this._getBestState().specificationsBySymbol);
  }

  /**
   * Returns hashes of terminal state data for incremental synchronization
   * @param {String} accountType account type
   * @returns {Object} hashes of terminal state data
   */
  getHashes(accountType) {

    const sortByKey = (obj1, obj2, key) => {
      if (obj1[key] < obj2[key]) {
        return -1;
      }
      if (obj1[key] > obj2[key]) {
        return 1;
      }
      return 0;
    };
    const specifications = JSON.parse((0, _stringify2.default)(this.specifications));
    specifications.sort((a, b) => sortByKey(a, b, 'symbol'));
    if (accountType === 'cloud-g1') {
      specifications.forEach(specification => {
        delete specification.description;
      });
    }
    const specificationsHash = this._getHash(specifications, accountType, ['digits']);

    const positions = JSON.parse((0, _stringify2.default)(this.positions));
    positions.sort((a, b) => sortByKey(a, b, 'id'));
    positions.forEach(position => {
      delete position.profit;
      delete position.unrealizedProfit;
      delete position.realizedProfit;
      delete position.currentPrice;
      delete position.currentTickValue;
      delete position.updateSequenceNumber;
      delete position.accountCurrencyExchangeRate;
      delete position.comment;
      delete position.originalComment;
      delete position.clientId;
      if (accountType === 'cloud-g1') {
        delete position.time;
        delete position.updateTime;
      }
    });
    const positionsHash = this._getHash(positions, accountType, ['magic']);

    const orders = JSON.parse((0, _stringify2.default)(this.orders));
    orders.sort((a, b) => sortByKey(a, b, 'id'));
    orders.forEach(order => {
      delete order.currentPrice;
      delete order.updateSequenceNumber;
      delete order.accountCurrencyExchangeRate;
      delete order.comment;
      delete order.originalComment;
      delete order.clientId;
      if (accountType === 'cloud-g1') {
        delete order.time;
      }
    });
    const ordersHash = this._getHash(orders, accountType, ['magic']);

    return {
      specificationsMd5: specificationsHash,
      positionsMd5: positionsHash,
      ordersMd5: ordersHash
    };
  }

  /**
   * Returns MetaTrader symbol specification by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolSpecification} MetatraderSymbolSpecification found or undefined if specification for a
   * symbol is not found
   */
  specification(symbol) {
    return this._getBestState(symbol, 'specification').specificationsBySymbol[symbol];
  }

  /**
   * Returns MetaTrader symbol price by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolPrice} MetatraderSymbolPrice found or undefined if price for a symbol is not found
   */
  price(symbol) {
    return this._getBestState(symbol, 'price').pricesBySymbol[symbol];
  }

  /**
   * Waits for price to be received
   * @param {string} symbol symbol (e.g. currency pair or an index)
   * @param {number} [timeoutInSeconds] timeout in seconds, default is 30
   * @return {Promise<MetatraderSymbolPrice>} promise resolving with price or undefined if price has not been received
   */
  async waitForPrice(symbol, timeoutInSeconds = 30) {
    this._waitForPriceResolves[symbol] = this._waitForPriceResolves[symbol] || [];
    if (!this.price(symbol)) {
      await _promise2.default.race([new _promise2.default(res => this._waitForPriceResolves[symbol].push(res)), new _promise2.default(res => setTimeout(res, timeoutInSeconds * 1000))]);
    }
    return this.price(symbol);
  }

  /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   */
  onConnected(instanceIndex) {
    this._getState(instanceIndex).connected = true;
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */
  onDisconnected(instanceIndex) {
    let state = this._getState(instanceIndex);
    state.connected = false;
    state.connectedToBroker = false;
  }

  /**
   * Invoked when broker connection status have changed
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} connected is MetaTrader terminal is connected to broker
   */
  onBrokerConnectionStatusChanged(instanceIndex, connected) {
    this._getState(instanceIndex).connectedToBroker = connected;
  }

  /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} specificationsUpdated whether specifications are going to be updated during synchronization
   * @param {Boolean} positionsUpdated whether positions are going to be updated during synchronization
   * @param {Boolean} ordersUpdated whether orders are going to be updated during synchronization
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onSynchronizationStarted(instanceIndex, specificationsUpdated, positionsUpdated, ordersUpdated) {
    let state = this._getState(instanceIndex);
    state.accountInformation = undefined;
    state.pricesBySymbol = {};
    if (positionsUpdated) {
      state.positions = [];
      state.removedPositions = {};
      state.positionsInitialized = false;
    }
    if (ordersUpdated) {
      state.orders = [];
      state.completedOrders = {};
      state.ordersInitialized = false;
    }
    if (specificationsUpdated) {
      state.specificationsBySymbol = {};
    }
  }

  /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   */
  onAccountInformationUpdated(instanceIndex, accountInformation) {
    let state = this._getState(instanceIndex);
    state.accountInformation = accountInformation;
    state.initializationCounter = 1;
  }

  /**
   * Invoked when the positions are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderPosition>} positions updated array of positions
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPositionsReplaced(instanceIndex, positions) {
    let state = this._getState(instanceIndex);
    state.positions = positions;
  }

  /**
   * Invoked when position synchronization fnished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPositionsSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.removedPositions = {};
    state.positionsInitialized = true;
    state.initializationCounter = 2;
  }

  /**
   * Invoked when MetaTrader position is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderPosition} position updated MetaTrader position
   */
  onPositionUpdated(instanceIndex, position) {
    let state = this._getState(instanceIndex);
    let index = state.positions.findIndex(p => p.id === position.id);
    if (index !== -1) {
      state.positions[index] = position;
    } else if (!state.removedPositions[position.id]) {
      state.positions.push(position);
    }
  }

  /**
   * Invoked when MetaTrader position is removed
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} positionId removed MetaTrader position id
   */
  onPositionRemoved(instanceIndex, positionId) {
    let state = this._getState(instanceIndex);
    let position = state.positions.find(p => p.id === positionId);
    if (!position) {
      for (let e of (0, _entries2.default)(state.removedPositions)) {
        if (e[1] + 5 * 60 * 1000 < Date.now()) {
          delete state.removedPositions[e[0]];
        }
      }
      state.removedPositions[positionId] = Date.now();
    } else {
      state.positions = state.positions.filter(p => p.id !== positionId);
    }
  }

  /**
   * Invoked when the orders are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderOrder>} orders updated array of pending orders
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPendingOrdersReplaced(instanceIndex, orders) {
    let state = this._getState(instanceIndex);
    state.orders = orders;
  }

  /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.completedOrders = {};
    state.ordersInitialized = true;
    state.initializationCounter = 3;
  }

  /**
   * Invoked when MetaTrader pending order is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderOrder} order updated MetaTrader pending order
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPendingOrderUpdated(instanceIndex, order) {
    let state = this._getState(instanceIndex);
    let index = state.orders.findIndex(o => o.id === order.id);
    if (index !== -1) {
      state.orders[index] = order;
    } else if (!state.completedOrders[order.id]) {
      state.orders.push(order);
    }
  }

  /**
   * Invoked when MetaTrader pending order is completed (executed or canceled)
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} orderId completed MetaTrader pending order id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onPendingOrderCompleted(instanceIndex, orderId) {
    let state = this._getState(instanceIndex);
    let order = state.orders.find(o => o.id === orderId);
    if (!order) {
      for (let e of (0, _entries2.default)(state.completedOrders)) {
        if (e[1] + 5 * 60 * 1000 < Date.now()) {
          delete state.completedOrders[e[0]];
        }
      }
      state.completedOrders[orderId] = Date.now();
    } else {
      state.orders = state.orders.filter(o => o.id !== orderId);
    }
  }

  /**
   * Invoked when a symbol specification was updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */
  onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
    let state = this._getState(instanceIndex);
    for (let specification of specifications) {
      state.specificationsBySymbol[specification.symbol] = specification;
    }
    for (let symbol of removedSymbols) {
      delete state.specificationsBySymbol[symbol];
    }
    state.specificationCount = (0, _keys2.default)(state.specificationsBySymbol).length;
  }

  /**
   * Invoked when prices for several symbols were updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderSymbolPrice>} prices updated MetaTrader symbol prices
   * @param {Number} equity account liquidation value
   * @param {Number} margin margin used
   * @param {Number} freeMargin free margin
   * @param {Number} marginLevel margin level calculated as % of equity/margin
   */
  // eslint-disable-next-line complexity
  onSymbolPricesUpdated(instanceIndex, prices, equity, margin, freeMargin, marginLevel) {
    let state = this._getState(instanceIndex);
    state.lastUpdateTime = Math.max(prices.map(p => p.time.getTime()));
    let pricesInitialized = false;
    for (let price of prices || []) {
      state.pricesBySymbol[price.symbol] = price;
      let positions = state.positions.filter(p => p.symbol === price.symbol);
      let otherPositions = state.positions.filter(p => p.symbol !== price.symbol);
      let orders = state.orders.filter(o => o.symbol === price.symbol);
      pricesInitialized = true;
      for (let position of otherPositions) {
        let p = state.pricesBySymbol[position.symbol];
        if (p) {
          if (position.unrealizedProfit === undefined) {
            this._updatePositionProfits(position, p);
          }
        } else {
          pricesInitialized = false;
        }
      }
      for (let position of positions) {
        this._updatePositionProfits(position, price);
      }
      for (let order of orders) {
        order.currentPrice = order.type === 'ORDER_TYPE_BUY' || order.type === 'ORDER_TYPE_BUY_LIMIT' || order.type === 'ORDER_TYPE_BUY_STOP' || order.type === 'ORDER_TYPE_BUY_STOP_LIMIT' ? price.ask : price.bid;
      }
      let priceResolves = this._waitForPriceResolves[price.symbol] || [];
      if (priceResolves.length) {
        for (let resolve of priceResolves) {
          resolve();
        }
        delete this._waitForPriceResolves[price.symbol];
      }
    }
    if (state.accountInformation) {
      if (state.positionsInitialized && pricesInitialized) {
        if (state.accountInformation.platform === 'mt5') {
          state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + state.positions.reduce((acc, p) => acc + Math.round((p.unrealizedProfit || 0) * 100) / 100 + Math.round((p.swap || 0) * 100) / 100, 0);
        } else {
          state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + state.positions.reduce((acc, p) => acc + Math.round((p.swap || 0) * 100) / 100 + Math.round((p.commission || 0) * 100) / 100 + Math.round((p.unrealizedProfit || 0) * 100) / 100, 0);
        }
        state.accountInformation.equity = Math.round(state.accountInformation.equity * 100) / 100;
      } else {
        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.equity;
      }
      state.accountInformation.margin = margin !== undefined ? margin : state.accountInformation.margin;
      state.accountInformation.freeMargin = freeMargin !== undefined ? freeMargin : state.accountInformation.freeMargin;
      state.accountInformation.marginLevel = freeMargin !== undefined ? marginLevel : state.accountInformation.marginLevel;
    }
  }

  /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onStreamClosed(instanceIndex) {
    delete this._stateByInstanceIndex[instanceIndex];
  }

  // eslint-disable-next-line complexity
  _updatePositionProfits(position, price) {
    let specification = this.specification(position.symbol);
    if (specification) {
      let multiplier = Math.pow(10, specification.digits);
      if (position.profit !== undefined) {
        position.profit = Math.round(position.profit * multiplier) / multiplier;
      }
      if (position.unrealizedProfit === undefined || position.realizedProfit === undefined) {
        position.unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (position.currentPrice - position.openPrice) * position.currentTickValue * position.volume / specification.tickSize;
        position.unrealizedProfit = Math.round(position.unrealizedProfit * multiplier) / multiplier;
        position.realizedProfit = position.profit - position.unrealizedProfit;
      }
      let newPositionPrice = position.type === 'POSITION_TYPE_BUY' ? price.bid : price.ask;
      let isProfitable = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice);
      let currentTickValue = isProfitable > 0 ? price.profitTickValue : price.lossTickValue;
      let unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice) * currentTickValue * position.volume / specification.tickSize;
      unrealizedProfit = Math.round(unrealizedProfit * multiplier) / multiplier;
      position.unrealizedProfit = unrealizedProfit;
      position.profit = position.unrealizedProfit + position.realizedProfit;
      position.profit = Math.round(position.profit * multiplier) / multiplier;
      position.currentPrice = newPositionPrice;
      position.currentTickValue = currentTickValue;
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex['' + instanceIndex]) {
      this._stateByInstanceIndex['' + instanceIndex] = this._constructTerminalState(instanceIndex);
    }
    return this._stateByInstanceIndex['' + instanceIndex];
  }

  _constructTerminalState(instanceIndex) {
    return {
      instanceIndex,
      connected: false,
      connectedToBroker: false,
      accountInformation: undefined,
      positions: [],
      orders: [],
      specificationsBySymbol: {},
      pricesBySymbol: {},
      completedOrders: {},
      removedPositions: {},
      ordersInitialized: false,
      positionsInitialized: false,
      lastUpdateTime: 0,
      initializationCounter: 0,
      specificationCount: 0
    };
  }

  // eslint-disable-next-line complexity
  _getBestState(symbol, mode = 'default') {
    let result;
    let maxUpdateTime = -1;
    let maxInitializationCounter = -1;
    let maxSpecificationCount = -1;
    for (let state of (0, _values2.default)(this._stateByInstanceIndex)) {
      if (maxInitializationCounter < state.initializationCounter || maxInitializationCounter === state.initializationCounter && maxInitializationCounter === 3 && maxUpdateTime < state.lastUpdateTime || maxInitializationCounter === state.initializationCounter && maxInitializationCounter === 0 && maxSpecificationCount < state.specificationCount) {
        if (!symbol || mode === 'specification' && state.specificationsBySymbol[symbol] || mode === 'price' && state.pricesBySymbol[symbol]) {
          maxUpdateTime = state.lastUpdateTime;
          maxInitializationCounter = state.initializationCounter;
          maxSpecificationCount = state.specificationCount;
          result = state;
        }
      }
    }
    return result || this._constructTerminalState();
  }

  _getHash(obj, accountType, integerKeys) {
    let jsonItem = '';
    if (accountType === 'cloud-g1') {
      const stringify = (objFromJson, key) => {
        if (typeof objFromJson === 'number') {
          if (integerKeys.includes(key)) {
            return objFromJson;
          } else {
            return objFromJson.toFixed(8);
          }
        } else if (Array.isArray(objFromJson)) {
          return `[${objFromJson.map(item => stringify(item)).join(',')}]`;
        } else if (typeof objFromJson !== 'object' || objFromJson.getTime) {
          return (0, _stringify2.default)(objFromJson);
        }

        let props = (0, _keys2.default)(objFromJson).map(keyItem => `"${keyItem}":${stringify(objFromJson[keyItem], keyItem)}`).join(',');
        return `{${props}}`;
      };

      jsonItem = stringify(obj);
    } else if (accountType === 'cloud-g2') {
      jsonItem = (0, _stringify2.default)(obj);
    }
    return _cryptoJs2.default.MD5(jsonItem).toString();
  }

}
exports.default = TerminalState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL3Rlcm1pbmFsU3RhdGUuZXM2Il0sIm5hbWVzIjpbIlRlcm1pbmFsU3RhdGUiLCJTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImNvbnN0cnVjdG9yIiwiX3N0YXRlQnlJbnN0YW5jZUluZGV4IiwiX3dhaXRGb3JQcmljZVJlc29sdmVzIiwiY29ubmVjdGVkIiwicmVkdWNlIiwiYWNjIiwicyIsImNvbm5lY3RlZFRvQnJva2VyIiwiYWNjb3VudEluZm9ybWF0aW9uIiwiX2dldEJlc3RTdGF0ZSIsInBvc2l0aW9ucyIsIm9yZGVycyIsInNwZWNpZmljYXRpb25zIiwic3BlY2lmaWNhdGlvbnNCeVN5bWJvbCIsImdldEhhc2hlcyIsImFjY291bnRUeXBlIiwic29ydEJ5S2V5Iiwib2JqMSIsIm9iajIiLCJrZXkiLCJKU09OIiwicGFyc2UiLCJzb3J0IiwiYSIsImIiLCJmb3JFYWNoIiwic3BlY2lmaWNhdGlvbiIsImRlc2NyaXB0aW9uIiwic3BlY2lmaWNhdGlvbnNIYXNoIiwiX2dldEhhc2giLCJwb3NpdGlvbiIsInByb2ZpdCIsInVucmVhbGl6ZWRQcm9maXQiLCJyZWFsaXplZFByb2ZpdCIsImN1cnJlbnRQcmljZSIsImN1cnJlbnRUaWNrVmFsdWUiLCJ1cGRhdGVTZXF1ZW5jZU51bWJlciIsImFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSIsImNvbW1lbnQiLCJvcmlnaW5hbENvbW1lbnQiLCJjbGllbnRJZCIsInRpbWUiLCJ1cGRhdGVUaW1lIiwicG9zaXRpb25zSGFzaCIsIm9yZGVyIiwib3JkZXJzSGFzaCIsInNwZWNpZmljYXRpb25zTWQ1IiwicG9zaXRpb25zTWQ1Iiwib3JkZXJzTWQ1Iiwic3ltYm9sIiwicHJpY2UiLCJwcmljZXNCeVN5bWJvbCIsIndhaXRGb3JQcmljZSIsInRpbWVvdXRJblNlY29uZHMiLCJyYWNlIiwicmVzIiwicHVzaCIsInNldFRpbWVvdXQiLCJvbkNvbm5lY3RlZCIsImluc3RhbmNlSW5kZXgiLCJfZ2V0U3RhdGUiLCJvbkRpc2Nvbm5lY3RlZCIsInN0YXRlIiwib25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZCIsIm9uU3luY2hyb25pemF0aW9uU3RhcnRlZCIsInNwZWNpZmljYXRpb25zVXBkYXRlZCIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwidW5kZWZpbmVkIiwicmVtb3ZlZFBvc2l0aW9ucyIsInBvc2l0aW9uc0luaXRpYWxpemVkIiwiY29tcGxldGVkT3JkZXJzIiwib3JkZXJzSW5pdGlhbGl6ZWQiLCJvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQiLCJpbml0aWFsaXphdGlvbkNvdW50ZXIiLCJvblBvc2l0aW9uc1JlcGxhY2VkIiwib25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQiLCJzeW5jaHJvbml6YXRpb25JZCIsIm9uUG9zaXRpb25VcGRhdGVkIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJwIiwiaWQiLCJvblBvc2l0aW9uUmVtb3ZlZCIsInBvc2l0aW9uSWQiLCJmaW5kIiwiZSIsIkRhdGUiLCJub3ciLCJmaWx0ZXIiLCJvblBlbmRpbmdPcmRlcnNSZXBsYWNlZCIsIm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCIsIm9uUGVuZGluZ09yZGVyVXBkYXRlZCIsIm8iLCJvblBlbmRpbmdPcmRlckNvbXBsZXRlZCIsIm9yZGVySWQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInJlbW92ZWRTeW1ib2xzIiwic3BlY2lmaWNhdGlvbkNvdW50IiwibGVuZ3RoIiwib25TeW1ib2xQcmljZXNVcGRhdGVkIiwicHJpY2VzIiwiZXF1aXR5IiwibWFyZ2luIiwiZnJlZU1hcmdpbiIsIm1hcmdpbkxldmVsIiwibGFzdFVwZGF0ZVRpbWUiLCJNYXRoIiwibWF4IiwibWFwIiwiZ2V0VGltZSIsInByaWNlc0luaXRpYWxpemVkIiwib3RoZXJQb3NpdGlvbnMiLCJfdXBkYXRlUG9zaXRpb25Qcm9maXRzIiwidHlwZSIsImFzayIsImJpZCIsInByaWNlUmVzb2x2ZXMiLCJyZXNvbHZlIiwicGxhdGZvcm0iLCJiYWxhbmNlIiwicm91bmQiLCJzd2FwIiwiY29tbWlzc2lvbiIsIm9uU3RyZWFtQ2xvc2VkIiwibXVsdGlwbGllciIsInBvdyIsImRpZ2l0cyIsIm9wZW5QcmljZSIsInZvbHVtZSIsInRpY2tTaXplIiwibmV3UG9zaXRpb25QcmljZSIsImlzUHJvZml0YWJsZSIsInByb2ZpdFRpY2tWYWx1ZSIsImxvc3NUaWNrVmFsdWUiLCJfY29uc3RydWN0VGVybWluYWxTdGF0ZSIsIm1vZGUiLCJyZXN1bHQiLCJtYXhVcGRhdGVUaW1lIiwibWF4SW5pdGlhbGl6YXRpb25Db3VudGVyIiwibWF4U3BlY2lmaWNhdGlvbkNvdW50Iiwib2JqIiwiaW50ZWdlcktleXMiLCJqc29uSXRlbSIsInN0cmluZ2lmeSIsIm9iakZyb21Kc29uIiwiaW5jbHVkZXMiLCJ0b0ZpeGVkIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbSIsImpvaW4iLCJwcm9wcyIsImtleUl0ZW0iLCJjcnlwdG8iLCJNRDUiLCJ0b1N0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdlLE1BQU1BLGFBQU4sU0FBNEJDLGlDQUE1QixDQUFvRDs7QUFFakU7OztBQUdBQyxnQkFBYztBQUNaO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLQyxxQkFBTCxHQUE2QixFQUE3QjtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSUMsU0FBSixHQUFnQjtBQUNkLFdBQU8sc0JBQWMsS0FBS0YscUJBQW5CLEVBQTBDRyxNQUExQyxDQUFpRCxDQUFDQyxHQUFELEVBQU1DLENBQU4sS0FBWUQsT0FBT0MsRUFBRUgsU0FBdEUsRUFBaUYsS0FBakYsQ0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLE1BQUlJLGlCQUFKLEdBQXdCO0FBQ3RCLFdBQU8sc0JBQWMsS0FBS04scUJBQW5CLEVBQTBDRyxNQUExQyxDQUFpRCxD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IjoidGVybWluYWxTdGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8tanMnO1xuaW1wb3J0IFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcic7XG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYSBsb2NhbCBjb3B5IG9mIHJlbW90ZSB0ZXJtaW5hbCBzdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtaW5hbFN0YXRlIGV4dGVuZHMgU3luY2hyb25pemF0aW9uTGlzdGVuZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZSBvZiB0ZXJtaW5hbCBzdGF0ZSBjbGFzc1xuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKi9cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLmNvbm5lY3RlZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgYW5kIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29ubmVjdGVkIHRvIGJyb2tlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBhbmQgTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb25uZWN0ZWQgdG9cbiAgICogYnJva2VyXG4gICAqL1xuICBnZXQgY29ubmVjdGVkVG9Ccm9rZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiBhY2MgfHwgcy5jb25uZWN0ZWRUb0Jyb2tlciwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICogQHJldHVybnMge01ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb259IGxvY2FsIGNvcHkgb2YgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0IGFjY291bnRJbmZvcm1hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QmVzdFN0YXRlKCkuYWNjb3VudEluZm9ybWF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgcG9zaXRpb25zIG9wZW5lZFxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgcG9zaXRpb25zIG9wZW5lZFxuICAgKi9cbiAgZ2V0IHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QmVzdFN0YXRlKCkucG9zaXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgb3JkZXJzIG9wZW5lZFxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWV0YXRyYWRlck9yZGVyPn0gYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgb3JkZXJzIG9wZW5lZFxuICAgKi9cbiAgZ2V0IG9yZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QmVzdFN0YXRlKCkub3JkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIHN5bWJvbCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgaW4gTWV0YVRyYWRlciB0cmFkaW5nIHRlcm1pbmFsXG4gICAqIEByZXR1cm5zIHtBcnJheTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IGEgbG9jYWwgY29weSBvZiBzeW1ib2wgc3BlY2lmaWNhdGlvbnMgYXZhaWxhYmxlIGluIE1ldGFUcmFkZXJcbiAgICogdHJhZGluZyB0ZXJtaW5hbFxuICAgKi9cbiAgZ2V0IHNwZWNpZmljYXRpb25zKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2dldEJlc3RTdGF0ZSgpLnNwZWNpZmljYXRpb25zQnlTeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGFzaGVzIG9mIHRlcm1pbmFsIHN0YXRlIGRhdGEgZm9yIGluY3JlbWVudGFsIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFR5cGUgYWNjb3VudCB0eXBlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGhhc2hlcyBvZiB0ZXJtaW5hbCBzdGF0ZSBkYXRhXG4gICAqL1xuICBnZXRIYXNoZXMoYWNjb3VudFR5cGUpIHtcblxuICAgIGNvbnN0IHNvcnRCeUtleSA9IChvYmoxLCBvYmoyLCBrZXkpID0+IHtcbiAgICAgIGlmKG9iajFba2V5XSA8IG9iajJba2V5XSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZihvYmoxW2tleV0gPiBvYmoyW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGNvbnN0IHNwZWNpZmljYXRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnNwZWNpZmljYXRpb25zKSk7XG4gICAgc3BlY2lmaWNhdGlvbnMuc29ydCgoYSxiKSA9PiBzb3J0QnlLZXkoYSwgYiwgJ3N5bWJvbCcpKTtcbiAgICBpZihhY2NvdW50VHlwZSA9PT0gJ2Nsb3VkLWcxJykge1xuICAgICAgc3BlY2lmaWNhdGlvbnMuZm9yRWFjaChzcGVjaWZpY2F0aW9uID0+IHtcbiAgICAgICAgZGVsZXRlIHNwZWNpZmljYXRpb24uZGVzY3JpcHRpb247XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbnNIYXNoID0gdGhpcy5fZ2V0SGFzaChzcGVjaWZpY2F0aW9ucywgYWNjb3VudFR5cGUsIFsnZGlnaXRzJ10pO1xuXG4gICAgY29uc3QgcG9zaXRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBvc2l0aW9ucykpO1xuICAgIHBvc2l0aW9ucy5zb3J0KChhLGIpID0+IHNvcnRCeUtleShhLCBiLCAnaWQnKSk7XG4gICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4ge1xuICAgICAgZGVsZXRlIHBvc2l0aW9uLnByb2ZpdDtcbiAgICAgIGRlbGV0ZSBwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0O1xuICAgICAgZGVsZXRlIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0O1xuICAgICAgZGVsZXRlIHBvc2l0aW9uLmN1cnJlbnRQcmljZTtcbiAgICAgIGRlbGV0ZSBwb3NpdGlvbi5jdXJyZW50VGlja1ZhbHVlO1xuICAgICAgZGVsZXRlIHBvc2l0aW9uLnVwZGF0ZVNlcXVlbmNlTnVtYmVyO1xuICAgICAgZGVsZXRlIHBvc2l0aW9uLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZTtcbiAgICAgIGRlbGV0ZSBwb3NpdGlvbi5jb21tZW50O1xuICAgICAgZGVsZXRlIHBvc2l0aW9uLm9yaWdpbmFsQ29tbWVudDtcbiAgICAgIGRlbGV0ZSBwb3NpdGlvbi5jbGllbnRJZDtcbiAgICAgIGlmKGFjY291bnRUeXBlID09PSAnY2xvdWQtZzEnKSB7XG4gICAgICAgIGRlbGV0ZSBwb3NpdGlvbi50aW1lO1xuICAgICAgICBkZWxldGUgcG9zaXRpb24udXBkYXRlVGltZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwb3NpdGlvbnNIYXNoID0gdGhpcy5fZ2V0SGFzaChwb3NpdGlvbnMsIGFjY291bnRUeXBlLCBbJ21hZ2ljJ10pO1xuXG4gICAgY29uc3Qgb3JkZXJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm9yZGVycykpO1xuICAgIG9yZGVycy5zb3J0KChhLGIpID0+IHNvcnRCeUtleShhLCBiLCAnaWQnKSk7XG4gICAgb3JkZXJzLmZvckVhY2gob3JkZXIgPT4ge1xuICAgICAgZGVsZXRlIG9yZGVyLmN1cnJlbnRQcmljZTtcbiAgICAgIGRlbGV0ZSBvcmRlci51cGRhdGVTZXF1ZW5jZU51bWJlcjtcbiAgICAgIGRlbGV0ZSBvcmRlci5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGU7XG4gICAgICBkZWxldGUgb3JkZXIuY29tbWVudDtcbiAgICAgIGRlbGV0ZSBvcmRlci5vcmlnaW5hbENvbW1lbnQ7XG4gICAgICBkZWxldGUgb3JkZXIuY2xpZW50SWQ7XG4gICAgICBpZihhY2NvdW50VHlwZSA9PT0gJ2Nsb3VkLWcxJykge1xuICAgICAgICBkZWxldGUgb3JkZXIudGltZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvcmRlcnNIYXNoID0gdGhpcy5fZ2V0SGFzaChvcmRlcnMsIGFjY291bnRUeXBlLCBbJ21hZ2ljJ10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwZWNpZmljYXRpb25zTWQ1OiBzcGVjaWZpY2F0aW9uc0hhc2gsXG4gICAgICBwb3NpdGlvbnNNZDU6IHBvc2l0aW9uc0hhc2gsXG4gICAgICBvcmRlcnNNZDU6IG9yZGVyc0hhc2hcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzeW1ib2wgc3BlY2lmaWNhdGlvbiBieSBzeW1ib2xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHJldHVybiB7TWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb259IE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uIGZvdW5kIG9yIHVuZGVmaW5lZCBpZiBzcGVjaWZpY2F0aW9uIGZvciBhXG4gICAqIHN5bWJvbCBpcyBub3QgZm91bmRcbiAgICovXG4gIHNwZWNpZmljYXRpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEJlc3RTdGF0ZShzeW1ib2wsICdzcGVjaWZpY2F0aW9uJykuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbFtzeW1ib2xdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzeW1ib2wgcHJpY2UgYnkgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJTeW1ib2xQcmljZX0gTWV0YXRyYWRlclN5bWJvbFByaWNlIGZvdW5kIG9yIHVuZGVmaW5lZCBpZiBwcmljZSBmb3IgYSBzeW1ib2wgaXMgbm90IGZvdW5kXG4gICAqL1xuICBwcmljZShzeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QmVzdFN0YXRlKHN5bWJvbCwgJ3ByaWNlJykucHJpY2VzQnlTeW1ib2xbc3ltYm9sXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgcHJpY2UgdG8gYmUgcmVjZWl2ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgMzBcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sUHJpY2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHByaWNlIG9yIHVuZGVmaW5lZCBpZiBwcmljZSBoYXMgbm90IGJlZW4gcmVjZWl2ZWRcbiAgICovXG4gIGFzeW5jIHdhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMgPSAzMCkge1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzW3N5bWJvbF0gPSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1tzeW1ib2xdIHx8IFtdO1xuICAgIGlmICghdGhpcy5wcmljZShzeW1ib2wpKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZShyZXMgPT4gdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbc3ltYm9sXS5wdXNoKHJlcykpLFxuICAgICAgICBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmljZShzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIG9uQ29ubmVjdGVkKGluc3RhbmNlSW5kZXgpIHtcbiAgICB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KS5jb25uZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKi9cbiAgb25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHN0YXRlLmNvbm5lY3RlZFRvQnJva2VyID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1cyBoYXZlIGNoYW5nZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb25uZWN0ZWQgaXMgTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb25uZWN0ZWQgdG8gYnJva2VyXG4gICAqL1xuICBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkKGluc3RhbmNlSW5kZXgsIGNvbm5lY3RlZCkge1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmNvbm5lY3RlZFRvQnJva2VyID0gY29ubmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbiBpcyBzdGFydGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3BlY2lmaWNhdGlvbnNVcGRhdGVkIHdoZXRoZXIgc3BlY2lmaWNhdGlvbnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBvc2l0aW9uc1VwZGF0ZWQgd2hldGhlciBwb3NpdGlvbnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9yZGVyc1VwZGF0ZWQgd2hldGhlciBvcmRlcnMgYXJlIGdvaW5nIHRvIGJlIHVwZGF0ZWQgZHVyaW5nIHN5bmNocm9uaXphdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uU3luY2hyb25pemF0aW9uU3RhcnRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9uc1VwZGF0ZWQsIHBvc2l0aW9uc1VwZGF0ZWQsIG9yZGVyc1VwZGF0ZWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUucHJpY2VzQnlTeW1ib2wgPSB7fTtcbiAgICBpZihwb3NpdGlvbnNVcGRhdGVkKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbnMgPSBbXTtcbiAgICAgIHN0YXRlLnJlbW92ZWRQb3NpdGlvbnMgPSB7fTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmKG9yZGVyc1VwZGF0ZWQpIHtcbiAgICAgIHN0YXRlLm9yZGVycyA9IFtdO1xuICAgICAgc3RhdGUuY29tcGxldGVkT3JkZXJzID0ge307XG4gICAgICBzdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZihzcGVjaWZpY2F0aW9uc1VwZGF0ZWQpIHtcbiAgICAgIHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgPSB7fTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvbiBpcyB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbn0gYWNjb3VudEluZm9ybWF0aW9uIHVwZGF0ZWQgTWV0YVRyYWRlciBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqL1xuICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gYWNjb3VudEluZm9ybWF0aW9uO1xuICAgIHN0YXRlLmluaXRpYWxpemF0aW9uQ291bnRlciA9IDE7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBwb3NpdGlvbnMgYXJlIHJlcGxhY2VkIGFzIGEgcmVzdWx0IG9mIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gcG9zaXRpb25zIHVwZGF0ZWQgYXJyYXkgb2YgcG9zaXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25Qb3NpdGlvbnNSZXBsYWNlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbnMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHBvc2l0aW9uIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUG9zaXRpb25zU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUucmVtb3ZlZFBvc2l0aW9ucyA9IHt9O1xuICAgIHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5pbml0aWFsaXphdGlvbkNvdW50ZXIgPSAyO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBvc2l0aW9uIGlzIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyUG9zaXRpb259IHBvc2l0aW9uIHVwZGF0ZWQgTWV0YVRyYWRlciBwb3NpdGlvblxuICAgKi9cbiAgb25Qb3NpdGlvblVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb24pIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgaW5kZXggPSBzdGF0ZS5wb3NpdGlvbnMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcG9zaXRpb24uaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZW1vdmVkUG9zaXRpb25zW3Bvc2l0aW9uLmlkXSkge1xuICAgICAgc3RhdGUucG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciBwb3NpdGlvbiBpcyByZW1vdmVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHJlbW92ZWQgTWV0YVRyYWRlciBwb3NpdGlvbiBpZFxuICAgKi9cbiAgb25Qb3NpdGlvblJlbW92ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGxldCBwb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9ucy5maW5kKHAgPT4gcC5pZCA9PT0gcG9zaXRpb25JZCk7XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgZm9yIChsZXQgZSBvZiBPYmplY3QuZW50cmllcyhzdGF0ZS5yZW1vdmVkUG9zaXRpb25zKSkge1xuICAgICAgICBpZiAoZVsxXSArIDUgKiA2MCAqIDEwMDAgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLnJlbW92ZWRQb3NpdGlvbnNbZVswXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLnJlbW92ZWRQb3NpdGlvbnNbcG9zaXRpb25JZF0gPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbnMgPSBzdGF0ZS5wb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5pZCAhPT0gcG9zaXRpb25JZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgb3JkZXJzIGFyZSByZXBsYWNlZCBhcyBhIHJlc3VsdCBvZiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IG9yZGVycyB1cGRhdGVkIGFycmF5IG9mIHBlbmRpbmcgb3JkZXJzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25QZW5kaW5nT3JkZXJzUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgb3JkZXJzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzID0gb3JkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwZW5kaW5nIG9yZGVyIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGVcbiAgICogc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmNvbXBsZXRlZE9yZGVycyA9IHt9O1xuICAgIHN0YXRlLm9yZGVyc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5pbml0aWFsaXphdGlvbkNvdW50ZXIgPSAzO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXIgaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJPcmRlcn0gb3JkZXIgdXBkYXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblBlbmRpbmdPcmRlclVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgb3JkZXIpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgaW5kZXggPSBzdGF0ZS5vcmRlcnMuZmluZEluZGV4KG8gPT4gby5pZCA9PT0gb3JkZXIuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLm9yZGVyc1tpbmRleF0gPSBvcmRlcjtcbiAgICB9IGVsc2UgaWYgKCFzdGF0ZS5jb21wbGV0ZWRPcmRlcnNbb3JkZXIuaWRdKSB7XG4gICAgICBzdGF0ZS5vcmRlcnMucHVzaChvcmRlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXIgaXMgY29tcGxldGVkIChleGVjdXRlZCBvciBjYW5jZWxlZClcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVySWQgY29tcGxldGVkIE1ldGFUcmFkZXIgcGVuZGluZyBvcmRlciBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUGVuZGluZ09yZGVyQ29tcGxldGVkKGluc3RhbmNlSW5kZXgsIG9yZGVySWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgb3JkZXIgPSBzdGF0ZS5vcmRlcnMuZmluZChvID0+IG8uaWQgPT09IG9yZGVySWQpO1xuICAgIGlmICghb3JkZXIpIHtcbiAgICAgIGZvciAobGV0IGUgb2YgT2JqZWN0LmVudHJpZXMoc3RhdGUuY29tcGxldGVkT3JkZXJzKSkge1xuICAgICAgICBpZiAoZVsxXSArIDUgKiA2MCAqIDEwMDAgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmNvbXBsZXRlZE9yZGVyc1tlWzBdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuY29tcGxldGVkT3JkZXJzW29yZGVySWRdID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUub3JkZXJzID0gc3RhdGUub3JkZXJzLmZpbHRlcihvID0+IG8uaWQgIT09IG9yZGVySWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW1ib2wgc3BlY2lmaWNhdGlvbiB3YXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBzcGVjaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJlbW92ZWRTeW1ib2xzIHJlbW92ZWQgc3ltYm9sc1xuICAgKi9cbiAgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgZm9yIChsZXQgc3BlY2lmaWNhdGlvbiBvZiBzcGVjaWZpY2F0aW9ucykge1xuICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbFtzcGVjaWZpY2F0aW9uLnN5bWJvbF0gPSBzcGVjaWZpY2F0aW9uO1xuICAgIH1cbiAgICBmb3IgKGxldCBzeW1ib2wgb2YgcmVtb3ZlZFN5bWJvbHMpIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sW3N5bWJvbF07XG4gICAgfVxuICAgIHN0YXRlLnNwZWNpZmljYXRpb25Db3VudCA9IE9iamVjdC5rZXlzKHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcHJpY2VzIGZvciBzZXZlcmFsIHN5bWJvbHMgd2VyZSB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclN5bWJvbFByaWNlPn0gcHJpY2VzIHVwZGF0ZWQgTWV0YVRyYWRlciBzeW1ib2wgcHJpY2VzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlcXVpdHkgYWNjb3VudCBsaXF1aWRhdGlvbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWFyZ2luIG1hcmdpbiB1c2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmVlTWFyZ2luIGZyZWUgbWFyZ2luXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXJnaW5MZXZlbCBtYXJnaW4gbGV2ZWwgY2FsY3VsYXRlZCBhcyAlIG9mIGVxdWl0eS9tYXJnaW5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIG9uU3ltYm9sUHJpY2VzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZXMsIGVxdWl0eSwgbWFyZ2luLCBmcmVlTWFyZ2luLCBtYXJnaW5MZXZlbCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmxhc3RVcGRhdGVUaW1lID0gTWF0aC5tYXgocHJpY2VzLm1hcChwID0+IHAudGltZS5nZXRUaW1lKCkpKTtcbiAgICBsZXQgcHJpY2VzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMgfHwgW10pIHtcbiAgICAgIHN0YXRlLnByaWNlc0J5U3ltYm9sW3ByaWNlLnN5bWJvbF0gPSBwcmljZTtcbiAgICAgIGxldCBwb3NpdGlvbnMgPSBzdGF0ZS5wb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5zeW1ib2wgPT09IHByaWNlLnN5bWJvbCk7XG4gICAgICBsZXQgb3RoZXJQb3NpdGlvbnMgPSBzdGF0ZS5wb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5zeW1ib2wgIT09IHByaWNlLnN5bWJvbCk7XG4gICAgICBsZXQgb3JkZXJzID0gc3RhdGUub3JkZXJzLmZpbHRlcihvID0+IG8uc3ltYm9sID09PSBwcmljZS5zeW1ib2wpO1xuICAgICAgcHJpY2VzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgcG9zaXRpb24gb2Ygb3RoZXJQb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IHAgPSBzdGF0ZS5wcmljZXNCeVN5bWJvbFtwb3NpdGlvbi5zeW1ib2xdO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uUHJvZml0cyhwb3NpdGlvbiwgcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaWNlc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvblByb2ZpdHMocG9zaXRpb24sIHByaWNlKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IG9yZGVyIG9mIG9yZGVycykge1xuICAgICAgICBvcmRlci5jdXJyZW50UHJpY2UgPSBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVknIHx8IG9yZGVyLnR5cGUgPT09ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcgfHxcbiAgICAgICAgICBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVlfU1RPUCcgfHwgb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZX1NUT1BfTElNSVQnID8gcHJpY2UuYXNrIDogcHJpY2UuYmlkO1xuICAgICAgfVxuICAgICAgbGV0IHByaWNlUmVzb2x2ZXMgPSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1twcmljZS5zeW1ib2xdIHx8IFtdO1xuICAgICAgaWYgKHByaWNlUmVzb2x2ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHJlc29sdmUgb2YgcHJpY2VSZXNvbHZlcykge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbcHJpY2Uuc3ltYm9sXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbikge1xuICAgICAgaWYgKHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkICYmIHByaWNlc0luaXRpYWxpemVkKSB7XG4gICAgICAgIGlmIChzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ucGxhdGZvcm0gPT09ICdtdDUnKSB7XG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmJhbGFuY2UgK1xuICAgICAgICAgICAgc3RhdGUucG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgK1xuICAgICAgICAgICAgICBNYXRoLnJvdW5kKChwLnVucmVhbGl6ZWRQcm9maXQgfHwgMCkgKiAxMDApIC8gMTAwICsgTWF0aC5yb3VuZCgocC5zd2FwIHx8IDApICogMTAwKSAvIDEwMCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmJhbGFuY2UgK1xuICAgICAgICAgICAgc3RhdGUucG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgKyBNYXRoLnJvdW5kKChwLnN3YXAgfHwgMCkgKiAxMDApIC8gMTAwICtcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCgocC5jb21taXNzaW9uIHx8IDApICogMTAwKSAvIDEwMCArIE1hdGgucm91bmQoKHAudW5yZWFsaXplZFByb2ZpdCB8fCAwKSAqIDEwMCkgLyAxMDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgPSBNYXRoLnJvdW5kKHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgKiAxMDApIC8gMTAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW4gPSBtYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbiA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW47XG4gICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZnJlZU1hcmdpbiA9IGZyZWVNYXJnaW4gIT09IHVuZGVmaW5lZCA/IGZyZWVNYXJnaW4gOiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZnJlZU1hcmdpbjtcbiAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW5MZXZlbCA9IGZyZWVNYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbkxldmVsIDpcbiAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLm1hcmdpbkxldmVsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSkge1xuICAgIGxldCBzcGVjaWZpY2F0aW9uID0gdGhpcy5zcGVjaWZpY2F0aW9uKHBvc2l0aW9uLnN5bWJvbCk7XG4gICAgaWYgKHNwZWNpZmljYXRpb24pIHtcbiAgICAgIGxldCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHNwZWNpZmljYXRpb24uZGlnaXRzKTtcbiAgICAgIGlmIChwb3NpdGlvbi5wcm9maXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi5wcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24ucmVhbGl6ZWRQcm9maXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID0gKHBvc2l0aW9uLnR5cGUgPT09ICdQT1NJVElPTl9UWVBFX0JVWScgPyAxIDogLTEpICpcbiAgICAgICAgICAocG9zaXRpb24uY3VycmVudFByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIHBvc2l0aW9uLmN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICAgIHBvc2l0aW9uLnZvbHVtZSAvIHNwZWNpZmljYXRpb24udGlja1NpemU7XG4gICAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICAgIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0ID0gcG9zaXRpb24ucHJvZml0IC0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdDtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQb3NpdGlvblByaWNlID0gcG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IHByaWNlLmJpZCA6IHByaWNlLmFzaztcbiAgICAgIGxldCBpc1Byb2ZpdGFibGUgPSAocG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IDEgOiAtMSkgKiAobmV3UG9zaXRpb25QcmljZSAtIHBvc2l0aW9uLm9wZW5QcmljZSk7XG4gICAgICBsZXQgY3VycmVudFRpY2tWYWx1ZSA9IChpc1Byb2ZpdGFibGUgPiAwID8gcHJpY2UucHJvZml0VGlja1ZhbHVlIDogcHJpY2UubG9zc1RpY2tWYWx1ZSk7XG4gICAgICBsZXQgdW5yZWFsaXplZFByb2ZpdCA9IChwb3NpdGlvbi50eXBlID09PSAnUE9TSVRJT05fVFlQRV9CVVknID8gMSA6IC0xKSAqXG4gICAgICAgIChuZXdQb3NpdGlvblByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIGN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICBwb3NpdGlvbi52b2x1bWUgLyBzcGVjaWZpY2F0aW9uLnRpY2tTaXplO1xuICAgICAgdW5yZWFsaXplZFByb2ZpdCA9IE1hdGgucm91bmQodW5yZWFsaXplZFByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSB1bnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdCArIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gTWF0aC5yb3VuZChwb3NpdGlvbi5wcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICBwb3NpdGlvbi5jdXJyZW50UHJpY2UgPSBuZXdQb3NpdGlvblByaWNlO1xuICAgICAgcG9zaXRpb24uY3VycmVudFRpY2tWYWx1ZSA9IGN1cnJlbnRUaWNrVmFsdWU7XG4gICAgfVxuICB9XG4gIFxuICBfZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSkge1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSA9IHRoaXMuX2NvbnN0cnVjdFRlcm1pbmFsU3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdO1xuICB9XG5cbiAgX2NvbnN0cnVjdFRlcm1pbmFsU3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnN0YW5jZUluZGV4LFxuICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3RlZFRvQnJva2VyOiBmYWxzZSxcbiAgICAgIGFjY291bnRJbmZvcm1hdGlvbjogdW5kZWZpbmVkLFxuICAgICAgcG9zaXRpb25zOiBbXSxcbiAgICAgIG9yZGVyczogW10sXG4gICAgICBzcGVjaWZpY2F0aW9uc0J5U3ltYm9sOiB7fSxcbiAgICAgIHByaWNlc0J5U3ltYm9sOiB7fSxcbiAgICAgIGNvbXBsZXRlZE9yZGVyczoge30sXG4gICAgICByZW1vdmVkUG9zaXRpb25zOiB7fSxcbiAgICAgIG9yZGVyc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGxhc3RVcGRhdGVUaW1lOiAwLFxuICAgICAgaW5pdGlhbGl6YXRpb25Db3VudGVyOiAwLFxuICAgICAgc3BlY2lmaWNhdGlvbkNvdW50OiAwXG4gICAgfTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9nZXRCZXN0U3RhdGUoc3ltYm9sLCBtb2RlID0gJ2RlZmF1bHQnKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgbWF4VXBkYXRlVGltZSA9IC0xO1xuICAgIGxldCBtYXhJbml0aWFsaXphdGlvbkNvdW50ZXIgPSAtMTtcbiAgICBsZXQgbWF4U3BlY2lmaWNhdGlvbkNvdW50ID0gLTE7XG4gICAgZm9yIChsZXQgc3RhdGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkpIHtcbiAgICAgIGlmIChtYXhJbml0aWFsaXphdGlvbkNvdW50ZXIgPCBzdGF0ZS5pbml0aWFsaXphdGlvbkNvdW50ZXIgfHxcbiAgICAgICAgbWF4SW5pdGlhbGl6YXRpb25Db3VudGVyID09PSBzdGF0ZS5pbml0aWFsaXphdGlvbkNvdW50ZXIgJiYgbWF4SW5pdGlhbGl6YXRpb25Db3VudGVyID09PSAzICYmXG4gICAgICAgIG1heFVwZGF0ZVRpbWUgPCBzdGF0ZS5sYXN0VXBkYXRlVGltZSB8fFxuICAgICAgICBtYXhJbml0aWFsaXphdGlvbkNvdW50ZXIgPT09IHN0YXRlLmluaXRpYWxpemF0aW9uQ291bnRlciAmJiBtYXhJbml0aWFsaXphdGlvbkNvdW50ZXIgPT09IDAgJiZcbiAgICAgICAgbWF4U3BlY2lmaWNhdGlvbkNvdW50IDwgc3RhdGUuc3BlY2lmaWNhdGlvbkNvdW50KSB7XG4gICAgICAgIGlmICghc3ltYm9sIHx8IChtb2RlID09PSAnc3BlY2lmaWNhdGlvbicgJiYgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbFtzeW1ib2xdKSB8fFxuICAgICAgICAgIChtb2RlID09PSAncHJpY2UnICYmIHN0YXRlLnByaWNlc0J5U3ltYm9sW3N5bWJvbF0pKSB7XG4gICAgICAgICAgbWF4VXBkYXRlVGltZSA9IHN0YXRlLmxhc3RVcGRhdGVUaW1lO1xuICAgICAgICAgIG1heEluaXRpYWxpemF0aW9uQ291bnRlciA9IHN0YXRlLmluaXRpYWxpemF0aW9uQ291bnRlcjtcbiAgICAgICAgICBtYXhTcGVjaWZpY2F0aW9uQ291bnQgPSBzdGF0ZS5zcGVjaWZpY2F0aW9uQ291bnQ7XG4gICAgICAgICAgcmVzdWx0ID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8fCB0aGlzLl9jb25zdHJ1Y3RUZXJtaW5hbFN0YXRlKCk7XG4gIH1cblxuICBfZ2V0SGFzaChvYmosIGFjY291bnRUeXBlLCBpbnRlZ2VyS2V5cykge1xuICAgIGxldCBqc29uSXRlbSA9ICcnO1xuICAgIGlmKGFjY291bnRUeXBlID09PSAnY2xvdWQtZzEnKSB7XG4gICAgICBjb25zdCBzdHJpbmdpZnkgPSAob2JqRnJvbUpzb24sIGtleSkgPT4ge1xuICAgICAgICBpZih0eXBlb2Ygb2JqRnJvbUpzb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYoaW50ZWdlcktleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iakZyb21Kc29uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqRnJvbUpzb24udG9GaXhlZCg4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihBcnJheS5pc0FycmF5KG9iakZyb21Kc29uKSkge1xuICAgICAgICAgIHJldHVybiBgWyR7b2JqRnJvbUpzb24ubWFwKGl0ZW0gPT4gc3RyaW5naWZ5KGl0ZW0pKS5qb2luKCcsJyl9XWA7IFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpGcm9tSnNvbiAhPT0gJ29iamVjdCcgfHwgb2JqRnJvbUpzb24uZ2V0VGltZSl7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iakZyb21Kc29uKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3RcbiAgICAgICAgICAua2V5cyhvYmpGcm9tSnNvbilcbiAgICAgICAgICAubWFwKGtleUl0ZW0gPT4gYFwiJHtrZXlJdGVtfVwiOiR7c3RyaW5naWZ5KG9iakZyb21Kc29uW2tleUl0ZW1dLCBrZXlJdGVtKX1gKVxuICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIHJldHVybiBgeyR7cHJvcHN9fWA7XG4gICAgICB9O1xuICAgIFxuICAgICAganNvbkl0ZW0gPSBzdHJpbmdpZnkob2JqKTtcbiAgICB9IGVsc2UgaWYoYWNjb3VudFR5cGUgPT09ICdjbG91ZC1nMicpIHtcbiAgICAgIGpzb25JdGVtID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyeXB0by5NRDUoanNvbkl0ZW0pLnRvU3RyaW5nKCk7XG4gIH1cbiAgXG59XG4iXX0=