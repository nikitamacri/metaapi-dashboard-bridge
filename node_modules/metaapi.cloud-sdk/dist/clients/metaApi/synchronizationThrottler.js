'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _timeoutError = require('../timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _optionsValidator = require('../optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Options for synchronization throttler
 * @typedef {Object} SynchronizationThrottlerOpts
 * @property {Number} [maxConcurrentSynchronizations] amount of maximum allowed concurrent synchronizations
 * @property {Number} [queueTimeoutInSeconds] allowed time for a synchronization in queue
 * @property {Number} [synchronizationTimeoutInSeconds] time after which a synchronization slot
 * is freed to be used by another synchronization
 */

/**
 * Synchronization throttler used to limit the amount of concurrent synchronizations to prevent application
 * from being overloaded due to excessive number of synchronisation responses being sent.
 */
class SynchronizationThrottler {

  /**
   * Constructs the synchronization throttler
   * @param {MetaApiWebsocketClient} client MetaApi websocket client
   * @param {Number} socketInstanceIndex index of socket instance that uses the throttler
   * @param {SynchronizationThrottlerOpts} opts synchronization throttler options
   */
  constructor(client, socketInstanceIndex, opts) {
    const validator = new _optionsValidator2.default();
    opts = opts || {};
    this._maxConcurrentSynchronizations = validator.validateNonZero(opts.maxConcurrentSynchronizations, 15, 'synchronizationThrottler.maxConcurrentSynchronizations');
    this._queueTimeoutInSeconds = validator.validateNonZero(opts.queueTimeoutInSeconds, 300, 'synchronizationThrottler.queueTimeoutInSeconds');
    this._synchronizationTimeoutInSeconds = validator.validateNonZero(opts.synchronizationTimeoutInSeconds, 10, 'synchronizationThrottler.synchronizationTimeoutInSeconds');
    this._client = client;
    this._socketInstanceIndex = socketInstanceIndex;
    this._synchronizationIds = {};
    this._accountsBySynchronizationIds = {};
    this._synchronizationQueue = [];
    this._removeOldSyncIdsInterval = null;
    this._processQueueInterval = null;
    this._logger = _logger2.default.getLogger('SynchronizationThrottler');
  }

  /**
   * Initializes the synchronization throttler
   */
  start() {
    if (!this._removeOldSyncIdsInterval) {
      this._removeOldSyncIdsInterval = setInterval(() => this._removeOldSyncIdsJob(), 1000);
      this._processQueueInterval = setInterval(() => this._processQueueJob(), 1000);
    }
  }

  /**
   * Deinitializes the throttler
   */
  stop() {
    clearInterval(this._removeOldSyncIdsInterval);
    this._removeOldSyncIdsInterval = null;
    clearInterval(this._processQueueInterval);
    this._processQueueInterval = null;
  }

  async _removeOldSyncIdsJob() {
    const now = Date.now();
    for (let key of (0, _keys2.default)(this._synchronizationIds)) {
      if (now - this._synchronizationIds[key] > this._synchronizationTimeoutInSeconds * 1000) {
        delete this._synchronizationIds[key];
      }
    }
    while (this._synchronizationQueue.length && Date.now() - this._synchronizationQueue[0].queueTime > this._queueTimeoutInSeconds * 1000) {
      this._removeFromQueue(this._synchronizationQueue[0].synchronizationId, 'timeout');
    }
    this._advanceQueue();
  }

  /**
   * Fills a synchronization slot with synchronization id
   * @param {String} synchronizationId synchronization id
   */
  updateSynchronizationId(synchronizationId) {
    if (this._accountsBySynchronizationIds[synchronizationId]) {
      this._synchronizationIds[synchronizationId] = Date.now();
    }
  }

  /**
   * Returns the list of currently synchronizing account ids
   */
  get synchronizingAccounts() {
    const synchronizingAccounts = [];
    (0, _keys2.default)(this._synchronizationIds).forEach(key => {
      const accountData = this._accountsBySynchronizationIds[key];
      if (accountData && !synchronizingAccounts.includes(accountData.accountId)) {
        synchronizingAccounts.push(accountData.accountId);
      }
    });
    return synchronizingAccounts;
  }

  /**
   * Returns the list of currenly active synchronization ids
   * @return {String[]} synchronization ids
   */
  get activeSynchronizationIds() {
    return (0, _keys2.default)(this._accountsBySynchronizationIds);
  }

  /**
   * Returns the amount of maximum allowed concurrent synchronizations
   * @return {number} maximum allowed concurrent synchronizations
   */
  get maxConcurrentSynchronizations() {
    const calculatedMax = Math.max(Math.ceil(this._client.subscribedAccountIds(this._socketInstanceIndex).length / 10), 1);
    return Math.min(calculatedMax, this._maxConcurrentSynchronizations);
  }

  /**
   * Returns flag whether there are free slots for synchronization requests
   * @return {Boolean} flag whether there are free slots for synchronization requests
   */
  get isSynchronizationAvailable() {
    if (this._client.socketInstances.reduce((acc, socketInstance) => acc + socketInstance.synchronizationThrottler.synchronizingAccounts.length, 0) >= this._maxConcurrentSynchronizations) {
      return false;
    }
    return this.synchronizingAccounts.length < this.maxConcurrentSynchronizations;
  }

  /**
   * Removes synchronizations from queue and from the list by parameters
   * @param {String} accountId account id
   * @param {Number} instanceIndex account instance index
   * @param {String} host account host name
   */
  removeIdByParameters(accountId, instanceIndex, host) {
    for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
      if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === instanceIndex && this._accountsBySynchronizationIds[key].host === host) {
        this.removeSynchronizationId(key);
      }
    }
  }

  /**
   * Removes synchronization id from slots and removes ids for the same account from the queue
   * @param {String} synchronizationId synchronization id
   */
  removeSynchronizationId(synchronizationId) {
    if (this._accountsBySynchronizationIds[synchronizationId]) {
      const accountId = this._accountsBySynchronizationIds[synchronizationId].accountId;
      const instanceIndex = this._accountsBySynchronizationIds[synchronizationId].instanceIndex;
      const host = this._accountsBySynchronizationIds[synchronizationId].host;
      for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
        if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === instanceIndex && this._accountsBySynchronizationIds[key].host === host) {
          this._removeFromQueue(key, 'cancel');
          delete this._accountsBySynchronizationIds[key];
        }
      }
    }
    if (this._synchronizationIds[synchronizationId]) {
      delete this._synchronizationIds[synchronizationId];
    }
    this._advanceQueue();
  }

  /**
   * Clears synchronization ids on disconnect
   */
  onDisconnect() {
    this._synchronizationQueue.forEach(synchronization => {
      synchronization.resolve('cancel');
    });
    this._synchronizationIds = {};
    this._accountsBySynchronizationIds = {};
    this._synchronizationQueue = [];
    this.stop();
    this.start();
  }

  _advanceQueue() {
    let index = 0;
    while (this.isSynchronizationAvailable && this._synchronizationQueue.length && index < this._synchronizationQueue.length) {
      const queueItem = this._synchronizationQueue[index];
      queueItem.resolve('synchronize');
      this.updateSynchronizationId(queueItem.synchronizationId);
      index++;
    }
  }

  _removeFromQueue(synchronizationId, result) {
    this._synchronizationQueue.forEach((syncItem, i) => {
      if (syncItem.synchronizationId === synchronizationId) {
        syncItem.resolve(result);
      }
    });
    this._synchronizationQueue = this._synchronizationQueue.filter(item => item.synchronizationId !== synchronizationId);
  }

  async _processQueueJob() {
    try {
      while (this._synchronizationQueue.length) {
        const queueItem = this._synchronizationQueue[0];
        await this._synchronizationQueue[0].promise;
        if (this._synchronizationQueue.length && this._synchronizationQueue[0].synchronizationId === queueItem.synchronizationId) {
          this._synchronizationQueue.shift();
        }
      }
    } catch (err) {
      this._logger.error('Error processing queue job', err);
    }
  }

  /**
   * Schedules to send a synchronization request for account
   * @param {String} accountId account id
   * @param {Object} request request to send
   */
  async scheduleSynchronize(accountId, request) {
    const synchronizationId = request.requestId;
    for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
      if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === request.instanceIndex && this._accountsBySynchronizationIds[key].host === request.host) {
        this.removeSynchronizationId(key);
      }
    }
    this._accountsBySynchronizationIds[synchronizationId] = { accountId, instanceIndex: request.instanceIndex,
      host: request.host };
    if (!this.isSynchronizationAvailable) {
      let resolve;
      let requestResolve = new _promise2.default(res => {
        resolve = res;
      });
      this._synchronizationQueue.push({
        synchronizationId: synchronizationId,
        promise: requestResolve,
        resolve,
        queueTime: Date.now()
      });
      const result = await requestResolve;
      if (result === 'cancel') {
        return false;
      } else if (result === 'timeout') {
        throw new _timeoutError2.default(`Account ${accountId} synchronization ${synchronizationId}` + ' timed out in synchronization queue');
      }
    }
    this.updateSynchronizationId(synchronizationId);
    await this._client._rpcRequest(accountId, request);
    return true;
  }

}
exports.default = SynchronizationThrottler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLmVzNiJdLCJuYW1lcyI6WyJTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJjb25zdHJ1Y3RvciIsImNsaWVudCIsInNvY2tldEluc3RhbmNlSW5kZXgiLCJvcHRzIiwidmFsaWRhdG9yIiwiT3B0aW9uc1ZhbGlkYXRvciIsIl9tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucyIsInZhbGlkYXRlTm9uWmVybyIsIm1heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zIiwiX3F1ZXVlVGltZW91dEluU2Vjb25kcyIsInF1ZXVlVGltZW91dEluU2Vjb25kcyIsIl9zeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzIiwic3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcyIsIl9jbGllbnQiLCJfc29ja2V0SW5zdGFuY2VJbmRleCIsIl9zeW5jaHJvbml6YXRpb25JZHMiLCJfYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyIsIl9zeW5jaHJvbml6YXRpb25RdWV1ZSIsIl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwiLCJfcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwiLCJfbG9nZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciIsInN0YXJ0Iiwic2V0SW50ZXJ2YWwiLCJfcmVtb3ZlT2xkU3luY0lkc0pvYiIsIl9wcm9jZXNzUXVldWVKb2IiLCJzdG9wIiwiY2xlYXJJbnRlcnZhbCIsIm5vdyIsIkRhdGUiLCJrZXkiLCJsZW5ndGgiLCJxdWV1ZVRpbWUiLCJfcmVtb3ZlRnJvbVF1ZXVlIiwic3luY2hyb25pemF0aW9uSWQiLCJfYWR2YW5jZVF1ZXVlIiwidXBkYXRlU3luY2hyb25pemF0aW9uSWQiLCJzeW5jaHJvbml6aW5nQWNjb3VudHMiLCJmb3JFYWNoIiwiYWNjb3VudERhdGEiLCJpbmNsdWRlcyIsImFjY291bnRJZCIsInB1c2giLCJhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMiLCJjYWxjdWxhdGVkTWF4IiwiTWF0aCIsIm1heCIsImNlaWwiLCJzdWJzY3JpYmVkQWNjb3VudElkcyIsIm1pbiIsImlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlIiwic29ja2V0SW5zdGFuY2VzIiwicmVkdWNlIiwiYWNjIiwic29ja2V0SW5zdGFuY2UiLCJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJyZW1vdmVJZEJ5UGFyYW1ldGVycyIsImluc3RhbmNlSW5kZXgiLCJob3N0IiwicmVtb3ZlU3luY2hyb25pemF0aW9uSWQiLCJvbkRpc2Nvbm5lY3QiLCJzeW5jaHJvbml6YXRpb24iLCJyZXNvbHZlIiwiaW5kZXgiLCJxdWV1ZUl0ZW0iLCJyZXN1bHQiLCJzeW5jSXRlbSIsImkiLCJmaWx0ZXIiLCJpdGVtIiwicHJvbWlzZSIsInNoaWZ0IiwiZXJyIiwiZXJyb3IiLCJzY2hlZHVsZVN5bmNocm9uaXplIiwicmVxdWVzdCIsInJlcXVlc3RJZCIsInJlcXVlc3RSZXNvbHZlIiwicmVzIiwiVGltZW91dEVycm9yIiwiX3JwY1JlcXVlc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7Ozs7OztBQVNBOzs7O0FBSWUsTUFBTUEsd0JBQU4sQ0FBK0I7O0FBRTVDOzs7Ozs7QUFNQUMsY0FBWUMsTUFBWixFQUFvQkMsbUJBQXBCLEVBQXlDQyxJQUF6QyxFQUErQztBQUM3QyxVQUFNQyxZQUFZLElBQUlDLDBCQUFKLEVBQWxCO0FBQ0FGLFdBQU9BLFFBQVEsRUFBZjtBQUNBLFNBQUtHLDhCQUFMLEdBQXNDRixVQUFVRyxlQUFWLENBQTBCSixLQUFLSyw2QkFBL0IsRUFBOEQsRUFBOUQsRUFDcEMsd0RBRG9DLENBQXRDO0FBRUEsU0FBS0Msc0JBQUwsR0FBOEJMLFVBQVVHLGVBQVYsQ0FBMEJKLEtBQUtPLHFCQUEvQixFQUFzRCxHQUF0RCxFQUM1QixnREFENEIsQ0FBOUI7QUFFQSxTQUFLQyxnQ0FBTCxHQUF3Q1AsVUFBVUcsZUFBVixDQUEwQkosS0FBS1MsK0JBQS9CLEVBQWdFLEVBQWhFLEVBQ3RDLDBEQURzQyxDQUF4QztBQUVBLFNBQUtDLE9BQUwsR0FBZVosTUFBZjtBQUNBLFNBQUthLG9CQUFMLEdBQTRCWixtQkFBNUI7QUFDQSxTQUFLYSxtQkFBTCxHQUEyQixFQUEzQjtBQUNBLFNBQUtDLDZCQUFMLEdBQXFDLEVBQXJDO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLQyx5QkFBTCxHQUFpQyxJQUFqQztBQUNBLFNBQUtDLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0EsU0FBS0MsT0FBTCxHQUFlQyxpQkFBY0MsU0FBZCxDQUF3QiwwQkFBeEIsQ0FBZjtBQUNEOztBQUVEOzs7QUFHQUMsVUFBUTtBQUNOLFFBQUcsQ0FBQyxLQUFLTCx5QkFBVCxFQUFvQztBQUNsQyxXQUFLQSx5QkFBTCxHQUFpQ00sWUFBWSxNQUFNLEtBQUtDLG9CQUFMLEVBQWxCLEVBQStDLElBQS9DLENBQWpDO0FBQ0EsV0FBS04scUJBQUwsR0FBNkJLLFlBQVksTUFBTSxLQUFLRSxnQkFBTCxFQUFsQixFQUEyQyxJQUEzQyxDQUE3QjtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBQyxTQUFPO0FBQ0xDLGtCQUFjLEtBQUtWLHlCQUFuQjtBQUNBLFNBQUtBLHlCQUFMLEdBQWlDLElBQWpDO0FBQ0FVLGtCQUFjLEtBQUtULHFCQUFuQjtBQUNBLFNBQUtBLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0Q7O0FBRUQsUUFBTU0sb0JBQU4sR0FBNkI7QUFDM0IsVUFBTUksTUFBTUMsS0FBS0QsR0FBTCxFQUFaO0FBQ0EsU0FBSyxJQUFJRSxHQUFULElBQWdCLG9CQUFZLEtBQUtoQixtQkFBakIsQ0FBaEIsRUFBdUQ7QUFDckQsVUFBS2MsTUFBTSxLQUFLZCxtQkFBTCxDQUF5QmdCLEdBQXpCLENBQVAsR0FBd0MsS0FBS3BCLGdDQUFMLEdBQXdDLElBQXBGLEVBQTBGO0FBQ3hGLGVBQU8sS0FBS0ksbUJBQUwsQ0FBeUJnQixHQUF6QixDQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU8sS0FBS2QscUJBQUwsQ0FBMkJlLE1BQTNCLElBQXNDRixLQUFLRCxHQUFMLEtBQWEsS0FBS1oscUJBQUwsQ0FBMkIsQ0FBM0IsRUFBOEJnQixTQUE1QyxHQUN4QyxLQUFLeEIsc0JBQUwsR0FBOEIsSUFEbEMsRUFDd0M7QUFDdEMsV0FBS3lCLGdCQUFMLENBQXNCLEtBQUtqQixxQkFBTCxDQUEyQixDQUEzQixFQUE4QmtCLGlCQUFwRCxFQUF1RSxTQUF2RTtBQUNEO0FBQ0QsU0FBS0MsYUFBTDtBQUNEOztBQUVEOzs7O0FBSUFDLDBCQUF3QkYsaUJBQXhCLEVBQTJDO0FBQ3pDLFFBQUcsS0FBS25CLDZCQUFMLENBQW1DbUIsaUJBQW5DLENBQUgsRUFBMEQ7QUFDeEQsV0FBS3BCLG1CQUFMLENBQXlCb0IsaUJBQXpCLElBQThDTCxLQUFLRCxHQUFMLEVBQTlDO0FBQ0Q7QUFDRjs7QUFFRDs7O0FBR0EsTUFBSVMscUJBQUosR0FBNEI7QUFDMUIsVUFBTUEsd0JBQXdCLEVBQTlCO0FBQ0Esd0JBQVksS0FBS3ZCLG1CQUFqQixFQUFzQ3dCLE9BQXRDLENBQThDUixPQUFPO0FBQ25ELFlBQU1TLGNBQWMsS0FBS3hCLDZCQUFMLENBQW1DZSxHQUFuQyxDQUFwQjtBQUNBLFVBQUdTLGVBQWUsQ0FBQ0Ysc0JBQXNCRyxRQUF0QixDQUErQkQsWUFBWUUsU0FBM0MsQ0FBbkIsRUFBMEU7QUFDeEVKLDhCQUFzQkssSUFBdEIsQ0FBMkJILFlBQVlFLFNBQXZDO0FBQ0Q7QUFDRixLQUxEO0FBTUEsV0FBT0oscUJBQVA7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUlNLHdCQUFKLEdBQStCO0FBQzdCLFdBQU8sb0JBQVksS0FBSzVCLDZCQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxNQUFJUiw2QkFBSixHQUFvQztBQUNsQyxVQUFNcUMsZ0JBQWdCQyxLQUFLQyxHQUFMLENBQVNELEtBQUtFLElBQUwsQ0FDN0IsS0FBS25DLE9BQUwsQ0FBYW9DLG9CQUFiLENBQWtDLEtBQUtuQyxvQkFBdkMsRUFBNkRrQixNQUE3RCxHQUFzRSxFQUR6QyxDQUFULEVBQ3VELENBRHZELENBQXRCO0FBRUEsV0FBT2MsS0FBS0ksR0FBTCxDQUFTTCxhQUFULEVBQXdCLEtBQUt2Qyw4QkFBN0IsQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSTZDLDBCQUFKLEdBQWlDO0FBQy9CLFFBQUksS0FBS3RDLE9BQUwsQ0FBYXVDLGVBQWIsQ0FBNkJDLE1BQTdCLENBQW9DLENBQUNDLEdBQUQsRUFBTUMsY0FBTixLQUN0Q0QsTUFBTUMsZUFBZUMsd0JBQWYsQ0FBd0NsQixxQkFBeEMsQ0FBOEROLE1BRGxFLEVBQzBFLENBRDFFLEtBRUYsS0FBSzFCLDhCQUZQLEVBRXVDO0FBQ3JDLGFBQU8sS0FBUDtBQUNEO0FBQ0QsV0FBTyxLQUFLZ0MscUJBQUwsQ0FBMkJOLE1BQTNCLEdBQW9DLEtBQUt4Qiw2QkFBaEQ7QUFDRDs7QUFFRDs7Ozs7O0FBTUFpRCx1QkFBcUJmLFNBQXJCLEVBQWdDZ0IsYUFBaEMsRUFBK0NDLElBQS9DLEVBQXFEO0FBQ25ELFNBQUssSUFBSTVCLEdBQVQsSUFBZ0Isb0JBQVksS0FBS2YsNkJBQWpCLENBQWhCLEVBQWlFO0FBQy9ELFVBQUcsS0FBS0EsNkJBQUwsQ0FBbUNlLEdBQW5DLEVBQXdDVyxTQUF4QyxLQUFzREEsU0FBdEQsSUFDQyxLQUFLMUIsNkJBQUwsQ0FBbUNlLEdBQW5DLEVBQXdDMkIsYUFBeEMsS0FBMERBLGFBRDNELElBRUMsS0FBSzFDLDZCQUFMLENBQW1DZSxHQUFuQyxFQUF3QzRCLElBQXhDLEtBQWlEQSxJQUZyRCxFQUUyRDtBQUN6RCxhQUFLQyx1QkFBTCxDQUE2QjdCLEdBQTdCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7O0FBSUE2QiwwQkFBd0J6QixpQkFBeEIsRUFBMkM7QUFDekMsUUFBSSxLQUFLbkIsNkJBQUwsQ0FBbUNtQixpQkFBbkMsQ0FBSixFQUEyRDtBQUN6RCxZQUFNTyxZQUFZLEtBQUsxQiw2QkFBTCxDQUFtQ21CLGlCQUFuQyxFQUFzRE8sU0FBeEU7QUFDQSxZQUFNZ0IsZ0JBQWdCLEtBQUsxQyw2QkFBTCxDQUFtQ21CLGlCQUFuQyxFQUFzRHVCLGFBQTVFO0FBQ0EsWUFBTUMsT0FBTyxLQUFLM0MsNkJBQUwsQ0FBbUNtQixpQkFBbkMsRUFBc0R3QixJQUFuRTtBQUNBLFdBQUssSUFBSTVCLEdBQVQsSUFBZ0Isb0JBQVksS0FBS2YsNkJBQWpCLENBQWhCLEVBQWlFO0FBQy9ELFlBQUcsS0FBS0EsNkJBQUwsQ0FBbUNlLEdBQW5DLEVBQXdDVyxTQUF4QyxLQUFzREEsU0FBdEQsSUFDRCxLQUFLMUIsNkJBQUwsQ0FBbUNlLEdBQW5DLEVBQXdDMkIsYUFBeEMsS0FBMERBLGFBRHpELElBRUQsS0FBSzFDLDZCQUFMLENBQW1DZSxHQUFuQyxFQUF3QzRCLElBQXhDLEtBQWlEQSxJQUZuRCxFQUV5RDtBQUN2RCxlQUFLekIsZ0JBQUwsQ0FBc0JILEdBQXRCLEVBQTJCLFFBQTNCO0FBQ0EsaUJBQU8sS0FBS2YsNkJBQUwsQ0FBbUNlLEdBQW5DLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxRQUFHLEtBQUtoQixtQkFBTCxDQUF5Qm9CLGlCQUF6QixDQUFILEVBQWdEO0FBQzlDLGFBQU8sS0FBS3BCLG1CQUFMLENBQXlCb0IsaUJBQXpCLENBQVA7QUFDRDtBQUNELFNBQUtDLGFBQUw7QUFDRDs7QUFFRDs7O0FBR0F5QixpQkFBZTtBQUNiLFNBQUs1QyxxQkFBTCxDQUEyQnNCLE9BQTNCLENBQW1DdUIsbUJBQW1CO0FBQ3BEQSxzQkFBZ0JDLE9BQWhCLENBQXdCLFFBQXhCO0FBQ0QsS0FGRDtBQUdBLFNBQUtoRCxtQkFBTCxHQUEyQixFQUEzQjtBQUNBLFNBQUtDLDZCQUFMLEdBQXFDLEVBQXJDO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLVSxJQUFMO0FBQ0EsU0FBS0osS0FBTDtBQUNEOztBQUVEYSxrQkFBZ0I7QUFDZCxRQUFJNEIsUUFBUSxDQUFaO0FBQ0EsV0FBTSxLQUFLYiwwQkFBTCxJQUFtQyxLQUFLbEMscUJBQUwsQ0FBMkJlLE1BQTlELElBQ0ZnQyxRQUFRLEtBQUsvQyxxQkFBTCxDQUEyQmUsTUFEdkMsRUFDK0M7QUFDN0MsWUFBTWlDLFlBQVksS0FBS2hELHFCQUFMLENBQTJCK0MsS0FBM0IsQ0FBbEI7QUFDQUMsZ0JBQVVGLE9BQVYsQ0FBa0IsYUFBbEI7QUFDQSxXQUFLMUIsdUJBQUwsQ0FBNkI0QixVQUFVOUIsaUJBQXZDO0FBQ0E2QjtBQUNEO0FBQ0Y7O0FBRUQ5QixtQkFBaUJDLGlCQUFqQixFQUFvQytCLE1BQXBDLEVBQTRDO0FBQzFDLFNBQUtqRCxxQkFBTCxDQUEyQnNCLE9BQTNCLENBQW1DLENBQUM0QixRQUFELEVBQVdDLENBQVgsS0FBaUI7QUFDbEQsVUFBR0QsU0FBU2hDLGlCQUFULEtBQStCQSxpQkFBbEMsRUFBcUQ7QUFDbkRnQyxpQkFBU0osT0FBVCxDQUFpQkcsTUFBakI7QUFDRDtBQUNGLEtBSkQ7QUFLQSxTQUFLakQscUJBQUwsR0FBNkIsS0FBS0EscUJBQUwsQ0FBMkJvRCxNQUEzQixDQUFrQ0MsUUFDN0RBLEtBQUtuQyxpQkFBTCxLQUEyQkEsaUJBREEsQ0FBN0I7QUFFRDs7QUFFRCxRQUFNVCxnQkFBTixHQUF5QjtBQUN2QixRQUFJO0FBQ0YsYUFBTyxLQUFLVCxxQkFBTCxDQUEyQmUsTUFBbEMsRUFBMEM7QUFDeEMsY0FBTWlDLFlBQVksS0FBS2hELHFCQUFMLENBQTJCLENBQTNCLENBQWxCO0FBQ0EsY0FBTSxLQUFLQSxxQkFBTCxDQUEyQixDQUEzQixFQUE4QnNELE9BQXBDO0FBQ0EsWUFBRyxLQUFLdEQscUJBQUwsQ0FBMkJlLE1BQTNCLElBQXFDLEtBQUtmLHFCQUFMLENBQTJCLENBQTNCLEVBQThCa0IsaUJBQTlCLEtBQ3BDOEIsVUFBVTlCLGlCQURkLEVBQ2lDO0FBQy9CLGVBQUtsQixxQkFBTCxDQUEyQnVELEtBQTNCO0FBQ0Q7QUFDRjtBQUNGLEtBVEQsQ0FTRSxPQUFPQyxHQUFQLEVBQVk7QUFDWixXQUFLckQsT0FBTCxDQUFhc0QsS0FBYixDQUFtQiw0QkFBbkIsRUFBaURELEdBQWpEO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7QUFLQSxRQUFNRSxtQkFBTixDQUEwQmpDLFNBQTFCLEVBQXFDa0MsT0FBckMsRUFBOEM7QUFDNUMsVUFBTXpDLG9CQUFvQnlDLFFBQVFDLFNBQWxDO0FBQ0EsU0FBSyxJQUFJOUMsR0FBVCxJQUFnQixvQkFBWSxLQUFLZiw2QkFBakIsQ0FBaEIsRUFBaUU7QUFDL0QsVUFBRyxLQUFLQSw2QkFBTCxDQUFtQ2UsR0FBbkMsRUFBd0NXLFNBQXhDLEtBQXNEQSxTQUF0RCxJQUNELEtBQUsxQiw2QkFBTCxDQUFtQ2UsR0FBbkMsRUFBd0MyQixhQUF4QyxLQUEwRGtCLFFBQVFsQixhQURqRSxJQUVELEtBQUsxQyw2QkFBTCxDQUFtQ2UsR0FBbkMsRUFBd0M0QixJQUF4QyxLQUFpRGlCLFFBQVFqQixJQUYzRCxFQUVpRTtBQUMvRCxhQUFLQyx1QkFBTCxDQUE2QjdCLEdBQTdCO0FBQ0Q7QUFDRjtBQUNELFNBQUtmLDZCQUFMLENBQW1DbUIsaUJBQW5DLElBQXdELEVBQUNPLFNBQUQsRUFBWWdCLGVBQWVrQixRQUFRbEIsYUFBbkM7QUFDdERDLFlBQU1pQixRQUFRakIsSUFEd0MsRUFBeEQ7QUFFQSxRQUFHLENBQUMsS0FBS1IsMEJBQVQsRUFBcUM7QUFDbkMsVUFBSVksT0FBSjtBQUNBLFVBQUllLGlCQUFpQixzQkFBYUMsR0FBRCxJQUFTO0FBQ3hDaEIsa0JBQVVnQixHQUFWO0FBQ0QsT0FGb0IsQ0FBckI7QUFHQSxXQUFLOUQscUJBQUwsQ0FBMkIwQixJQUEzQixDQUFnQztBQUM5QlIsMkJBQW1CQSxpQkFEVztBQUU5Qm9DLGlCQUFTTyxjQUZxQjtBQUc5QmYsZUFIOEI7QUFJOUI5QixtQkFBV0gsS0FBS0QsR0FBTDtBQUptQixPQUFoQztBQU1BLFlBQU1xQyxTQUFTLE1BQU1ZLGNBQXJCO0FBQ0EsVUFBR1osV0FBVyxRQUFkLEVBQXdCO0FBQ3RCLGVBQU8sS0FBUDtBQUNELE9BRkQsTUFFTyxJQUFHQSxXQUFXLFNBQWQsRUFBeUI7QUFDOUIsY0FBTSxJQUFJYyxzQkFBSixDQUFrQixXQUFVdEMsU0FBVSxvQkFBbUJQLGlCQUFrQixFQUExRCxHQUN2QixxQ0FETSxDQUFOO0FBRUQ7QUFDRjtBQUNELFNBQUtFLHVCQUFMLENBQTZCRixpQkFBN0I7QUFDQSxVQUFNLEtBQUt0QixPQUFMLENBQWFvRSxXQUFiLENBQXlCdkMsU0FBekIsRUFBb0NrQyxPQUFwQyxDQUFOO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBcFAyQztrQkFBekI3RSx3QiIsImZpbGUiOiJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vdGltZW91dEVycm9yJztcbmltcG9ydCBPcHRpb25zVmFsaWRhdG9yIGZyb20gJy4uL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vLi4vbG9nZ2VyJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBzeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzXG4gKiBAcHJvcGVydHkge051bWJlcn0gW21heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zXSBhbW91bnQgb2YgbWF4aW11bSBhbGxvd2VkIGNvbmN1cnJlbnQgc3luY2hyb25pemF0aW9uc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtxdWV1ZVRpbWVvdXRJblNlY29uZHNdIGFsbG93ZWQgdGltZSBmb3IgYSBzeW5jaHJvbml6YXRpb24gaW4gcXVldWVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kc10gdGltZSBhZnRlciB3aGljaCBhIHN5bmNocm9uaXphdGlvbiBzbG90XG4gKiBpcyBmcmVlZCB0byBiZSB1c2VkIGJ5IGFub3RoZXIgc3luY2hyb25pemF0aW9uXG4gKi9cblxuLyoqXG4gKiBTeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyIHVzZWQgdG8gbGltaXQgdGhlIGFtb3VudCBvZiBjb25jdXJyZW50IHN5bmNocm9uaXphdGlvbnMgdG8gcHJldmVudCBhcHBsaWNhdGlvblxuICogZnJvbSBiZWluZyBvdmVybG9hZGVkIGR1ZSB0byBleGNlc3NpdmUgbnVtYmVyIG9mIHN5bmNocm9uaXNhdGlvbiByZXNwb25zZXMgYmVpbmcgc2VudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3luY2hyb25pemF0aW9uVGhyb3R0bGVyIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgc3luY2hyb25pemF0aW9uIHRocm90dGxlclxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IGNsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNvY2tldEluc3RhbmNlSW5kZXggaW5kZXggb2Ygc29ja2V0IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgdGhyb3R0bGVyXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0c30gb3B0cyBzeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgc29ja2V0SW5zdGFuY2VJbmRleCwgb3B0cykge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5fbWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMubWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMsIDE1LFxuICAgICAgJ3N5bmNocm9uaXphdGlvblRocm90dGxlci5tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucycpO1xuICAgIHRoaXMuX3F1ZXVlVGltZW91dEluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5xdWV1ZVRpbWVvdXRJblNlY29uZHMsIDMwMCxcbiAgICAgICdzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIucXVldWVUaW1lb3V0SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5zeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzLCAxMCxcbiAgICAgICdzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcycpO1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZUluZGV4ID0gc29ja2V0SW5zdGFuY2VJbmRleDtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25JZHMgPSB7fTtcbiAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUgPSBbXTtcbiAgICB0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZUludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignU3luY2hyb25pemF0aW9uVGhyb3R0bGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHN5bmNocm9uaXphdGlvbiB0aHJvdHRsZXJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmKCF0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3JlbW92ZU9sZFN5bmNJZHNJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX3JlbW92ZU9sZFN5bmNJZHNKb2IoKSwgMTAwMCk7XG4gICAgICB0aGlzLl9wcm9jZXNzUXVldWVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX3Byb2Nlc3NRdWV1ZUpvYigpLCAxMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVpbml0aWFsaXplcyB0aGUgdGhyb3R0bGVyXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVtb3ZlT2xkU3luY0lkc0ludGVydmFsKTtcbiAgICB0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwgPSBudWxsO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwpO1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZUludGVydmFsID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIF9yZW1vdmVPbGRTeW5jSWRzSm9iKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbklkcykpIHtcbiAgICAgIGlmICgobm93IC0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRzW2tleV0pID4gdGhpcy5fc3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoICYmIChEYXRlLm5vdygpIC0gdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0ucXVldWVUaW1lKSA+IFxuICAgICAgICB0aGlzLl9xdWV1ZVRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUXVldWUodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0uc3luY2hyb25pemF0aW9uSWQsICd0aW1lb3V0Jyk7XG4gICAgfVxuICAgIHRoaXMuX2FkdmFuY2VRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGEgc3luY2hyb25pemF0aW9uIHNsb3Qgd2l0aCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiBpZFxuICAgKi9cbiAgdXBkYXRlU3luY2hyb25pemF0aW9uSWQoc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBpZih0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY3VycmVudGx5IHN5bmNocm9uaXppbmcgYWNjb3VudCBpZHNcbiAgICovXG4gIGdldCBzeW5jaHJvbml6aW5nQWNjb3VudHMoKSB7XG4gICAgY29uc3Qgc3luY2hyb25pemluZ0FjY291bnRzID0gW107XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3luY2hyb25pemF0aW9uSWRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50RGF0YSA9IHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XTtcbiAgICAgIGlmKGFjY291bnREYXRhICYmICFzeW5jaHJvbml6aW5nQWNjb3VudHMuaW5jbHVkZXMoYWNjb3VudERhdGEuYWNjb3VudElkKSkge1xuICAgICAgICBzeW5jaHJvbml6aW5nQWNjb3VudHMucHVzaChhY2NvdW50RGF0YS5hY2NvdW50SWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzeW5jaHJvbml6aW5nQWNjb3VudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjdXJyZW5seSBhY3RpdmUgc3luY2hyb25pemF0aW9uIGlkc1xuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gc3luY2hyb25pemF0aW9uIGlkc1xuICAgKi9cbiAgZ2V0IGFjdGl2ZVN5bmNocm9uaXphdGlvbklkcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIG1heGltdW0gYWxsb3dlZCBjb25jdXJyZW50IHN5bmNocm9uaXphdGlvbnNcbiAgICogQHJldHVybiB7bnVtYmVyfSBtYXhpbXVtIGFsbG93ZWQgY29uY3VycmVudCBzeW5jaHJvbml6YXRpb25zXG4gICAqL1xuICBnZXQgbWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMoKSB7XG4gICAgY29uc3QgY2FsY3VsYXRlZE1heCA9IE1hdGgubWF4KE1hdGguY2VpbChcbiAgICAgIHRoaXMuX2NsaWVudC5zdWJzY3JpYmVkQWNjb3VudElkcyh0aGlzLl9zb2NrZXRJbnN0YW5jZUluZGV4KS5sZW5ndGggLyAxMCksIDEpO1xuICAgIHJldHVybiBNYXRoLm1pbihjYWxjdWxhdGVkTWF4LCB0aGlzLl9tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIHdoZXRoZXIgdGhlcmUgYXJlIGZyZWUgc2xvdHMgZm9yIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0c1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmbGFnIHdoZXRoZXIgdGhlcmUgYXJlIGZyZWUgc2xvdHMgZm9yIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jbGllbnQuc29ja2V0SW5zdGFuY2VzLnJlZHVjZSgoYWNjLCBzb2NrZXRJbnN0YW5jZSkgPT4gXG4gICAgICBhY2MgKyBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuc3luY2hyb25pemluZ0FjY291bnRzLmxlbmd0aCwgMCkgPj1cbiAgICAgIHRoaXMuX21heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN5bmNocm9uaXppbmdBY2NvdW50cy5sZW5ndGggPCB0aGlzLm1heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9ucyBmcm9tIHF1ZXVlIGFuZCBmcm9tIHRoZSBsaXN0IGJ5IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGFjY291bnQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3QgYWNjb3VudCBob3N0IG5hbWVcbiAgICovXG4gIHJlbW92ZUlkQnlQYXJhbWV0ZXJzKGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCwgaG9zdCkge1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzKSkge1xuICAgICAgaWYodGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmFjY291bnRJZCA9PT0gYWNjb3VudElkICYmXG4gICAgICAgICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmluc3RhbmNlSW5kZXggPT09IGluc3RhbmNlSW5kZXggJiZcbiAgICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaG9zdCA9PT0gaG9zdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVN5bmNocm9uaXphdGlvbklkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9uIGlkIGZyb20gc2xvdHMgYW5kIHJlbW92ZXMgaWRzIGZvciB0aGUgc2FtZSBhY2NvdW50IGZyb20gdGhlIHF1ZXVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICovXG4gIHJlbW92ZVN5bmNocm9uaXphdGlvbklkKHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNbc3luY2hyb25pemF0aW9uSWRdKSB7XG4gICAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXS5hY2NvdW50SWQ7XG4gICAgICBjb25zdCBpbnN0YW5jZUluZGV4ID0gdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0uaW5zdGFuY2VJbmRleDtcbiAgICAgIGNvbnN0IGhvc3QgPSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXS5ob3N0O1xuICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHMpKSB7XG4gICAgICAgIGlmKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5hY2NvdW50SWQgPT09IGFjY291bnRJZCAmJiBcbiAgICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaW5zdGFuY2VJbmRleCA9PT0gaW5zdGFuY2VJbmRleCAmJlxuICAgICAgICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5ob3N0ID09PSBob3N0KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVF1ZXVlKGtleSwgJ2NhbmNlbCcpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF07XG4gICAgfVxuICAgIHRoaXMuX2FkdmFuY2VRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBzeW5jaHJvbml6YXRpb24gaWRzIG9uIGRpc2Nvbm5lY3RcbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZS5mb3JFYWNoKHN5bmNocm9uaXphdGlvbiA9PiB7XG4gICAgICBzeW5jaHJvbml6YXRpb24ucmVzb2x2ZSgnY2FuY2VsJyk7XG4gICAgfSk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRzID0ge307XG4gICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyA9IHt9O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlID0gW107XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgX2FkdmFuY2VRdWV1ZSgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlKHRoaXMuaXNTeW5jaHJvbml6YXRpb25BdmFpbGFibGUgJiYgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoICYmIFxuICAgICAgICBpbmRleCA8IHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcXVldWVJdGVtID0gdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbaW5kZXhdO1xuICAgICAgcXVldWVJdGVtLnJlc29sdmUoJ3N5bmNocm9uaXplJyk7XG4gICAgICB0aGlzLnVwZGF0ZVN5bmNocm9uaXphdGlvbklkKHF1ZXVlSXRlbS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIF9yZW1vdmVGcm9tUXVldWUoc3luY2hyb25pemF0aW9uSWQsIHJlc3VsdCkge1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmZvckVhY2goKHN5bmNJdGVtLCBpKSA9PiB7XG4gICAgICBpZihzeW5jSXRlbS5zeW5jaHJvbml6YXRpb25JZCA9PT0gc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICAgICAgc3luY0l0ZW0ucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlID0gdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUuZmlsdGVyKGl0ZW0gPT4gXG4gICAgICBpdGVtLnN5bmNocm9uaXphdGlvbklkICE9PSBzeW5jaHJvbml6YXRpb25JZCk7XG4gIH1cblxuICBhc3luYyBfcHJvY2Vzc1F1ZXVlSm9iKCkge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbSA9IHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlWzBdO1xuICAgICAgICBhd2FpdCB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZVswXS5wcm9taXNlO1xuICAgICAgICBpZih0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZS5sZW5ndGggJiYgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0uc3luY2hyb25pemF0aW9uSWQgPT09IFxuICAgICAgICAgICAgcXVldWVJdGVtLnN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHF1ZXVlIGpvYicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyB0byBzZW5kIGEgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgZm9yIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IHJlcXVlc3QgdG8gc2VuZFxuICAgKi9cbiAgYXN5bmMgc2NoZWR1bGVTeW5jaHJvbml6ZShhY2NvdW50SWQsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBzeW5jaHJvbml6YXRpb25JZCA9IHJlcXVlc3QucmVxdWVzdElkO1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzKSkge1xuICAgICAgaWYodGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmFjY291bnRJZCA9PT0gYWNjb3VudElkICYmXG4gICAgICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5pbnN0YW5jZUluZGV4ID09PSByZXF1ZXN0Lmluc3RhbmNlSW5kZXggJiZcbiAgICAgICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmhvc3QgPT09IHJlcXVlc3QuaG9zdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVN5bmNocm9uaXphdGlvbklkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNbc3luY2hyb25pemF0aW9uSWRdID0ge2FjY291bnRJZCwgaW5zdGFuY2VJbmRleDogcmVxdWVzdC5pbnN0YW5jZUluZGV4LFxuICAgICAgaG9zdDogcmVxdWVzdC5ob3N0fTtcbiAgICBpZighdGhpcy5pc1N5bmNocm9uaXphdGlvbkF2YWlsYWJsZSkge1xuICAgICAgbGV0IHJlc29sdmU7XG4gICAgICBsZXQgcmVxdWVzdFJlc29sdmUgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICBzeW5jaHJvbml6YXRpb25JZDogc3luY2hyb25pemF0aW9uSWQsXG4gICAgICAgIHByb21pc2U6IHJlcXVlc3RSZXNvbHZlLFxuICAgICAgICByZXNvbHZlLFxuICAgICAgICBxdWV1ZVRpbWU6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdFJlc29sdmU7XG4gICAgICBpZihyZXN1bHQgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZihyZXN1bHQgPT09ICd0aW1lb3V0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKGBBY2NvdW50ICR7YWNjb3VudElkfSBzeW5jaHJvbml6YXRpb24gJHtzeW5jaHJvbml6YXRpb25JZH1gICtcbiAgICAgICAgJyB0aW1lZCBvdXQgaW4gc3luY2hyb25pemF0aW9uIHF1ZXVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3luY2hyb25pemF0aW9uSWQoc3luY2hyb25pemF0aW9uSWQpO1xuICAgIGF3YWl0IHRoaXMuX2NsaWVudC5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn0iXX0=