'use strict';

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _provisioningProfile = require('./provisioningProfile.client');

var _provisioningProfile2 = _interopRequireDefault(_provisioningProfile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const provisioningApiUrl = 'https://mt-provisioning-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {ProvisioningProfileClient}
 */
describe('ProvisioningProfileClient', () => {

  let provisioningClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let sandbox;
  let requestStub;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    provisioningClient = new _provisioningProfile2.default(httpClient, token);
    requestStub = sandbox.stub(httpClient, 'request');
  });

  afterEach(() => {
    sandbox.restore();
  });

  /**
   * @test {ProvisioningProfileClient#getProvisioningProfiles}
   */
  it('should retrieve provisioning profiles from API', async () => {
    let expected = [{
      _id: 'id',
      name: 'name',
      version: 4,
      status: 'active'
    }];
    requestStub.resolves(expected);
    let profiles = await provisioningClient.getProvisioningProfiles(5, 'active');
    profiles.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles`,
      method: 'GET',
      qs: {
        version: 5,
        status: 'active'
      },
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {MetatraderAccountClient#getProvisioningProfiles}
   */
  it('should not retrieve provisioning profiles from API with account token', async () => {
    provisioningClient = new _provisioningProfile2.default(httpClient, 'token');
    try {
      await provisioningClient.getProvisioningProfiles(5, 'active');
    } catch (error) {
      error.message.should.equal('You can not invoke getProvisioningProfiles method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#getProvisioningProfile}
   */
  it('should retrieve provisioning profile from API', async () => {
    let expected = {
      _id: 'id',
      name: 'name',
      version: 4,
      status: 'active'
    };
    requestStub.resolves(expected);
    let profile = await provisioningClient.getProvisioningProfile('id');
    profile.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {MetatraderAccountClient#getProvisioningProfile}
   */
  it('should not retrieve provisioning profile from API with account token', async () => {
    provisioningClient = new _provisioningProfile2.default(httpClient, 'token');
    try {
      await provisioningClient.getProvisioningProfile('id');
    } catch (error) {
      error.message.should.equal('You can not invoke getProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#createProvisioningProfile}
   */
  it('should create provisioning profile via API', async () => {
    let expected = {
      id: 'id'
    };
    let profile = {
      name: 'name',
      version: 4
    };
    requestStub.resolves(expected);
    let id = await provisioningClient.createProvisioningProfile(profile);
    id.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles`,
      method: 'POST',
      body: profile,
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {MetatraderAccountClient#createProvisioningProfile}
   */
  it('should not create provisioning profile via API with account token', async () => {
    provisioningClient = new _provisioningProfile2.default(httpClient, 'token');
    try {
      await provisioningClient.createProvisioningProfile({});
    } catch (error) {
      error.message.should.equal('You can not invoke createProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#uploadProvisioningProfileFile}
   */
  it('should upload file to a provisioning profile via API', async () => {
    let file = Buffer.from('test', 'utf8');
    await provisioningClient.uploadProvisioningProfileFile('id', 'servers.dat', file);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id/servers.dat`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      formData: {
        file
      },
      json: true
    });
  });

  /**
   * @test {MetatraderAccountClient#uploadProvisioningProfileFile}
   */
  it('should not upload provisioning profile file via API with account token', async () => {
    provisioningClient = new _provisioningProfile2.default(httpClient, 'token');
    try {
      await provisioningClient.uploadProvisioningProfileFile('id', 'servers.dat', {});
    } catch (error) {
      error.message.should.equal('You can not invoke uploadProvisioningProfileFile method, because you have connected with account access' + ' token. Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#deleteProvisioningProfile}
   */
  it('should delete provisioning profile via API', async () => {
    await provisioningClient.deleteProvisioningProfile('id');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id`,
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {MetatraderAccountClient#deleteProvisioningProfile}
   */
  it('should not delete provisioning profile via API with account token', async () => {
    provisioningClient = new _provisioningProfile2.default(httpClient, 'token');
    try {
      await provisioningClient.deleteProvisioningProfile('id');
    } catch (error) {
      error.message.should.equal('You can not invoke deleteProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ProvisioningProfileClient#updateProvisioningProfile}
   */
  it('should update provisioning profile via API', async () => {
    await provisioningClient.updateProvisioningProfile('id', { name: 'new name' });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${provisioningApiUrl}/users/current/provisioning-profiles/id`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        name: 'new name'
      }
    });
  });

  /**
   * @test {MetatraderAccountClient#updateProvisioningProfile}
   */
  it('should not update provisioning profile via API with account token', async () => {
    provisioningClient = new _provisioningProfile2.default(httpClient, 'token');
    try {
      await provisioningClient.updateProvisioningProfile('id', { name: 'new name' });
    } catch (error) {
      error.message.should.equal('You can not invoke updateProvisioningProfile method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvcHJvdmlzaW9uaW5nUHJvZmlsZS5jbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsicHJvdmlzaW9uaW5nQXBpVXJsIiwiZGVzY3JpYmUiLCJwcm92aXNpb25pbmdDbGllbnQiLCJ0b2tlbiIsImh0dHBDbGllbnQiLCJIdHRwQ2xpZW50Iiwic2FuZGJveCIsInJlcXVlc3RTdHViIiwiYmVmb3JlIiwic2lub24iLCJjcmVhdGVTYW5kYm94IiwiYmVmb3JlRWFjaCIsIlByb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQiLCJzdHViIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZSIsIml0IiwiZXhwZWN0ZWQiLCJfaWQiLCJuYW1lIiwidmVyc2lvbiIsInN0YXR1cyIsInJlc29sdmVzIiwicHJvZmlsZXMiLCJnZXRQcm92aXNpb25pbmdQcm9maWxlcyIsInNob3VsZCIsImVxdWFsIiwiYXNzZXJ0IiwiY2FsbGVkT25jZVdpdGhFeGFjdGx5IiwicmVxdWVzdCIsInVybCIsIm1ldGhvZCIsInFzIiwiaGVhZGVycyIsImpzb24iLCJlcnJvciIsIm1lc3NhZ2UiLCJwcm9maWxlIiwiZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZSIsImlkIiwiY3JlYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSIsImJvZHkiLCJmaWxlIiwiQnVmZmVyIiwiZnJvbSIsInVwbG9hZFByb3Zpc2lvbmluZ1Byb2ZpbGVGaWxlIiwiZm9ybURhdGEiLCJkZWxldGVQcm92aXNpb25pbmdQcm9maWxlIiwidXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxxQkFBcUIsNkRBQTNCOztBQUVBOzs7QUFHQUMsU0FBUywyQkFBVCxFQUFzQyxNQUFNOztBQUUxQyxNQUFJQyxrQkFBSjtBQUNBLFFBQU1DLFFBQVEscUJBQWQ7QUFDQSxNQUFJQyxhQUFhLElBQUlDLG9CQUFKLEVB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SUQ7QUFDRixHQVZEOztBQVlBOzs7QUFHQVYsS0FBRyw0Q0FBSCxFQUFpRCxZQUFZO0FBQzNELFVBQU1kLG1CQUFtQjhDLHlCQUFuQixDQUE2QyxJQUE3QyxFQUFtRCxFQUFDN0IsTUFBTSxVQUFQLEVBQW5ELENBQU47QUFDQVYsb0JBQU1rQixNQUFOLENBQWFDLHFCQUFiLENBQW1DeEIsV0FBV3lCLE9BQTlDLEVBQXVEO0FBQ3JEQyxXQUFNLEdBQUU5QixrQkFBbUIseUNBRDBCO0FBRXJEK0IsY0FBUSxLQUY2QztBQUdyREUsZUFBUztBQUNQLHNCQUFjOUI7QUFEUCxPQUg0QztBQU1yRCtCLFlBQU0sSUFOK0M7QUFPckRPLFlBQU07QUFDSnRCLGNBQU07QUFERjtBQVArQyxLQUF2RDtBQVdELEdBYkQ7O0FBZUE7OztBQUdBSCxLQUFHLG1FQUFILEVBQXdFLFlBQVk7QUFDbEZkLHlCQUFxQixJQUFJVSw2QkFBSixDQUE4QlIsVUFBOUIsRUFBMEMsT0FBMUMsQ0FBckI7QUFDQSxRQUFJO0FBQ0YsWUFBTUYsbUJBQW1COEMseUJBQW5CLENBQTZDLElBQTdDLEVBQW1ELEVBQUM3QixNQUFNLFVBQVAsRUFBbkQsQ0FBTjtBQUNELEtBRkQsQ0FFRSxPQUFPZ0IsS0FBUCxFQUFjO0FBQ2RBLFlBQU1DLE9BQU4sQ0FBY1gsTUFBZCxDQUFxQkMsS0FBckIsQ0FDRSxnSEFDQSw4RkFGRjtBQUlEO0FBQ0YsR0FWRDtBQVlELENBOU9EIiwiZmlsZSI6InByb3Zpc2lvbmluZ1Byb2ZpbGUuY2xpZW50LnNwZWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBIdHRwQ2xpZW50IGZyb20gJy4uL2h0dHBDbGllbnQnO1xuaW1wb3J0IHNpbm9uIGZyb20gJ3Npbm9uJztcbmltcG9ydCBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50IGZyb20gJy4vcHJvdmlzaW9uaW5nUHJvZmlsZS5jbGllbnQnO1xuXG5jb25zdCBwcm92aXNpb25pbmdBcGlVcmwgPSAnaHR0cHM6Ly9tdC1wcm92aXNpb25pbmctYXBpLXYxLmFnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuXG4vKipcbiAqIEB0ZXN0IHtQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50fVxuICovXG5kZXNjcmliZSgnUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCcsICgpID0+IHtcblxuICBsZXQgcHJvdmlzaW9uaW5nQ2xpZW50O1xuICBjb25zdCB0b2tlbiA9ICdoZWFkZXIucGF5bG9hZC5zaWduJztcbiAgbGV0IGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgpO1xuICBsZXQgc2FuZGJveDtcbiAgbGV0IHJlcXVlc3RTdHViO1xuXG4gIGJlZm9yZSgoKSA9PiB7XG4gICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgcHJvdmlzaW9uaW5nQ2xpZW50ID0gbmV3IFByb3Zpc2lvbmluZ1Byb2ZpbGVDbGllbnQoaHR0cENsaWVudCwgdG9rZW4pO1xuICAgIHJlcXVlc3RTdHViID0gc2FuZGJveC5zdHViKGh0dHBDbGllbnQsICdyZXF1ZXN0Jyk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7UHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCNnZXRQcm92aXNpb25pbmdQcm9maWxlc31cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgcHJvdmlzaW9uaW5nIHByb2ZpbGVzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBfaWQ6ICdpZCcsXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICB2ZXJzaW9uOiA0LFxuICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgIH1dO1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZXMoNSwgJ2FjdGl2ZScpO1xuICAgIHByb2ZpbGVzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3Zpc2lvbmluZy1wcm9maWxlc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcXM6IHtcbiAgICAgICAgdmVyc2lvbjogNSxcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZXN9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBwcm92aXNpb25pbmcgcHJvZmlsZXMgZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIHByb3Zpc2lvbmluZ0NsaWVudCA9IG5ldyBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZXMoNSwgJ2FjdGl2ZScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZXRQcm92aXNpb25pbmdQcm9maWxlcyBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50I2dldFByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHByb3Zpc2lvbmluZyBwcm9maWxlIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IHtcbiAgICAgIF9pZDogJ2lkJyxcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIHZlcnNpb246IDQsXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnXG4gICAgfTtcbiAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnKTtcbiAgICBwcm9maWxlLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7cHJvdmlzaW9uaW5nQXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3Zpc2lvbmluZy1wcm9maWxlcy9pZGAsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNnZXRQcm92aXNpb25pbmdQcm9maWxlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmV0cmlldmUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIHByb3Zpc2lvbmluZ0NsaWVudCA9IG5ldyBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgZ2V0UHJvdmlzaW9uaW5nUHJvZmlsZSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50I2NyZWF0ZVByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGNyZWF0ZSBwcm92aXNpb25pbmcgcHJvZmlsZSB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IHtcbiAgICAgIGlkOiAnaWQnXG4gICAgfTtcbiAgICBsZXQgcHJvZmlsZSA9IHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIHZlcnNpb246IDRcbiAgICB9O1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgaWQgPSBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuY3JlYXRlUHJvdmlzaW9uaW5nUHJvZmlsZShwcm9maWxlKTtcbiAgICBpZC5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9wcm92aXNpb25pbmctcHJvZmlsZXNgLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBwcm9maWxlLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCNjcmVhdGVQcm92aXNpb25pbmdQcm9maWxlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgY3JlYXRlIHByb3Zpc2lvbmluZyBwcm9maWxlIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIHByb3Zpc2lvbmluZ0NsaWVudCA9IG5ldyBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQuY3JlYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSh7fSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGNyZWF0ZVByb3Zpc2lvbmluZ1Byb2ZpbGUgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7UHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCN1cGxvYWRQcm92aXNpb25pbmdQcm9maWxlRmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgdXBsb2FkIGZpbGUgdG8gYSBwcm92aXNpb25pbmcgcHJvZmlsZSB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBmaWxlID0gQnVmZmVyLmZyb20oJ3Rlc3QnLCAndXRmOCcpO1xuICAgIGF3YWl0IHByb3Zpc2lvbmluZ0NsaWVudC51cGxvYWRQcm92aXNpb25pbmdQcm9maWxlRmlsZSgnaWQnLCAnc2VydmVycy5kYXQnLCBmaWxlKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtwcm92aXNpb25pbmdBcGlVcmx9L3VzZXJzL2N1cnJlbnQvcHJvdmlzaW9uaW5nLXByb2ZpbGVzL2lkL3NlcnZlcnMuZGF0YCxcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBmb3JtRGF0YToge1xuICAgICAgICBmaWxlXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCN1cGxvYWRQcm92aXNpb25pbmdQcm9maWxlRmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVwbG9hZCBwcm92aXNpb25pbmcgcHJvZmlsZSBmaWxlIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIHByb3Zpc2lvbmluZ0NsaWVudCA9IG5ldyBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQudXBsb2FkUHJvdmlzaW9uaW5nUHJvZmlsZUZpbGUoJ2lkJywgJ3NlcnZlcnMuZGF0Jywge30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSB1cGxvYWRQcm92aXNpb25pbmdQcm9maWxlRmlsZSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MnICtcbiAgICAgICAgJyB0b2tlbi4gUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50I2RlbGV0ZVByb3Zpc2lvbmluZ1Byb2ZpbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGRlbGV0ZSBwcm92aXNpb25pbmcgcHJvZmlsZSB2aWEgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHByb3Zpc2lvbmluZ0NsaWVudC5kZWxldGVQcm92aXNpb25pbmdQcm9maWxlKCdpZCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9wcm92aXNpb25pbmctcHJvZmlsZXMvaWRgLFxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZGVsZXRlUHJvdmlzaW9uaW5nUHJvZmlsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IGRlbGV0ZSBwcm92aXNpb25pbmcgcHJvZmlsZSB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBwcm92aXNpb25pbmdDbGllbnQgPSBuZXcgUHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvdmlzaW9uaW5nQ2xpZW50LmRlbGV0ZVByb3Zpc2lvbmluZ1Byb2ZpbGUoJ2lkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGRlbGV0ZVByb3Zpc2lvbmluZ1Byb2ZpbGUgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7UHJvdmlzaW9uaW5nUHJvZmlsZUNsaWVudCN1cGRhdGVQcm92aXNpb25pbmdQcm9maWxlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCB1cGRhdGUgcHJvdmlzaW9uaW5nIHByb2ZpbGUgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQudXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnLCB7bmFtZTogJ25ldyBuYW1lJ30pO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke3Byb3Zpc2lvbmluZ0FwaVVybH0vdXNlcnMvY3VycmVudC9wcm92aXNpb25pbmctcHJvZmlsZXMvaWRgLFxuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWU6ICduZXcgbmFtZSdcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhdHJhZGVyQWNjb3VudENsaWVudCN1cGRhdGVQcm92aXNpb25pbmdQcm9maWxlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgdXBkYXRlIHByb3Zpc2lvbmluZyBwcm9maWxlIHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIHByb3Zpc2lvbmluZ0NsaWVudCA9IG5ldyBQcm92aXNpb25pbmdQcm9maWxlQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aXNpb25pbmdDbGllbnQudXBkYXRlUHJvdmlzaW9uaW5nUHJvZmlsZSgnaWQnLCB7bmFtZTogJ25ldyBuYW1lJ30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSB1cGRhdGVQcm92aXNpb25pbmdQcm9maWxlIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxufSk7XG4iXX0=