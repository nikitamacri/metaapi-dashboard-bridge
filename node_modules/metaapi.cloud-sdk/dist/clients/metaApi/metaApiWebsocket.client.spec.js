'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _metaApiWebsocket = require('./metaApiWebsocket.client');

var _metaApiWebsocket2 = _interopRequireDefault(_metaApiWebsocket);

var _socket = require('socket.io');

var _socket2 = _interopRequireDefault(_socket);

var _notConnectedError = require('./notConnectedError');

var _notConnectedError2 = _interopRequireDefault(_notConnectedError);

var _errorHandler = require('../errorHandler');

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const metaapiApiUrl = 'https://mt-client-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {MetaApiWebsocketClient}
 */
// eslint-disable-next-line max-statements
describe('MetaApiWebsocketClient', () => {

  let io;
  let server;
  let client;
  let sandbox;
  let httpClient = new _httpClient2.default();
  const emptyHash = 'd41d8cd98f00b204e9800998ecf8427e';
  const synchronizationThrottler = {
    activeSynchronizationIds: ['synchronizationId'],
    onDisconnect: () => {},
    updateSynchronizationId: () => {}
  };
  let accountInformation = {
    broker: 'True ECN Trading Ltd',
    currency: 'USD',
    server: 'ICMarketsSC-Demo',
    balance: 7319.9,
    equity: 7306.649913200001,
    margin: 184.1,
    freeMargin: 7120.22,
    leverage: 100,
    marginLevel: 3967.58283542
  };

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(async () => {
    client = new _metaApiWebsocket2.default(httpClient, 'token', { application: 'application',
      domain: 'project-stock.agiliumlabs.cloud', requestTimeout: 1.5, useSharedClientApi: true,
      retryOpts: { retries: 3, minDelayInSeconds: 0.1, maxDelayInSeconds: 0.5 } });
    client.url = 'http://localhost:6784';
    io = new _socket2.default(6784, { path: '/ws', pingTimeout: 1000000 });
    io.on('connect', socket => {
      server = socket;
      if (socket.request._query['auth-token'] !== 'token') {
        socket.emit({ error: 'UnauthorizedError', message: 'Authorization token invalid' });
        socket.close();
      }
    });
    client._socketInstancesByAccounts = { accountId: 0 };
    await client.connect();
    sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => []);
  });

  afterEach(async () => {
    sandbox.restore();
    let resolve;
    let promise = new _promise2.default(res => resolve = res);
    client.close();
    io.close(() => resolve());
    await promise;
  });

  /**
   * @test {MetaApiWebsocketClient#_tryReconnect}
   */
  it('should change client id on reconnect', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
    client.close();
    let clientId;
    let connectAmount = 0;
    io.on('connect', socket => {
      connectAmount++;
      socket.request.headers['client-id'].should.equal(socket.request._query.clientId);
      socket.request.headers['client-id'].should.not.equal(clientId);
      socket.request._query.clientId.should.not.equal(clientId);
      clientId = socket.request._query.clientId;
      socket.disconnect();
    });
    await client.connect();
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1500);
    await new _promise2.default(res => setTimeout(res, 50));
    connectAmount.should.be.aboveOrEqual(2);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#_getServerUrl}
   */
  it('should connect to dedicated server', async () => {
    let positions = [{
      id: '46214692',
      type: 'POSITION_TYPE_BUY',
      symbol: 'GBPUSD',
      magic: 1000,
      time: new Date('2020-04-15T02:45:06.521Z'),
      updateTime: new Date('2020-04-15T02:45:06.521Z'),
      openPrice: 1.26101,
      currentPrice: 1.24883,
      currentTickValue: 1,
      volume: 0.07,
      swap: 0,
      profit: -85.25999999999966,
      commission: -0.25,
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      stopLoss: 1.17721,
      unrealizedProfit: -85.25999999999901,
      realizedProfit: -6.536993168992922e-13
    }];
    let resolve;
    let promise = new _promise2.default(res => resolve = res);
    client.close();
    io.close(() => resolve());
    await promise;
    io = new _socket2.default(6785, { path: '/ws', pingTimeout: 1000000 });
    sandbox.stub(httpClient, 'request').resolves({ url: 'http://localhost:6785' });
    client = new _metaApiWebsocket2.default(httpClient, 'token', { application: 'application',
      domain: 'project-stock.agiliumlabs.cloud', requestTimeout: 1.5, useSharedClientApi: false,
      retryOpts: { retries: 3, minDelayInSeconds: 0.1, maxDelayInSeconds: 0.5 } });
    io.on('connect', socket => {
      server = socket;
      if (socket.request._query['auth-token'] !== 'token') {
        socket.emit({ error: 'UnauthorizedError', message: 'Authorization token invalid' });
        socket.close();
      }
      server.on('request', data => {
        if (data.type === 'getPositions' && data.accountId === 'accountId' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, positions });
        }
      });
    });
    let actual = await client.getPositions('accountId');
    actual.should.match(positions);
  });

  /**
   * @test {MetaApiWebsocketClient#getAccountInformation}
   */
  it('should retrieve MetaTrader account information from API', async () => {
    server.on('request', data => {
      if (data.type === 'getAccountInformation' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId,
          accountInformation
        });
      }
    });
    let actual = await client.getAccountInformation('accountId');
    actual.should.match(accountInformation);
  });

  /**
   * @test {MetaApiWebsocketClient#getPositions}
   */
  it('should retrieve MetaTrader positions from API', async () => {
    let positions = [{
      id: '46214692',
      type: 'POSITION_TYPE_BUY',
      symbol: 'GBPUSD',
      magic: 1000,
      time: new Date('2020-04-15T02:45:06.521Z'),
      updateTime: new Date('2020-04-15T02:45:06.521Z'),
      openPrice: 1.26101,
      currentPrice: 1.24883,
      currentTickValue: 1,
      volume: 0.07,
      swap: 0,
      profit: -85.25999999999966,
      commission: -0.25,
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      stopLoss: 1.17721,
      unrealizedProfit: -85.25999999999901,
      realizedProfit: -6.536993168992922e-13
    }];
    server.on('request', data => {
      if (data.type === 'getPositions' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, positions });
      }
    });
    let actual = await client.getPositions('accountId');
    actual.should.match(positions);
  });

  /**
   * @test {MetaApiWebsocketClient#getPosition}
   */
  it('should retrieve MetaTrader position from API by id', async () => {
    let position = {
      id: '46214692',
      type: 'POSITION_TYPE_BUY',
      symbol: 'GBPUSD',
      magic: 1000,
      time: new Date('2020-04-15T02:45:06.521Z'),
      updateTime: new Date('2020-04-15T02:45:06.521Z'),
      openPrice: 1.26101,
      currentPrice: 1.24883,
      currentTickValue: 1,
      volume: 0.07,
      swap: 0,
      profit: -85.25999999999966,
      commission: -0.25,
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      stopLoss: 1.17721,
      unrealizedProfit: -85.25999999999901,
      realizedProfit: -6.536993168992922e-13
    };
    server.on('request', data => {
      if (data.type === 'getPosition' && data.accountId === 'accountId' && data.positionId === '46214692' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, position });
      }
    });
    let actual = await client.getPosition('accountId', '46214692');
    actual.should.match(position);
  });

  /**
   * @test {MetaApiWebsocketClient#getOrders}
   */
  it('should retrieve MetaTrader orders from API', async () => {
    let orders = [{
      id: '46871284',
      type: 'ORDER_TYPE_BUY_LIMIT',
      state: 'ORDER_STATE_PLACED',
      symbol: 'AUDNZD',
      magic: 123456,
      platform: 'mt5',
      time: new Date('2020-04-20T08:38:58.270Z'),
      openPrice: 1.03,
      currentPrice: 1.05206,
      volume: 0.01,
      currentVolume: 0.01,
      comment: 'COMMENT2'
    }];
    server.on('request', data => {
      if (data.type === 'getOrders' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, orders });
      }
    });
    let actual = await client.getOrders('accountId');
    actual.should.match(orders);
  });

  /**
   * @test {MetaApiWebsocketClient#getOrder}
   */
  it('should retrieve MetaTrader order from API by id', async () => {
    let order = {
      id: '46871284',
      type: 'ORDER_TYPE_BUY_LIMIT',
      state: 'ORDER_STATE_PLACED',
      symbol: 'AUDNZD',
      magic: 123456,
      platform: 'mt5',
      time: new Date('2020-04-20T08:38:58.270Z'),
      openPrice: 1.03,
      currentPrice: 1.05206,
      volume: 0.01,
      currentVolume: 0.01,
      comment: 'COMMENT2'
    };
    server.on('request', data => {
      if (data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
      }
    });
    let actual = await client.getOrder('accountId', '46871284');
    actual.should.match(order);
  });

  /**
   * @test {MetaApiWebsocketClient#getHistoryOrdersByTicket}
   */
  it('should retrieve MetaTrader history orders from API by ticket', async () => {
    let historyOrders = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      currentPrice: 1.261,
      currentVolume: 0,
      doneTime: new Date('2020-04-15T02:45:06.521Z'),
      id: '46214692',
      magic: 1000,
      platform: 'mt5',
      positionId: '46214692',
      state: 'ORDER_STATE_FILLED',
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.260Z'),
      type: 'ORDER_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getHistoryOrdersByTicket' && data.accountId === 'accountId' && data.ticket === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, historyOrders,
          synchronizing: false
        });
      }
    });
    let actual = await client.getHistoryOrdersByTicket('accountId', '46214692');
    actual.should.match({ historyOrders, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getHistoryOrdersByPosition}
   */
  it('should retrieve MetaTrader history orders from API by position', async () => {
    let historyOrders = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      currentPrice: 1.261,
      currentVolume: 0,
      doneTime: new Date('2020-04-15T02:45:06.521Z'),
      id: '46214692',
      magic: 1000,
      platform: 'mt5',
      positionId: '46214692',
      state: 'ORDER_STATE_FILLED',
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.260Z'),
      type: 'ORDER_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getHistoryOrdersByPosition' && data.accountId === 'accountId' && data.positionId === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, historyOrders,
          synchronizing: false
        });
      }
    });
    let actual = await client.getHistoryOrdersByPosition('accountId', '46214692');
    actual.should.match({ historyOrders, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getHistoryOrdersByTimeRange}
   */
  it('should retrieve MetaTrader history orders from API by time range', async () => {
    let historyOrders = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      currentPrice: 1.261,
      currentVolume: 0,
      doneTime: new Date('2020-04-15T02:45:06.521Z'),
      id: '46214692',
      magic: 1000,
      platform: 'mt5',
      positionId: '46214692',
      state: 'ORDER_STATE_FILLED',
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.260Z'),
      type: 'ORDER_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getHistoryOrdersByTimeRange' && data.accountId === 'accountId' && data.startTime === '2020-04-15T02:45:00.000Z' && data.endTime === '2020-04-15T02:46:00.000Z' && data.offset === 1 && data.limit === 100 && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, historyOrders,
          synchronizing: false
        });
      }
    });
    let actual = await client.getHistoryOrdersByTimeRange('accountId', new Date('2020-04-15T02:45:00.000Z'), new Date('2020-04-15T02:46:00.000Z'), 1, 100);
    actual.should.match({ historyOrders, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getDealsByTicket}
   */
  it('should retrieve MetaTrader deals from API by ticket', async () => {
    let deals = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      commission: -0.25,
      entryType: 'DEAL_ENTRY_IN',
      id: '33230099',
      magic: 1000,
      platform: 'mt5',
      orderId: '46214692',
      positionId: '46214692',
      price: 1.26101,
      profit: 0,
      swap: 0,
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.521Z'),
      type: 'DEAL_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getDealsByTicket' && data.accountId === 'accountId' && data.ticket === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, deals,
          synchronizing: false
        });
      }
    });
    let actual = await client.getDealsByTicket('accountId', '46214692');
    actual.should.match({ deals, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getDealsByPosition}
   */
  it('should retrieve MetaTrader deals from API by position', async () => {
    let deals = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      commission: -0.25,
      entryType: 'DEAL_ENTRY_IN',
      id: '33230099',
      magic: 1000,
      platform: 'mt5',
      orderId: '46214692',
      positionId: '46214692',
      price: 1.26101,
      profit: 0,
      swap: 0,
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.521Z'),
      type: 'DEAL_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getDealsByPosition' && data.accountId === 'accountId' && data.positionId === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, deals,
          synchronizing: false
        });
      }
    });
    let actual = await client.getDealsByPosition('accountId', '46214692');
    actual.should.match({ deals, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getDealsByTimeRange}
   */
  it('should retrieve MetaTrader deals from API by time range', async () => {
    let deals = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      commission: -0.25,
      entryType: 'DEAL_ENTRY_IN',
      id: '33230099',
      magic: 1000,
      platform: 'mt5',
      orderId: '46214692',
      positionId: '46214692',
      price: 1.26101,
      profit: 0,
      swap: 0,
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.521Z'),
      type: 'DEAL_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getDealsByTimeRange' && data.accountId === 'accountId' && data.startTime === '2020-04-15T02:45:00.000Z' && data.endTime === '2020-04-15T02:46:00.000Z' && data.offset === 1 && data.limit === 100 && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, deals,
          synchronizing: false
        });
      }
    });
    let actual = await client.getDealsByTimeRange('accountId', new Date('2020-04-15T02:45:00.000Z'), new Date('2020-04-15T02:46:00.000Z'), 1, 100);
    actual.should.match({ deals, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#removeHistory}
   */
  it('should remove history from API', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'removeHistory' && data.accountId === 'accountId' && data.application === 'app') {
        requestReceived = true;
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.removeHistory('accountId', 'app');
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#removeApplication}
   */
  it('should remove application from API', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'removeApplication' && data.accountId === 'accountId' && data.application === 'application') {
        requestReceived = true;
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.removeApplication('accountId');
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#trade}
   */
  it('should execute a trade via new API version', async () => {
    let trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    let response = {
      numericCode: 10009,
      stringCode: 'TRADE_RETCODE_DONE',
      message: 'Request completed',
      orderId: '46870472'
    };
    server.on('request', data => {
      data.trade.should.match(trade);
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
    });
    let actual = await client.trade('accountId', trade);
    actual.should.match(response);
  });

  /**
   * @test {MetaApiWebsocketClient#trade}
   */
  it('should execute a trade via API and receive trade error from old API version', async () => {
    let trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    let response = {
      error: 10006,
      description: 'TRADE_RETCODE_REJECT',
      message: 'Request rejected',
      orderId: '46870472'
    };
    server.on('request', data => {
      data.trade.should.match(trade);
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
    });
    try {
      await client.trade('accountId', trade);
      _should2.default.fail('Trade error expected');
    } catch (err) {
      err.message.should.equal('Request rejected');
      err.name.should.equal('TradeError');
      err.stringCode.should.equal('TRADE_RETCODE_REJECT');
      err.numericCode.should.equal(10006);
    }
  });

  /**
   * @test {MetaApiWebsocketClient#subscribe}
   */
  it('should connect to MetaTrader terminal', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'subscribe' && data.accountId === 'accountId' && data.application === 'application' && data.instanceIndex === 1) {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        requestReceived = true;
      }
    });
    await client.subscribe('accountId', 1);
    await new _promise2.default(res => setTimeout(res, 50));
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#subscribe}
   */
  it('should create new instance when account limit is reached', async () => {
    _sinon2.default.assert.match(client.socketInstances.length, 1);
    for (let i = 0; i < 100; i++) {
      client._socketInstancesByAccounts['accountId' + i] = 0;
    }

    io.removeAllListeners('connect');
    io.on('connect', socket => {
      socket.on('request', data => {
        if (data.type === 'subscribe' && data.accountId === 'accountId101' && data.application === 'application' && data.instanceIndex === 1) {
          socket.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
    });
    await client.subscribe('accountId101', 1);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.match(client.socketInstances.length, 2);
  });

  /**
   * @test {MetaApiWebsocketClient#subscribe}
   */
  it('should return error if connect to MetaTrader terminal failed', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'subscribe' && data.accountId === 'accountId' && data.application === 'application') {
        requestReceived = true;
      }
      server.emit('processingError', {
        id: 1, error: 'NotAuthenticatedError', message: 'Error message',
        requestId: data.requestId
      });
    });
    let success = true;
    try {
      await client.subscribe('accountId');
      success = false;
    } catch (err) {
      err.name.should.equal('NotConnectedError');
    }
    success.should.be.true();
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#reconnect}
   */
  it('should reconnect to MetaTrader terminal', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'reconnect' && data.accountId === 'accountId' && data.application === 'application') {
        requestReceived = true;
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.reconnect('accountId');
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#getSymbols}
   */
  it('should retrieve symbols from API', async () => {
    let symbols = ['EURUSD'];
    server.on('request', data => {
      if (data.type === 'getSymbols' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, symbols
        });
      }
    });
    let actual = await client.getSymbols('accountId');
    actual.should.match(symbols);
  });

  /**
   * @test {MetaApiWebsocketClient#getSymbolSpecification}
   */
  it('should retrieve symbol specification from API', async () => {
    let specification = {
      symbol: 'AUDNZD',
      tickSize: 0.00001,
      minVolume: 0.01,
      maxVolume: 100,
      volumeStep: 0.01
    };
    server.on('request', data => {
      if (data.type === 'getSymbolSpecification' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId,
          specification
        });
      }
    });
    let actual = await client.getSymbolSpecification('accountId', 'AUDNZD');
    actual.should.match(specification);
  });

  /**
   * @test {MetaApiWebsocketClient#getSymbolPrice}
   */
  it('should retrieve symbol price from API', async () => {
    let price = {
      symbol: 'AUDNZD',
      bid: 1.05297,
      ask: 1.05309,
      profitTickValue: 0.59731,
      lossTickValue: 0.59736
    };
    server.on('request', data => {
      if (data.type === 'getSymbolPrice' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, price });
      }
    });
    let actual = await client.getSymbolPrice('accountId', 'AUDNZD');
    actual.should.match(price);
  });

  /**
   * @test {MetaApiWebsocketClient#getCandle}
   */
  it('should retrieve candle from API', async () => {
    let candle = {
      symbol: 'AUDNZD',
      timeframe: '15m',
      time: new Date('2020-04-07T03:45:00.000Z'),
      brokerTime: '2020-04-07 06:45:00.000',
      open: 1.03297,
      high: 1.06309,
      low: 1.02705,
      close: 1.043,
      tickVolume: 1435,
      spread: 17,
      volume: 345
    };
    server.on('request', data => {
      if (data.type === 'getCandle' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC' && data.timeframe === '15m') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, candle });
      }
    });
    let actual = await client.getCandle('accountId', 'AUDNZD', '15m');
    actual.should.match(candle);
  });

  /**
   * @test {MetaApiWebsocketClient#getTick}
   */
  it('should retrieve latest tick from API', async () => {
    let tick = {
      symbol: 'AUDNZD',
      time: new Date('2020-04-07T03:45:00.000Z'),
      brokerTime: '2020-04-07 06:45:00.000',
      bid: 1.05297,
      ask: 1.05309,
      last: 0.5298,
      volume: 0.13,
      side: 'buy'
    };
    server.on('request', data => {
      if (data.type === 'getTick' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, tick });
      }
    });
    let actual = await client.getTick('accountId', 'AUDNZD');
    actual.should.match(tick);
  });

  /**
   * @test {MetaApiWebsocketClient#getBook}
   */
  it('should retrieve latest order book from API', async () => {
    let book = {
      symbol: 'AUDNZD',
      time: new Date('2020-04-07T03:45:00.000Z'),
      brokerTime: '2020-04-07 06:45:00.000',
      book: [{
        type: 'BOOK_TYPE_SELL',
        price: 1.05309,
        volume: 5.67
      }, {
        type: 'BOOK_TYPE_BUY',
        price: 1.05297,
        volume: 3.45
      }]
    };
    server.on('request', data => {
      if (data.type === 'getBook' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, book });
      }
    });
    let actual = await client.getBook('accountId', 'AUDNZD');
    actual.should.match(book);
  });

  /**
   * @test {MetaApiWebsocketClient#sendUptime}
   */
  it('should sent uptime stats to the server', async () => {
    server.on('request', data => {
      if (data.type === 'saveUptime' && data.accountId === 'accountId' && (0, _stringify2.default)(data.uptime) === (0, _stringify2.default)({ '1h': 100 }) && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.saveUptime('accountId', { '1h': 100 });
  });

  /**
   * @test {MetaApiWebsocketClient#unsubscribe}
   */
  it('should unsubscribe from account data', async () => {
    let requestReceived = false;

    let response = { type: 'response', accountId: 'accountId' };
    server.on('request', data => {
      if (data.type === 'unsubscribe' && data.accountId === 'accountId') {
        requestReceived = true;
        server.emit('response', (0, _assign2.default)({ requestId: data.requestId }, response));
      }
    });
    await client.unsubscribe('accountId');
    _sinon2.default.assert.match(requestReceived, true);
    client.socketInstancesByAccounts.should.not.have.property('accountId');
  });

  /**
   * @test {MetaApiWebsocketClient#unsubscribe}
   */
  it('should ignore not found exception on unsubscribe', async () => {
    server.on('request', data => {
      server.emit('processingError', {
        id: 1, error: 'ValidationError', message: 'Validation failed',
        details: [{ parameter: 'volume', message: 'Required value.' }], requestId: data.requestId
      });
    });
    try {
      await client.unsubscribe('accountId');
      throw new Error('ValidationError extected');
    } catch (err) {
      err.name.should.equal('ValidationError');
      err.details.should.match([{
        parameter: 'volume',
        message: 'Required value.'
      }]);
    }
    server.removeAllListeners('request');
    server.on('request', data => {
      server.emit('processingError', {
        id: 1, error: 'NotFoundError', message: 'Account not found', requestId: data.requestId
      });
    });
    await client.unsubscribe('accountId');
  });

  describe('error handling', () => {

    /**
     * @test {MetaApiWebsocketClient#trade}
     */
    it('should handle ValidationError', async () => {
      let trade = {
        actionType: 'ORDER_TYPE_SELL',
        symbol: 'AUDNZD'
      };
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'ValidationError', message: 'Validation failed',
          details: [{ parameter: 'volume', message: 'Required value.' }], requestId: data.requestId
        });
      });
      try {
        await client.trade('accountId', trade);
        throw new Error('ValidationError extected');
      } catch (err) {
        err.name.should.equal('ValidationError');
        err.details.should.match([{
          parameter: 'volume',
          message: 'Required value.'
        }]);
      }
    });

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle NotFoundError', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'NotFoundError', message: 'Position id 1234 not found',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('NotFoundError extected');
      } catch (err) {
        err.name.should.equal('NotFoundError');
      }
    });

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle NotSynchronizedError', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'NotSynchronizedError', message: 'Error message',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('NotSynchronizedError extected');
      } catch (err) {
        err.name.should.equal('NotSynchronizedError');
      }
    }).timeout(8000);

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle NotConnectedError', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'NotAuthenticatedError', message: 'Error message',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('NotConnectedError extected');
      } catch (err) {
        err.name.should.equal('NotConnectedError');
      }
    });

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle other errors', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'Error', message: 'Error message',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('InternalError extected');
      } catch (err) {
        err.name.should.equal('InternalError');
      }
    }).timeout(8000);
  });

  describe('connection status synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    it('should process authenticated synchronization event', async () => {
      let listener = {
        onConnected: () => {}
      };
      sandbox.stub(listener, 'onConnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onConnected, '1:ps-mpa-1', 2);
    });

    it('should process authenticated synchronization event with session id', async () => {
      let listener = {
        onConnected: () => {}
      };
      sandbox.stub(listener, 'onConnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 2, replicas: 4, sessionId: 'wrong' });
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2, sessionId: client._sessionId });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onConnected, 1);
      _sinon2.default.assert.calledWith(listener.onConnected, '1:ps-mpa-1', 2);
    });

    it('should process broker connection status event', async () => {
      let listener = {
        onConnected: () => {},
        onBrokerConnectionStatusChanged: () => {}
      };
      sandbox.stub(listener, 'onBrokerConnectionStatusChanged').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onBrokerConnectionStatusChanged, '1:ps-mpa-1', true);
    });

    it('should call an onDisconnect if there was no signal for a long time', async () => {
      const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {},
        onBrokerConnectionStatusChanged: () => {}
      };
      sandbox.stub(listener, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(10000);
      await server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(55000);
      _sinon2.default.assert.notCalled(listener.onDisconnected);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(10000);
      _sinon2.default.assert.notCalled(listener.onDisconnected);
      await clock.tickAsync(55000);
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onDisconnected, '1:ps-mpa-1');
      clock.restore();
    });

    it('should close stream on timeout if another stream exists', async () => {
      const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {},
        onStreamClosed: () => {},
        onBrokerConnectionStatusChanged: () => {}
      };
      const onTimeoutStub = sandbox.stub(client._subscriptionManager, 'onTimeout').resolves();
      const onStreamClosedStub = sandbox.stub(listener, 'onStreamClosed').resolves();
      const onDisconnectedStub = sandbox.stub(listener, 'onDisconnected').resolves();
      sandbox.stub(client._subscriptionManager, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-2',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(55000);
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(55000);
      _sinon2.default.assert.calledWith(onStreamClosedStub, '1:ps-mpa-1');
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      _sinon2.default.assert.notCalled(onTimeoutStub);
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      _sinon2.default.assert.calledWith(onDisconnectedStub, '1:ps-mpa-2');
      _sinon2.default.assert.notCalled(client._subscriptionManager.onDisconnected);
      _sinon2.default.assert.calledWith(onTimeoutStub, 'accountId', 1);
      clock.restore();
    });

    it('should process server-side health status event', async () => {
      let listener = {
        onConnected: () => {},
        onBrokerConnectionStatusChanged: () => {},
        onHealthStatus: () => {}
      };
      sandbox.stub(listener, 'onHealthStatus').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        healthStatus: { restApiHealthy: true }, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onHealthStatus, '1:ps-mpa-1', { restApiHealthy: true });
    });

    it('should process disconnected synchronization event', async () => {
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {}
      };
      sandbox.stub(listener, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'disconnected', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onDisconnected, '1:ps-mpa-1');
    });

    it('should close the stream if host name disconnected and another stream exists', async () => {
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {},
        onStreamClosed: () => {}
      };
      sandbox.stub(listener, 'onDisconnected').resolves();
      sandbox.stub(listener, 'onStreamClosed').resolves();
      const onDisconnectedStub = sandbox.stub(client._subscriptionManager, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-2',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'disconnected', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onStreamClosed, '1:ps-mpa-1');
      _sinon2.default.assert.notCalled(listener.onDisconnected);
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      server.emit('synchronization', { type: 'disconnected', accountId: 'accountId', host: 'ps-mpa-2',
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledOnce(listener.onDisconnected);
      _sinon2.default.assert.calledWith(onDisconnectedStub, 'accountId', 1);
    });
  });

  describe('terminal state synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    it('should only accept packets with own synchronization ids', async () => {
      let listener = {
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onAccountInformationUpdated').resolves();
      client.addSynchronizationListener('accountId', listener);
      sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => ['synchronizationId']);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation: {}, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onAccountInformationUpdated, 1);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation: {}, instanceIndex: 1, synchronizationId: 'wrong' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onAccountInformationUpdated, 1);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation: {}, instanceIndex: 1, synchronizationId: 'synchronizationId' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onAccountInformationUpdated, 2);
    });

    /**
     * @test {MetaApiWebsocketClient#synchronize}
     */
    it('should synchronize with MetaTrader terminal', async () => {
      let requestReceived = false;
      // eslint-disable-next-line complexity
      server.on('request', data => {
        if (data.type === 'synchronize' && data.accountId === 'accountId' && data.host === 'ps-mpa-1' && data.startingHistoryOrderTime === '2020-01-01T00:00:00.000Z' && data.startingDealTime === '2020-01-02T00:00:00.000Z' && data.requestId === 'synchronizationId' && data.application === 'application' && data.instanceIndex === 1) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.synchronize('accountId', 1, 'ps-mpa-1', 'synchronizationId', new Date('2020-01-01T00:00:00.000Z'), new Date('2020-01-02T00:00:00.000Z'), emptyHash, emptyHash, emptyHash);
      requestReceived.should.be.true();
    });

    it('should process synchronization started event', async () => {
      client._socketInstances[0].synchronizationThrottler = synchronizationThrottler;
      let listener = {
        onSynchronizationStarted: () => {},
        onPositionsSynchronized: () => {},
        onPendingOrdersSynchronized: () => {},
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onSynchronizationStarted').resolves();
      sandbox.stub(listener, 'onPositionsSynchronized').resolves();
      sandbox.stub(listener, 'onPendingOrdersSynchronized').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId', instanceIndex: 1,
        synchronizationId: 'synchronizationId', host: 'ps-mpa-1' });
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation, instanceIndex: 1, host: 'ps-mpa-1', synchronizationId: 'synchronizationId' });
      await new _promise2.default(res => setTimeout(res, 100));
      _sinon2.default.assert.calledWith(listener.onSynchronizationStarted, '1:ps-mpa-1', true, true, true);
      _sinon2.default.assert.notCalled(listener.onPositionsSynchronized);
      _sinon2.default.assert.notCalled(listener.onPendingOrdersSynchronized);
    });

    it('should process synchronization started event without updating positions', async () => {
      client._socketInstances[0].synchronizationThrottler = synchronizationThrottler;
      let listener = {
        onSynchronizationStarted: () => {},
        onPositionsSynchronized: () => {},
        onPendingOrdersSynchronized: () => {},
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onSynchronizationStarted').resolves();
      sandbox.stub(listener, 'onPositionsSynchronized').resolves();
      sandbox.stub(listener, 'onPendingOrdersSynchronized').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId', instanceIndex: 1,
        synchronizationId: 'synchronizationId', host: 'ps-mpa-1', positionsUpdated: false,
        ordersUpdated: true });
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation, instanceIndex: 1, host: 'ps-mpa-1', synchronizationId: 'synchronizationId' });
      await new _promise2.default(res => setTimeout(res, 100));
      _sinon2.default.assert.calledWith(listener.onSynchronizationStarted, '1:ps-mpa-1', true, false, true);
      _sinon2.default.assert.calledWith(listener.onPositionsSynchronized, '1:ps-mpa-1', 'synchronizationId');
      _sinon2.default.assert.notCalled(listener.onPendingOrdersSynchronized);
    });

    it('should process synchronization started event without updating orders', async () => {
      client._socketInstances[0].synchronizationThrottler = synchronizationThrottler;
      let listener = {
        onSynchronizationStarted: () => {},
        onPositionsSynchronized: () => {},
        onPendingOrdersSynchronized: () => {},
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onSynchronizationStarted').resolves();
      sandbox.stub(listener, 'onPositionsSynchronized').resolves();
      sandbox.stub(listener, 'onPendingOrdersSynchronized').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId', instanceIndex: 1,
        synchronizationId: 'synchronizationId', host: 'ps-mpa-1', positionsUpdated: true,
        ordersUpdated: false });
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation, instanceIndex: 1, host: 'ps-mpa-1', synchronizationId: 'synchronizationId' });
      await new _promise2.default(res => setTimeout(res, 100));
      _sinon2.default.assert.calledWith(listener.onSynchronizationStarted, '1:ps-mpa-1', true, true, false);
      _sinon2.default.assert.notCalled(listener.onPositionsSynchronized);
      _sinon2.default.assert.calledWith(listener.onPendingOrdersSynchronized, '1:ps-mpa-1', 'synchronizationId');
    });

    it('should synchronize account information', async () => {
      let listener = {
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onAccountInformationUpdated').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        host: 'ps-mpa-1', accountInformation, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onAccountInformationUpdated, '1:ps-mpa-1', accountInformation);
    });

    it('should synchronize positions', async () => {
      let positions = [{
        id: '46214692',
        type: 'POSITION_TYPE_BUY',
        symbol: 'GBPUSD',
        magic: 1000,
        time: new Date('2020-04-15T02:45:06.521Z'),
        updateTime: new Date('2020-04-15T02:45:06.521Z'),
        openPrice: 1.26101,
        currentPrice: 1.24883,
        currentTickValue: 1,
        volume: 0.07,
        swap: 0,
        profit: -85.25999999999966,
        commission: -0.25,
        clientId: 'TE_GBPUSD_7hyINWqAlE',
        stopLoss: 1.17721,
        unrealizedProfit: -85.25999999999901,
        realizedProfit: -6.536993168992922e-13
      }];
      client._socketInstances[0].synchronizationThrottler = synchronizationThrottler;
      let listener = {
        onPositionsReplaced: () => {},
        onPositionsSynchronized: () => {}
      };
      sandbox.stub(listener, 'onPositionsReplaced').resolves();
      sandbox.stub(listener, 'onPositionsSynchronized').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'positions', accountId: 'accountId', positions, instanceIndex: 1,
        synchronizationId: 'synchronizationId', host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onPositionsReplaced, '1:ps-mpa-1', positions);
      _sinon2.default.assert.calledWith(listener.onPositionsSynchronized, '1:ps-mpa-1', 'synchronizationId');
    });

    it('should synchronize orders', async () => {
      let orders = [{
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      }];
      let listener = {
        onPendingOrdersReplaced: () => {},
        onPendingOrdersSynchronized: () => {}
      };
      client._socketInstances[0].synchronizationThrottler = synchronizationThrottler;
      sandbox.stub(listener, 'onPendingOrdersReplaced').resolves();
      sandbox.stub(listener, 'onPendingOrdersSynchronized').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders, instanceIndex: 1,
        synchronizationId: 'synchronizationId', host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 100));
      _sinon2.default.assert.calledWith(listener.onPendingOrdersReplaced, '1:ps-mpa-1', orders);
      _sinon2.default.assert.calledWith(listener.onPendingOrdersSynchronized, '1:ps-mpa-1', 'synchronizationId');
    });

    it('should synchronize history orders', async () => {
      let historyOrders = [{
        clientId: 'TE_GBPUSD_7hyINWqAlE',
        currentPrice: 1.261,
        currentVolume: 0,
        doneTime: new Date('2020-04-15T02:45:06.521Z'),
        id: '46214692',
        magic: 1000,
        platform: 'mt5',
        positionId: '46214692',
        state: 'ORDER_STATE_FILLED',
        symbol: 'GBPUSD',
        time: new Date('2020-04-15T02:45:06.260Z'),
        type: 'ORDER_TYPE_BUY',
        volume: 0.07
      }];
      let listener = {
        onHistoryOrderAdded: () => {}
      };
      sandbox.stub(listener, 'onHistoryOrderAdded').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'historyOrders', accountId: 'accountId', historyOrders,
        instanceIndex: 1, host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onHistoryOrderAdded, '1:ps-mpa-1', historyOrders[0]);
    });

    it('should synchronize deals', async () => {
      let deals = [{
        clientId: 'TE_GBPUSD_7hyINWqAlE',
        commission: -0.25,
        entryType: 'DEAL_ENTRY_IN',
        id: '33230099',
        magic: 1000,
        platform: 'mt5',
        orderId: '46214692',
        positionId: '46214692',
        price: 1.26101,
        profit: 0,
        swap: 0,
        symbol: 'GBPUSD',
        time: new Date('2020-04-15T02:45:06.521Z'),
        type: 'DEAL_TYPE_BUY',
        volume: 0.07
      }];
      let listener = {
        onDealAdded: () => {}
      };
      sandbox.stub(listener, 'onDealAdded').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'deals', accountId: 'accountId', deals, instanceIndex: 1,
        host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onDealAdded, '1:ps-mpa-1', deals[0]);
    });

    it('should process synchronization updates', async () => {
      let update = {
        accountInformation: {
          broker: 'True ECN Trading Ltd',
          currency: 'USD',
          server: 'ICMarketsSC-Demo',
          balance: 7319.9,
          equity: 7306.649913200001,
          margin: 184.1,
          freeMargin: 7120.22,
          leverage: 100,
          marginLevel: 3967.58283542
        },
        updatedPositions: [{
          id: '46214692',
          type: 'POSITION_TYPE_BUY',
          symbol: 'GBPUSD',
          magic: 1000,
          time: new Date('2020-04-15T02:45:06.521Z'),
          updateTime: new Date('2020-04-15T02:45:06.521Z'),
          openPrice: 1.26101,
          currentPrice: 1.24883,
          currentTickValue: 1,
          volume: 0.07,
          swap: 0,
          profit: -85.25999999999966,
          commission: -0.25,
          clientId: 'TE_GBPUSD_7hyINWqAlE',
          stopLoss: 1.17721,
          unrealizedProfit: -85.25999999999901,
          realizedProfit: -6.536993168992922e-13
        }],
        removedPositionIds: ['1234'],
        updatedOrders: [{
          id: '46871284',
          type: 'ORDER_TYPE_BUY_LIMIT',
          state: 'ORDER_STATE_PLACED',
          symbol: 'AUDNZD',
          magic: 123456,
          platform: 'mt5',
          time: new Date('2020-04-20T08:38:58.270Z'),
          openPrice: 1.03,
          currentPrice: 1.05206,
          volume: 0.01,
          currentVolume: 0.01,
          comment: 'COMMENT2'
        }],
        completedOrderIds: ['2345'],
        historyOrders: [{
          clientId: 'TE_GBPUSD_7hyINWqAlE',
          currentPrice: 1.261,
          currentVolume: 0,
          doneTime: new Date('2020-04-15T02:45:06.521Z'),
          id: '46214692',
          magic: 1000,
          platform: 'mt5',
          positionId: '46214692',
          state: 'ORDER_STATE_FILLED',
          symbol: 'GBPUSD',
          time: new Date('2020-04-15T02:45:06.260Z'),
          type: 'ORDER_TYPE_BUY',
          volume: 0.07
        }],
        deals: [{
          clientId: 'TE_GBPUSD_7hyINWqAlE',
          commission: -0.25,
          entryType: 'DEAL_ENTRY_IN',
          id: '33230099',
          magic: 1000,
          platform: 'mt5',
          orderId: '46214692',
          positionId: '46214692',
          price: 1.26101,
          profit: 0,
          swap: 0,
          symbol: 'GBPUSD',
          time: new Date('2020-04-15T02:45:06.521Z'),
          type: 'DEAL_TYPE_BUY',
          volume: 0.07
        }]
      };
      let listener = {
        onAccountInformationUpdated: () => {},
        onPositionUpdated: () => {},
        onPositionRemoved: () => {},
        onPendingOrderUpdated: () => {},
        onPendingOrderCompleted: () => {},
        onHistoryOrderAdded: () => {},
        onDealAdded: () => {}
      };
      sandbox.stub(listener, 'onAccountInformationUpdated').resolves();
      sandbox.stub(listener, 'onPositionUpdated').resolves();
      sandbox.stub(listener, 'onPositionRemoved').resolves();
      sandbox.stub(listener, 'onPendingOrderUpdated').resolves();
      sandbox.stub(listener, 'onPendingOrderCompleted').resolves();
      sandbox.stub(listener, 'onHistoryOrderAdded').resolves();
      sandbox.stub(listener, 'onDealAdded').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', (0, _assign2.default)({ type: 'update', accountId: 'accountId', instanceIndex: 1,
        host: 'ps-mpa-1' }, update));
      await new _promise2.default(res => setTimeout(res, 100));
      _sinon2.default.assert.calledWith(listener.onAccountInformationUpdated, '1:ps-mpa-1', update.accountInformation);
      _sinon2.default.assert.calledWith(listener.onPositionUpdated, '1:ps-mpa-1', update.updatedPositions[0]);
      _sinon2.default.assert.calledWith(listener.onPositionRemoved, '1:ps-mpa-1', update.removedPositionIds[0]);
      _sinon2.default.assert.calledWith(listener.onPendingOrderUpdated, '1:ps-mpa-1', update.updatedOrders[0]);
      _sinon2.default.assert.calledWith(listener.onPendingOrderCompleted, '1:ps-mpa-1', update.completedOrderIds[0]);
      _sinon2.default.assert.calledWith(listener.onHistoryOrderAdded, '1:ps-mpa-1', update.historyOrders[0]);
      _sinon2.default.assert.calledWith(listener.onDealAdded, '1:ps-mpa-1', update.deals[0]);
    });
  });

  describe('market data synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should retry request on failure', async () => {
      let requestCounter = 0;
      let order = {
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      };
      server.on('request', data => {
        if (requestCounter > 1 && data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
        }
        requestCounter++;
      });
      let actual = await client.getOrder('accountId', '46871284');
      actual.should.match(order);
    }).timeout(20000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should wait specified amount of time on too many requests error', async () => {
      let requestCounter = 0;
      let order = {
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      };
      server.on('request', data => {
        if (requestCounter > 0 && data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
        } else {
          server.emit('processingError', {
            id: 1, error: 'TooManyRequestsError', requestId: data.requestId,
            message: 'The API allows 10000 requests per 60 minutes to avoid overloading our servers.',
            status_code: 429, metadata: {
              periodInMinutes: 60, maxRequestsForPeriod: 10000,
              recommendedRetryTime: new Date(Date.now() + 1000)
            }
          });
        }
        requestCounter++;
      });
      const startTime = Date.now();
      let actual = await client.getOrder('accountId', '46871284');
      actual.should.match(order);
      (Date.now() - startTime).should.be.approximately(1000, 100);
    }).timeout(10000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should return too many requests exception if recommended time is beyond max request time', async () => {
      let requestCounter = 0;
      let order = {
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      };
      server.on('request', data => {
        if (requestCounter > 0 && data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
        } else {
          server.emit('processingError', {
            id: 1, error: 'TooManyRequestsError', requestId: data.requestId,
            message: 'The API allows 10000 requests per 60 minutes to avoid overloading our servers.',
            status_code: 429, metadata: {
              periodInMinutes: 60, maxRequestsForPeriod: 10000,
              recommendedRetryTime: new Date(Date.now() + 60000)
            }
          });
        }
        requestCounter++;
      });

      try {
        await client.getOrder('accountId', '46871284');
        throw new Error('TooManyRequestsError expected');
      } catch (err) {
        err.name.should.equal('TooManyRequestsError');
      }
    }).timeout(10000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should not retry request on validation error', async () => {
      let requestCounter = 0;
      server.on('request', data => {
        if (requestCounter > 0 && data.type === 'subscribeToMarketData' && data.accountId === 'accountId' && data.symbol === 'EURUSD' && data.application === 'application' && data.instanceIndex === 1) {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        } else {
          server.emit('processingError', {
            id: 1, error: 'ValidationError', message: 'Error message', requestId: data.requestId
          });
        }
        requestCounter++;
      });
      try {
        await client.subscribeToMarketData('accountId', 1, 'EURUSD');
        throw new Error('ValidationError expected');
      } catch (err) {
        err.name.should.equal('ValidationError');
      }
      _sinon2.default.assert.match(requestCounter, 1);
    }).timeout(6000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should not retry trade requests on fail', async () => {
      let requestCounter = 0;
      let trade = {
        actionType: 'ORDER_TYPE_SELL',
        symbol: 'AUDNZD',
        volume: 0.07
      };
      server.on('request', data => {
        if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
          if (requestCounter > 0) {
            _sinon2.default.assert.fail();
          }
          requestCounter++;
        }
      });
      try {
        await client.trade(trade);
        throw new Error('TimeoutError expected');
      } catch (err) {
        err.name.should.equal('TimeoutError');
      }
    }).timeout(6000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should not retry request if connection closed between retries', async () => {
      let requestCounter = 0;
      let response = { type: 'response', accountId: 'accountId' };
      server.on('request', async data => {
        if (data.type === 'unsubscribe' && data.accountId === 'accountId') {
          server.emit('response', (0, _assign2.default)({ requestId: data.requestId }, response));
        }

        if (data.type === 'getOrders' && data.accountId === 'accountId' && data.application === 'RPC') {
          requestCounter++;
          server.emit('processingError', {
            id: 1, error: 'NotSynchronizedError', message: 'Error message',
            requestId: data.requestId
          });
        }
      });
      client.unsubscribe('accountId');
      try {
        await client.getOrders('accountId');
        throw new Error('NotSynchronizedError expected');
      } catch (err) {
        err.name.should.equal('NotSynchronizedError');
      }
      requestCounter.should.equal(1);
      client.socketInstancesByAccounts.should.not.have.property('accountId');
    });

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should return timeout error if no server response received', async () => {
      let trade = {
        actionType: 'ORDER_TYPE_SELL',
        symbol: 'AUDNZD',
        volume: 0.07
      };
      server.on('request', data => {});
      try {
        await client.trade(trade);
        throw new Error('TimeoutError extected');
      } catch (err) {
        err.name.should.equal('TimeoutError');
      }
    }).timeout(20000);

    /**
     * @test {MetaApiWebsocketClient#subscribeToMarketData}
     */
    it('should subscribe to market data with MetaTrader terminal', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'subscribeToMarketData' && data.accountId === 'accountId' && data.symbol === 'EURUSD' && data.application === 'application' && data.instanceIndex === 1 && (0, _stringify2.default)(data.subscriptions) === (0, _stringify2.default)([{ type: 'quotes' }])) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.subscribeToMarketData('accountId', 1, 'EURUSD', [{ type: 'quotes' }]);
      requestReceived.should.be.true();
    });

    /**
     * @test {MetaApiWebsocketClient#refreshMarketDataSubscriptions}
     */
    it('should refresh market data subscriptions', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'refreshMarketDataSubscriptions' && data.accountId === 'accountId' && data.application === 'application' && data.instanceIndex === 1 && (0, _stringify2.default)(data.subscriptions) === (0, _stringify2.default)([{ symbol: 'EURUSD' }])) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.refreshMarketDataSubscriptions('accountId', 1, [{ symbol: 'EURUSD' }]);
      requestReceived.should.be.true();
    });

    /**
     * @test {MetaApiWebsocketClient#unsubscribeFromMarketData}
     */
    it('should unsubscribe from market data with MetaTrader terminal', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'unsubscribeFromMarketData' && data.accountId === 'accountId' && data.symbol === 'EURUSD' && data.application === 'application' && data.instanceIndex === 1 && (0, _stringify2.default)(data.subscriptions) === (0, _stringify2.default)([{ type: 'quotes' }])) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.unsubscribeFromMarketData('accountId', 1, 'EURUSD', [{ type: 'quotes' }]);
      requestReceived.should.be.true();
    });

    it('should synchronize symbol specifications', async () => {
      let specifications = [{
        symbol: 'EURUSD',
        tickSize: 0.00001,
        minVolume: 0.01,
        maxVolume: 200,
        volumeStep: 0.01
      }];
      let listener = {
        onSymbolSpecificationsUpdated: () => {},
        onSymbolSpecificationUpdated: () => {},
        onSymbolSpecificationRemoved: () => {}
      };
      sandbox.stub(listener, 'onSymbolSpecificationsUpdated').resolves();
      sandbox.stub(listener, 'onSymbolSpecificationUpdated').resolves();
      sandbox.stub(listener, 'onSymbolSpecificationRemoved').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'specifications', accountId: 'accountId', specifications, instanceIndex: 1, host: 'ps-mpa-1',
        removedSymbols: ['AUDNZD'] });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onSymbolSpecificationsUpdated, '1:ps-mpa-1', specifications, ['AUDNZD']);
      _sinon2.default.assert.calledWith(listener.onSymbolSpecificationUpdated, '1:ps-mpa-1', specifications[0]);
      _sinon2.default.assert.calledWith(listener.onSymbolSpecificationRemoved, '1:ps-mpa-1', 'AUDNZD');
    });

    it('should synchronize symbol prices', async () => {
      let prices = [{
        symbol: 'AUDNZD',
        bid: 1.05916,
        ask: 1.05927,
        profitTickValue: 0.602,
        lossTickValue: 0.60203
      }];
      let ticks = [{
        symbol: 'AUDNZD',
        time: new Date('2020-04-07T03:45:00.000Z'),
        brokerTime: '2020-04-07 06:45:00.000',
        bid: 1.05297,
        ask: 1.05309,
        last: 0.5298,
        volume: 0.13,
        side: 'buy'
      }];
      let candles = [{
        symbol: 'AUDNZD',
        timeframe: '15m',
        time: new Date('2020-04-07T03:45:00.000Z'),
        brokerTime: '2020-04-07 06:45:00.000',
        open: 1.03297,
        high: 1.06309,
        low: 1.02705,
        close: 1.043,
        tickVolume: 1435,
        spread: 17,
        volume: 345
      }];
      let books = [{
        symbol: 'AUDNZD',
        time: new Date('2020-04-07T03:45:00.000Z'),
        brokerTime: '2020-04-07 06:45:00.000',
        book: [{
          type: 'BOOK_TYPE_SELL',
          price: 1.05309,
          volume: 5.67
        }, {
          type: 'BOOK_TYPE_BUY',
          price: 1.05297,
          volume: 3.45
        }]
      }];
      let listener = {
        onSymbolPriceUpdated: () => {},
        onSymbolPricesUpdated: () => {},
        onCandlesUpdated: () => {},
        onTicksUpdated: () => {},
        onBooksUpdated: () => {}
      };
      sandbox.stub(listener, 'onSymbolPriceUpdated').resolves();
      sandbox.stub(listener, 'onSymbolPricesUpdated').resolves();
      sandbox.stub(listener, 'onCandlesUpdated').resolves();
      sandbox.stub(listener, 'onTicksUpdated').resolves();
      sandbox.stub(listener, 'onBooksUpdated').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'prices', accountId: 'accountId', host: 'ps-mpa-1', prices,
        ticks, candles, books, equity: 100, margin: 200, freeMargin: 400, marginLevel: 40000, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onSymbolPricesUpdated, '1:ps-mpa-1', prices, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onCandlesUpdated, '1:ps-mpa-1', candles, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onTicksUpdated, '1:ps-mpa-1', ticks, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onBooksUpdated, '1:ps-mpa-1', books, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onSymbolPriceUpdated, '1:ps-mpa-1', prices[0]);
    });
  });

  describe('wait for server-side terminal state synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    /**
     * @test {MetaApiWebsocketClient#waitSynchronized}
     */
    it('should wait for server-side terminal state synchronization', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'waitSynchronized' && data.accountId === 'accountId' && data.applicationPattern === 'app.*' && data.timeoutInSeconds === 10 && data.application === 'application' && data.instanceIndex === 1) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.waitSynchronized('accountId', 1, 'app.*', 10);
      requestReceived.should.be.true();
    });
  });

  describe('latency monitoring', () => {

    /**
     * @test {LatencyListener#onResponse}
     */
    it('should invoke latency listener on response', async () => {
      let accountId;
      let requestType;
      let actualTimestamps;
      let listener = {
        onResponse: (aid, type, ts) => {
          accountId = aid;
          requestType = type;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      let price = {};
      let timestamps;
      server.on('request', data => {
        if (data.type === 'getSymbolPrice' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC' && data.timestamps.clientProcessingStarted) {
          timestamps = (0, _assign2.default)(data.timestamps, { serverProcessingStarted: new Date(),
            serverProcessingFinished: new Date() });
          timestamps.clientProcessingStarted = new Date(timestamps.clientProcessingStarted);
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, price,
            timestamps });
        }
      });
      await client.getSymbolPrice('accountId', 'AUDNZD');
      await new _promise2.default(res => setTimeout(res, 100));
      accountId.should.equal('accountId');
      requestType.should.equal('getSymbolPrice');
      actualTimestamps.should.match(timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingStarted);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
      _should2.default.exist(actualTimestamps.serverProcessingStarted);
      _should2.default.exist(actualTimestamps.serverProcessingFinished);
    });

    /**
     * @test {LatencyListener#onSymbolPrice}
     */
    it('should measure price streaming latencies', async () => {
      let prices = [{
        symbol: 'AUDNZD',
        timestamps: {
          eventGenerated: new Date(),
          serverProcessingStarted: new Date(),
          serverProcessingFinished: new Date()
        }
      }];
      let accountId;
      let symbol;
      let actualTimestamps;
      let listener = {
        onSymbolPrice: (aid, sym, ts) => {
          accountId = aid;
          symbol = sym;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      server.emit('synchronization', { type: 'prices', accountId: 'accountId', prices, equity: 100, margin: 200,
        freeMargin: 400, marginLevel: 40000 });
      await new _promise2.default(res => setTimeout(res, 50));
      accountId.should.equal('accountId');
      symbol.should.equal('AUDNZD');
      actualTimestamps.should.match(prices[0].timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
    });

    /**
     * @test {LatencyListener#onUpdate}
     */
    it('should measure update latencies', async () => {
      let update = {
        timestamps: {
          eventGenerated: new Date(),
          serverProcessingStarted: new Date(),
          serverProcessingFinished: new Date()
        }
      };
      let accountId;
      let actualTimestamps;
      let listener = {
        onUpdate: (aid, ts) => {
          accountId = aid;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      server.emit('synchronization', (0, _assign2.default)({ type: 'update', accountId: 'accountId' }, update));
      await new _promise2.default(res => setTimeout(res, 50));
      accountId.should.equal('accountId');
      actualTimestamps.should.match(update.timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
    });

    /**
     * @test {LatencyListener#onTrade}
     */
    it('should process trade latency', async () => {
      let trade = {};
      let response = {
        numericCode: 10009,
        stringCode: 'TRADE_RETCODE_DONE',
        message: 'Request completed',
        orderId: '46870472'
      };
      let timestamps = {
        clientExecutionStarted: new Date(),
        serverExecutionStarted: new Date(),
        serverExecutionFinished: new Date(),
        tradeExecuted: new Date()
      };
      let accountId;
      let actualTimestamps;
      let listener = {
        onTrade: (aid, ts) => {
          accountId = aid;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      server.on('request', data => {
        data.trade.should.match(trade);
        if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response,
            timestamps });
        }
      });
      await client.trade('accountId', trade);
      accountId.should.equal('accountId');
      actualTimestamps.should.match(timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
    });
  });

  it('should reconnect to server on disconnect', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
    const trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    const response = {
      numericCode: 10009,
      stringCode: 'TRADE_RETCODE_DONE',
      message: 'Request completed',
      orderId: '46870472'
    };
    let listener = {
      onReconnected: () => {}
    };
    sandbox.stub(listener, 'onReconnected').resolves();
    sandbox.stub(client._packetOrderer, 'onReconnected').resolves();
    sandbox.stub(client._subscriptionManager, 'onReconnected').resolves();
    client.addReconnectListener(listener, 'accountId');
    let requestCounter = 0;
    server.on('request', async data => {
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        requestCounter++;
        await server.emit('response', { type: 'response', accountId: data.accountId,
          requestId: data.requestId, response });
      }
      await server.disconnect();
    });

    client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1500);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onReconnected);
    _sinon2.default.assert.calledWith(client._subscriptionManager.onReconnected, 0, ['accountId']);
    _sinon2.default.assert.calledWith(client._packetOrderer.onReconnected, ['accountId']);

    server.on('request', async data => {
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        requestCounter++;
        await server.emit('response', { type: 'response', accountId: data.accountId,
          requestId: data.requestId, response });
      }
      await server.disconnect();
    });

    client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1500);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.match(requestCounter, 2);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#_rpcRequest}
   */
  it('should remove reconnect listener', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });

    let trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    let response = {
      numericCode: 10009,
      stringCode: 'TRADE_RETCODE_DONE',
      message: 'Request completed',
      orderId: '46870472'
    };
    const listener = { onReconnected: async () => {} };
    sandbox.stub(listener, 'onReconnected').resolves();
    client.addReconnectListener(listener, 'accountId');
    sandbox.stub(client._subscriptionManager, 'onReconnected');
    let requestCounter = 0;
    server.on('request', data => {
      data.trade.should.match(trade);
      requestCounter++;
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
      server.disconnect();
    });

    await client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1100);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onReconnected);
    client.removeReconnectListener(listener);

    server.on('request', data => {
      data.trade.should.match(trade);
      requestCounter++;
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
      server.disconnect();
    });

    await client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1100);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onReconnected);
    _sinon2.default.assert.match(requestCounter, 2);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#queuePacket}
   */
  it('should process packets in order', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
    let ordersCallTime = 0;
    let positionsCallTime = 0;
    let disconnectedCallTime = 0;
    let pricesCallTime = 0;
    let listener = {
      onConnected: () => {},
      onDisconnected: async () => {
        await new _promise2.default(res => setTimeout(res, 5000));
        disconnectedCallTime = Date.now();
      },
      onPendingOrdersReplaced: async () => {
        await new _promise2.default(res => setTimeout(res, 10000));
        ordersCallTime = Date.now();
      },
      onPendingOrdersSynchronized: () => {},
      onPositionsReplaced: async () => {
        await new _promise2.default(res => setTimeout(res, 1000));
        positionsCallTime = Date.now();
      },
      onPositionsSynchronized: () => {},
      onSymbolPriceUpdated: () => {},
      onSymbolPricesUpdated: async () => {
        await new _promise2.default(res => setTimeout(res, 1000));
        pricesCallTime = Date.now();
      }
    };
    let resolve;
    let promise = new _promise2.default(res => resolve = res);
    client.close();
    io.close(() => resolve());
    await promise;
    io = new _socket2.default(6785, { path: '/ws', pingTimeout: 1000000 });
    sandbox.stub(httpClient, 'request').resolves({ url: 'http://localhost:6785' });
    client = new _metaApiWebsocket2.default(httpClient, 'token', { application: 'application',
      domain: 'project-stock.agiliumlabs.cloud', requestTimeout: 1.5, useSharedClientApi: false,
      retryOpts: { retries: 3, minDelayInSeconds: 0.1, maxDelayInSeconds: 0.5 },
      eventProcessing: { sequentialProcessing: true } });
    io.on('connect', socket => {
      server = socket;
      if (socket.request._query['auth-token'] !== 'token') {
        socket.emit({ error: 'UnauthorizedError', message: 'Authorization token invalid' });
        socket.close();
      }
      server.on('request', data => {
        if (data.type === 'getPositions' && data.accountId === 'accountId' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId,
            requestId: data.requestId, positions: [] });
        }
      });
    });
    await client.getPositions('accountId');
    client.addSynchronizationListener('accountId', listener);
    sandbox.stub(client._packetOrderer, 'restoreOrder').callsFake(arg => {
      return [arg];
    });
    server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
      instanceIndex: 1, replicas: 2, sequenceNumber: 1 });
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(59000);
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [], instanceIndex: 1,
      host: 'ps-mpa-1', sequenceNumber: 2 });
    server.emit('synchronization', { type: 'prices', accountId: 'accountId', prices: [{ symbol: 'EURUSD' }],
      instanceIndex: 1, host: 'ps-mpa-1', equity: 100, margin: 200, freeMargin: 400, marginLevel: 40000 });
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(3000);
    server.emit('synchronization', { type: 'positions', accountId: 'accountId', positions: [], instanceIndex: 1,
      host: 'ps-mpa-1', sequenceNumber: 3 });
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(20000);
    await new _promise2.default(res => setTimeout(res, 50));
    pricesCallTime.should.not.eql(0);
    ordersCallTime.should.be.above(pricesCallTime);
    disconnectedCallTime.should.be.above(ordersCallTime);
    positionsCallTime.should.be.above(disconnectedCallTime);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#queuePacket}
   */
  it('should not process old synchronization packet without gaps in sequence numbers', async () => {
    let listener = {
      onSynchronizationStarted: _sinon2.default.fake(),
      onPendingOrdersReplaced: _sinon2.default.fake(),
      onPendingOrdersSynchronized: () => {}
    };
    client.addSynchronizationListener('accountId', listener);
    sandbox.stub(client._packetOrderer, 'restoreOrder').callsFake(arg => [arg]);

    sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => ['ABC']);
    server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId',
      sequenceNumber: 1, sequenceTimestamp: 1603124267178, synchronizationId: 'ABC' });
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [],
      sequenceNumber: 2, sequenceTimestamp: 1603124267181, synchronizationId: 'ABC' });
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onSynchronizationStarted);
    _sinon2.default.assert.calledOnce(listener.onPendingOrdersReplaced);

    sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => ['DEF']);
    server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId',
      sequenceNumber: 3, sequenceTimestamp: 1603124267190, synchronizationId: 'DEF' });
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [],
      sequenceNumber: 4, sequenceTimestamp: 1603124267192, synchronizationId: 'ABC' });
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [],
      sequenceNumber: 5, sequenceTimestamp: 1603124267195, synchronizationId: 'DEF' });
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledTwice(listener.onSynchronizationStarted);
    _sinon2.default.assert.calledTwice(listener.onPendingOrdersReplaced);
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvbWV0YUFwaVdlYnNvY2tldC5jbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsibWV0YWFwaUFwaVVybCIsImRlc2NyaWJlIiwiaW8iLCJzZXJ2ZXIiLCJjbGllbnQiLCJzYW5kYm94IiwiaHR0cENsaWVudCIsIkh0dHBDbGllbnQiLCJlbXB0eUhhc2giLCJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMiLCJvbkRpc2Nvbm5lY3QiLCJ1cGRhdGVTeW5jaHJvbml6YXRpb25JZCIsImFjY291bnRJbmZvcm1hdGlvbiIsImJyb2tlciIsImN1cnJlbmN5IiwiYmFsYW5jZSIsImVxdWl0eSIsIm1hcmdpbiIsImZyZWVNYXJnaW4iLCJsZXZlcmFnZSIsIm1hcmdpbkxldmVsIiwiYmVmb3JlIiwic2lub24iLCJjcmVhdGVTYW5kYm94IiwiYmVmb3JlRWFjaCIsIk1ldGFBcGlXZWJzb2NrZXRDbGllbnQiLCJhcHBsaWNhdGlvbiIsImRvbWFpbiIsInJlcXVlc3RUaW1lb3V0IiwidXNlU2hhcmVkQ2xpZW50QXBpIiwicmV0cnlPcHRzIiwicmV0cmllcyIsIm1pbkRlbGF5SW5TZWNvbmRzIiwibWF4RGVsYXlJblNlY29uZHMiLCJ1cmwiLCJTZXJ2ZXIiLCJwYXRoIiwicGluZ1RpbWVvdXQiLCJvbiIsInNvY2tldCIsInJlcXVlc3QiLCJfcXVlcnkiLCJlbWl0IiwiZXJyb3IiLCJtZXNzYWdlIiwiY2xvc2UiLCJfc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyIsImFjY291bnRJZCIsImNvbm5lY3QiLCJzdHViIiwiX3NvY2tldEluc3RhbmNlcyIsImdldCIsImFmdGVyRWFjaCIsInJlc3RvcmUiLCJyZXNvbHZlIiwicHJvbWlzZSIsInJlcyIsIml0IiwiY2xvY2siLCJ1c2VGYWtlVGltZXJzIiwic2hvdWxkQWR2YW5jZVRpbWUiLCJjbGllbnRJZCIsImNvbm5lY3RBbW91bnQiLCJoZWFkZXJzIiwic2hvdWxkIiwiZXF1YWwiLCJub3QiLCJkaXNjb25uZWN0Iiwic2V0VGltZW91dCIsInRpY2tBc3luYyIsImJlIiwiYWJvdmVPckVxdWFsIiwicG9zaXRpb25zIiwiaWQiLCJ0eXBlIiwic3ltYm9sIiwibWFnaWMiLCJ0aW1lIiwiRGF0ZSIsInVwZGF0ZVRpbWUiLCJvcGVuUHJpY2UiLCJjdXJyZW50UHJpY2UiLCJjdXJyZW50VGlja1ZhbHVlIiwidm9sdW1lIiwic3dhcCIsInByb2ZpdCIsImNvbW1pc3Npb24iLCJzdG9wTG9zcyIsInVucmVhbGl6ZWRQcm9maXQiLCJyZWFsaXplZFByb2ZpdCIsInJlc29sdmVzIiwiZGF0YSIsInJlcXVlc3RJZCIsImFjdHVhbCIsImdldFBvc2l0aW9ucyIsIm1hdGNoIiwiZ2V0QWNjb3VudEluZm9ybWF0aW9uIiwicG9zaXRpb24iLCJwb3NpdGlvbklkIiwiZ2V0UG9zaXRpb24iLCJvcmRlcnMiLCJzdGF0ZSIsInBsYXRmb3JtIiwiY3VycmVudFZvbHVtZSIsImNvbW1lbnQiLCJnZXRPcmRlcnMiLCJvcmRlciIsIm9yZGVySWQiLCJnZXRPcmRlciIsImhpc3RvcnlPcmRlcnMiLCJkb25lVGltZSIsInRpY2tldCIsInN5bmNocm9uaXppbmciLCJnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQiLCJnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbiIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJvZmZzZXQiLCJsaW1pdCIsImdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZSIsImRlYWxzIiwiZW50cnlUeXBlIiwicHJpY2UiLCJnZXREZWFsc0J5VGlja2V0IiwiZ2V0RGVhbHNCeVBvc2l0aW9uIiwiZ2V0RGVhbHNCeVRpbWVSYW5nZSIsInJlcXVlc3RSZWNlaXZlZCIsInJlbW92ZUhpc3RvcnkiLCJ0cnVlIiwicmVtb3ZlQXBwbGljYXRpb24iLCJ0cmFkZSIsImFjdGlvblR5cGUiLCJyZXNwb25zZSIsIm51bWVyaWNDb2RlIiwic3RyaW5nQ29kZSIsImRlc2NyaXB0aW9uIiwiZmFpbCIsImVyciIsIm5hbWUiLCJpbnN0YW5jZUluZGV4Iiwic3Vic2NyaWJlIiwiYXNzZXJ0Iiwic29ja2V0SW5zdGFuY2VzIiwibGVuZ3RoIiwiaSIsInJlbW92ZUFsbExpc3RlbmVycyIsInN1Y2Nlc3MiLCJyZWNvbm5lY3QiLCJzeW1ib2xzIiwiZ2V0U3ltYm9scyIsInNwZWNpZmljYXRpb24iLCJ0aWNrU2l6ZSIsIm1pblZvbHVtZSIsIm1heFZvbHVtZSIsInZvbHVtZVN0ZXAiLCJnZXRTeW1ib2xTcGVjaWZpY2F0aW9uIiwiYmlkIiwiYXNrIiwicHJvZml0VGlja1ZhbHVlIiwibG9zc1RpY2tWYWx1ZSIsImdldFN5bWJvbFByaWNlIiwiY2FuZGxlIiwidGltZWZyYW1lIiwiYnJva2VyVGltZSIsIm9wZW4iLCJoaWdoIiwibG93IiwidGlja1ZvbHVtZSIsInNwcmVhZCIsImdldENhbmRsZSIsInRpY2siLCJsYXN0Iiwic2lkZSIsImdldFRpY2siLCJib29rIiwiZ2V0Qm9vayIsInVwdGltZSIsInNhdmVVcHRpbWUiLCJ1bnN1YnNjcmliZSIsInNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJoYXZlIiwicHJvcGVydHkiLCJkZXRhaWxzIiwicGFyYW1ldGVyIiwiRXJyb3IiLCJ0aW1lb3V0IiwibGlzdGVuZXIiLCJvbkNvbm5lY3RlZCIsImFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiaG9zdCIsInJlcGxpY2FzIiwiY2FsbGVkV2l0aCIsInNlc3Npb25JZCIsIl9zZXNzaW9uSWQiLCJjYWxsQ291bnQiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwiY29ubmVjdGVkIiwib25EaXNjb25uZWN0ZWQiLCJub3RDYWxsZWQiLCJvblN0cmVhbUNsb3NlZCIsIm9uVGltZW91dFN0dWIiLCJfc3Vic2NyaXB0aW9uTWFuYWdlciIsIm9uU3RyZWFtQ2xvc2VkU3R1YiIsIm9uRGlzY29ubmVjdGVkU3R1YiIsIm9uSGVhbHRoU3RhdHVzIiwiaGVhbHRoU3RhdHVzIiwicmVzdEFwaUhlYWx0aHkiLCJjYWxsZWRPbmNlIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkIiwic3luY2hyb25pemF0aW9uSWQiLCJzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUiLCJzdGFydGluZ0RlYWxUaW1lIiwic3luY2hyb25pemUiLCJvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQiLCJvblBvc2l0aW9uc1N5bmNocm9uaXplZCIsIm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsIm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkIiwib25IaXN0b3J5T3JkZXJBZGRlZCIsIm9uRGVhbEFkZGVkIiwidXBkYXRlIiwidXBkYXRlZFBvc2l0aW9ucyIsInJlbW92ZWRQb3NpdGlvbklkcyIsInVwZGF0ZWRPcmRlcnMiLCJjb21wbGV0ZWRPcmRlcklkcyIsIm9uUG9zaXRpb25VcGRhdGVkIiwib25Qb3NpdGlvblJlbW92ZWQiLCJvblBlbmRpbmdPcmRlclVwZGF0ZWQiLCJvblBlbmRpbmdPcmRlckNvbXBsZXRlZCIsInJlcXVlc3RDb3VudGVyIiwic3RhdHVzX2NvZGUiLCJtZXRhZGF0YSIsInBlcmlvZEluTWludXRlcyIsIm1heFJlcXVlc3RzRm9yUGVyaW9kIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJub3ciLCJhcHByb3hpbWF0ZWx5Iiwic3Vic2NyaWJlVG9NYXJrZXREYXRhIiwic3Vic2NyaXB0aW9ucyIsInJlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsInVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEiLCJzcGVjaWZpY2F0aW9ucyIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQiLCJyZW1vdmVkU3ltYm9scyIsInByaWNlcyIsInRpY2tzIiwiY2FuZGxlcyIsImJvb2tzIiwib25TeW1ib2xQcmljZVVwZGF0ZWQiLCJvblN5bWJvbFByaWNlc1VwZGF0ZWQiLCJvbkNhbmRsZXNVcGRhdGVkIiwib25UaWNrc1VwZGF0ZWQiLCJvbkJvb2tzVXBkYXRlZCIsImFwcGxpY2F0aW9uUGF0dGVybiIsInRpbWVvdXRJblNlY29uZHMiLCJ3YWl0U3luY2hyb25pemVkIiwicmVxdWVzdFR5cGUiLCJhY3R1YWxUaW1lc3RhbXBzIiwib25SZXNwb25zZSIsImFpZCIsInRzIiwiYWRkTGF0ZW5jeUxpc3RlbmVyIiwidGltZXN0YW1wcyIsImNsaWVudFByb2Nlc3NpbmdTdGFydGVkIiwic2VydmVyUHJvY2Vzc2luZ1N0YXJ0ZWQiLCJzZXJ2ZXJQcm9jZXNzaW5nRmluaXNoZWQiLCJleGlzdCIsImNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCIsImV2ZW50R2VuZXJhdGVkIiwib25TeW1ib2xQcmljZSIsInN5bSIsIm9uVXBkYXRlIiwiY2xpZW50RXhlY3V0aW9uU3RhcnRlZCIsInNlcnZlckV4ZWN1dGlvblN0YXJ0ZWQiLCJzZXJ2ZXJFeGVjdXRpb25GaW5pc2hlZCIsInRyYWRlRXhlY3V0ZWQiLCJvblRyYWRlIiwib25SZWNvbm5lY3RlZCIsIl9wYWNrZXRPcmRlcmVyIiwiYWRkUmVjb25uZWN0TGlzdGVuZXIiLCJyZW1vdmVSZWNvbm5lY3RMaXN0ZW5lciIsIm9yZGVyc0NhbGxUaW1lIiwicG9zaXRpb25zQ2FsbFRpbWUiLCJkaXNjb25uZWN0ZWRDYWxsVGltZSIsInByaWNlc0NhbGxUaW1lIiwiZXZlbnRQcm9jZXNzaW5nIiwic2VxdWVudGlhbFByb2Nlc3NpbmciLCJjYWxsc0Zha2UiLCJhcmciLCJzZXF1ZW5jZU51bWJlciIsImVxbCIsImFib3ZlIiwiZmFrZSIsInNlcXVlbmNlVGltZXN0YW1wIiwiY2FsbGVkVHdpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7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QkFBUCxFQUFpQzNCLFdBQVcsV0FBNUM7QUFDN0JzUCxzQkFBZ0IsQ0FEYSxFQUNWSSxtQkFBbUIsYUFEVCxFQUN3QnhGLG1CQUFtQixLQUQzQyxFQUEvQjtBQUVBL00sV0FBT3dDLElBQVAsQ0FBWSxpQkFBWixFQUErQixFQUFDZ0MsTUFBTSxRQUFQLEVBQWlCM0IsV0FBVyxXQUE1QixFQUF5Q3FELFFBQVEsRUFBakQ7QUFDN0JpTSxzQkFBZ0IsQ0FEYSxFQUNWSSxtQkFBbUIsYUFEVCxFQUN3QnhGLG1CQUFtQixLQUQzQyxFQUEvQjtBQUVBL00sV0FBT3dDLElBQVAsQ0FBWSxpQkFBWixFQUErQixFQUFDZ0MsTUFBTSxRQUFQLEVBQWlCM0IsV0FBVyxXQUE1QixFQUF5Q3FELFFBQVEsRUFBakQ7QUFDN0JpTSxzQkFBZ0IsQ0FEYSxFQUNWSSxtQkFBbUIsYUFEVCxFQUN3QnhGLG1CQUFtQixLQUQzQyxFQUEvQjtBQUVBLFVBQU0sc0JBQVl6SixPQUFPWSxXQUFXWixHQUFYLEVBQWdCLEVBQWhCLENBQW5CLENBQU47QUFDQWxDLG9CQUFNdUgsTUFBTixDQUFhNkosV0FBYixDQUF5QmhILFNBQVMyQix3QkFBbEM7QUFDQS9MLG9CQUFNdUgsTUFBTixDQUFhNkosV0FBYixDQUF5QmhILFNBQVNpQyx1QkFBbEM7QUFDRCxHQTVCRDtBQThCRCxDQXp0RUQiLCJmaWxlIjoibWV0YUFwaVdlYnNvY2tldC5jbGllbnQuc3BlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHNob3VsZCBmcm9tICdzaG91bGQnO1xuaW1wb3J0IHNpbm9uIGZyb20gJ3Npbm9uJztcbmltcG9ydCBNZXRhQXBpV2Vic29ja2V0Q2xpZW50IGZyb20gJy4vbWV0YUFwaVdlYnNvY2tldC5jbGllbnQnO1xuaW1wb3J0IFNlcnZlciBmcm9tICdzb2NrZXQuaW8nO1xuaW1wb3J0IE5vdENvbm5lY3RlZEVycm9yIGZyb20gJy4vbm90Q29ubmVjdGVkRXJyb3InO1xuaW1wb3J0IHtJbnRlcm5hbEVycm9yfSBmcm9tICcuLi9lcnJvckhhbmRsZXInO1xuaW1wb3J0IEh0dHBDbGllbnQgZnJvbSAnLi4vaHR0cENsaWVudCc7XG5cbmNvbnN0IG1ldGFhcGlBcGlVcmwgPSAnaHR0cHM6Ly9tdC1jbGllbnQtYXBpLXYxLmFnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuXG4vKipcbiAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbmRlc2NyaWJlKCdNZXRhQXBpV2Vic29ja2V0Q2xpZW50JywgKCkgPT4ge1xuXG4gIGxldCBpbztcbiAgbGV0IHNlcnZlcjtcbiAgbGV0IGNsaWVudDtcbiAgbGV0IHNhbmRib3g7XG4gIGxldCBodHRwQ2xpZW50ID0gbmV3IEh0dHBDbGllbnQoKTtcbiAgY29uc3QgZW1wdHlIYXNoID0gJ2Q0MWQ4Y2Q5OGYwMGIyMDRlOTgwMDk5OGVjZjg0MjdlJztcbiAgY29uc3Qgc3luY2hyb25pemF0aW9uVGhyb3R0bGVyID0ge1xuICAgIGFjdGl2ZVN5bmNocm9uaXphdGlvbklkczogWydzeW5jaHJvbml6YXRpb25JZCddLFxuICAgIG9uRGlzY29ubmVjdDogKCkgPT4ge30sXG4gICAgdXBkYXRlU3luY2hyb25pemF0aW9uSWQ6ICgpID0+IHt9XG4gIH07XG4gIGxldCBhY2NvdW50SW5mb3JtYXRpb24gPSB7XG4gICAgYnJva2VyOiAnVHJ1ZSBFQ04gVHJhZGluZyBMdGQnLFxuICAgIGN1cnJlbmN5OiAnVVNEJyxcbiAgICBzZXJ2ZXI6ICdJQ01hcmtldHNTQy1EZW1vJyxcbiAgICBiYWxhbmNlOiA3MzE5LjksXG4gICAgZXF1aXR5OiA3MzA2LjY0OTkxMzIwMDAwMSxcbiAgICBtYXJnaW46IDE4NC4xLFxuICAgIGZyZWVNYXJnaW46IDcxMjAuMjIsXG4gICAgbGV2ZXJhZ2U6IDEwMCxcbiAgICBtYXJnaW5MZXZlbDogMzk2Ny41ODI4MzU0MlxuICB9O1xuXG4gIGJlZm9yZSgoKSA9PiB7XG4gICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY2xpZW50ID0gbmV3IE1ldGFBcGlXZWJzb2NrZXRDbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJywge2FwcGxpY2F0aW9uOiAnYXBwbGljYXRpb24nLCBcbiAgICAgIGRvbWFpbjogJ3Byb2plY3Qtc3RvY2suYWdpbGl1bWxhYnMuY2xvdWQnLCByZXF1ZXN0VGltZW91dDogMS41LCB1c2VTaGFyZWRDbGllbnRBcGk6IHRydWUsXG4gICAgICByZXRyeU9wdHM6IHtyZXRyaWVzOiAzLCBtaW5EZWxheUluU2Vjb25kczogMC4xLCBtYXhEZWxheUluU2Vjb25kczogMC41fX0pO1xuICAgIGNsaWVudC51cmwgPSAnaHR0cDovL2xvY2FsaG9zdDo2Nzg0JztcbiAgICBpbyA9IG5ldyBTZXJ2ZXIoNjc4NCwge3BhdGg6ICcvd3MnLCBwaW5nVGltZW91dDogMTAwMDAwMH0pO1xuICAgIGlvLm9uKCdjb25uZWN0Jywgc29ja2V0ID0+IHtcbiAgICAgIHNlcnZlciA9IHNvY2tldDtcbiAgICAgIGlmIChzb2NrZXQucmVxdWVzdC5fcXVlcnlbJ2F1dGgtdG9rZW4nXSAhPT0gJ3Rva2VuJykge1xuICAgICAgICBzb2NrZXQuZW1pdCh7ZXJyb3I6ICdVbmF1dGhvcml6ZWRFcnJvcicsIG1lc3NhZ2U6ICdBdXRob3JpemF0aW9uIHRva2VuIGludmFsaWQnfSk7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNsaWVudC5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyA9IHthY2NvdW50SWQ6IDB9O1xuICAgIGF3YWl0IGNsaWVudC5jb25uZWN0KCk7XG4gICAgc2FuZGJveC5zdHViKGNsaWVudC5fc29ja2V0SW5zdGFuY2VzWzBdLnN5bmNocm9uaXphdGlvblRocm90dGxlciwgJ2FjdGl2ZVN5bmNocm9uaXphdGlvbklkcycpLmdldCgoKSA9PiBbXSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXMgPT4gcmVzb2x2ZSA9IHJlcyk7XG4gICAgY2xpZW50LmNsb3NlKCk7XG4gICAgaW8uY2xvc2UoKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjX3RyeVJlY29ubmVjdH1cbiAgICovXG4gIGl0KCdzaG91bGQgY2hhbmdlIGNsaWVudCBpZCBvbiByZWNvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzKHtzaG91bGRBZHZhbmNlVGltZTogdHJ1ZX0pO1xuICAgIGNsaWVudC5jbG9zZSgpO1xuICAgIGxldCBjbGllbnRJZDtcbiAgICBsZXQgY29ubmVjdEFtb3VudCA9IDA7XG4gICAgaW8ub24oJ2Nvbm5lY3QnLCBzb2NrZXQgPT4ge1xuICAgICAgY29ubmVjdEFtb3VudCsrO1xuICAgICAgc29ja2V0LnJlcXVlc3QuaGVhZGVyc1snY2xpZW50LWlkJ10uc2hvdWxkLmVxdWFsKHNvY2tldC5yZXF1ZXN0Ll9xdWVyeS5jbGllbnRJZCk7XG4gICAgICBzb2NrZXQucmVxdWVzdC5oZWFkZXJzWydjbGllbnQtaWQnXS5zaG91bGQubm90LmVxdWFsKGNsaWVudElkKTtcbiAgICAgIHNvY2tldC5yZXF1ZXN0Ll9xdWVyeS5jbGllbnRJZC5zaG91bGQubm90LmVxdWFsKGNsaWVudElkKTtcbiAgICAgIGNsaWVudElkID0gc29ja2V0LnJlcXVlc3QuX3F1ZXJ5LmNsaWVudElkO1xuICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTUwMCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIGNvbm5lY3RBbW91bnQuc2hvdWxkLmJlLmFib3ZlT3JFcXVhbCgyKTtcbiAgICBjbG9jay5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfZ2V0U2VydmVyVXJsfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBjb25uZWN0IHRvIGRlZGljYXRlZCBzZXJ2ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHBvc2l0aW9ucyA9IFt7XG4gICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgIHR5cGU6ICdQT1NJVElPTl9UWVBFX0JVWScsXG4gICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICB1cGRhdGVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICBvcGVuUHJpY2U6IDEuMjYxMDEsXG4gICAgICBjdXJyZW50UHJpY2U6IDEuMjQ4ODMsXG4gICAgICBjdXJyZW50VGlja1ZhbHVlOiAxLFxuICAgICAgdm9sdW1lOiAwLjA3LFxuICAgICAgc3dhcDogMCxcbiAgICAgIHByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTY2LFxuICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIHN0b3BMb3NzOiAxLjE3NzIxLFxuICAgICAgdW5yZWFsaXplZFByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTAxLFxuICAgICAgcmVhbGl6ZWRQcm9maXQ6IC02LjUzNjk5MzE2ODk5MjkyMmUtMTNcbiAgICB9XTtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlcyA9PiByZXNvbHZlID0gcmVzKTtcbiAgICBjbGllbnQuY2xvc2UoKTtcbiAgICBpby5jbG9zZSgoKSA9PiByZXNvbHZlKCkpO1xuICAgIGF3YWl0IHByb21pc2U7XG4gICAgaW8gPSBuZXcgU2VydmVyKDY3ODUsIHtwYXRoOiAnL3dzJywgcGluZ1RpbWVvdXQ6IDEwMDAwMDB9KTtcbiAgICBzYW5kYm94LnN0dWIoaHR0cENsaWVudCwgJ3JlcXVlc3QnKS5yZXNvbHZlcyh7dXJsOiAnaHR0cDovL2xvY2FsaG9zdDo2Nzg1J30pO1xuICAgIGNsaWVudCA9IG5ldyBNZXRhQXBpV2Vic29ja2V0Q2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicsIHthcHBsaWNhdGlvbjogJ2FwcGxpY2F0aW9uJywgXG4gICAgICBkb21haW46ICdwcm9qZWN0LXN0b2NrLmFnaWxpdW1sYWJzLmNsb3VkJywgcmVxdWVzdFRpbWVvdXQ6IDEuNSwgdXNlU2hhcmVkQ2xpZW50QXBpOiBmYWxzZSxcbiAgICAgIHJldHJ5T3B0czogeyByZXRyaWVzOiAzLCBtaW5EZWxheUluU2Vjb25kczogMC4xLCBtYXhEZWxheUluU2Vjb25kczogMC41fX0pO1xuICAgIGlvLm9uKCdjb25uZWN0Jywgc29ja2V0ID0+IHtcbiAgICAgIHNlcnZlciA9IHNvY2tldDtcbiAgICAgIGlmIChzb2NrZXQucmVxdWVzdC5fcXVlcnlbJ2F1dGgtdG9rZW4nXSAhPT0gJ3Rva2VuJykge1xuICAgICAgICBzb2NrZXQuZW1pdCh7ZXJyb3I6ICdVbmF1dGhvcml6ZWRFcnJvcicsIG1lc3NhZ2U6ICdBdXRob3JpemF0aW9uIHRva2VuIGludmFsaWQnfSk7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRQb3NpdGlvbnMnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwb3NpdGlvbnN9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRQb3NpdGlvbnMoJ2FjY291bnRJZCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2gocG9zaXRpb25zKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldEFjY291bnRJbmZvcm1hdGlvbn1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBhY2NvdW50IGluZm9ybWF0aW9uIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldEFjY291bnRJbmZvcm1hdGlvbicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLFxuICAgICAgICAgIGFjY291bnRJbmZvcm1hdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldEFjY291bnRJbmZvcm1hdGlvbignYWNjb3VudElkJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaChhY2NvdW50SW5mb3JtYXRpb24pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0UG9zaXRpb25zfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIHBvc2l0aW9ucyBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgcG9zaXRpb25zID0gW3tcbiAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgdHlwZTogJ1BPU0lUSU9OX1RZUEVfQlVZJyxcbiAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICBtYWdpYzogMTAwMCxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgIHVwZGF0ZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgIG9wZW5QcmljZTogMS4yNjEwMSxcbiAgICAgIGN1cnJlbnRQcmljZTogMS4yNDg4MyxcbiAgICAgIGN1cnJlbnRUaWNrVmFsdWU6IDEsXG4gICAgICB2b2x1bWU6IDAuMDcsXG4gICAgICBzd2FwOiAwLFxuICAgICAgcHJvZml0OiAtODUuMjU5OTk5OTk5OTk5NjYsXG4gICAgICBjb21taXNzaW9uOiAtMC4yNSxcbiAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgc3RvcExvc3M6IDEuMTc3MjEsXG4gICAgICB1bnJlYWxpemVkUHJvZml0OiAtODUuMjU5OTk5OTk5OTk5MDEsXG4gICAgICByZWFsaXplZFByb2ZpdDogLTYuNTM2OTkzMTY4OTkyOTIyZS0xM1xuICAgIH1dO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldFBvc2l0aW9ucycgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwb3NpdGlvbnN9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldFBvc2l0aW9ucygnYWNjb3VudElkJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaChwb3NpdGlvbnMpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0UG9zaXRpb259XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgcG9zaXRpb24gZnJvbSBBUEkgYnkgaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHBvc2l0aW9uID0ge1xuICAgICAgaWQ6ICc0NjIxNDY5MicsXG4gICAgICB0eXBlOiAnUE9TSVRJT05fVFlQRV9CVVknLFxuICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgdXBkYXRlVGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgb3BlblByaWNlOiAxLjI2MTAxLFxuICAgICAgY3VycmVudFByaWNlOiAxLjI0ODgzLFxuICAgICAgY3VycmVudFRpY2tWYWx1ZTogMSxcbiAgICAgIHZvbHVtZTogMC4wNyxcbiAgICAgIHN3YXA6IDAsXG4gICAgICBwcm9maXQ6IC04NS4yNTk5OTk5OTk5OTk2NixcbiAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICBzdG9wTG9zczogMS4xNzcyMSxcbiAgICAgIHVucmVhbGl6ZWRQcm9maXQ6IC04NS4yNTk5OTk5OTk5OTkwMSxcbiAgICAgIHJlYWxpemVkUHJvZml0OiAtNi41MzY5OTMxNjg5OTI5MjJlLTEzXG4gICAgfTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRQb3NpdGlvbicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEucG9zaXRpb25JZCA9PT0gJzQ2MjE0NjkyJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcG9zaXRpb259KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldFBvc2l0aW9uKCdhY2NvdW50SWQnLCAnNDYyMTQ2OTInKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHBvc2l0aW9uKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldE9yZGVyc31cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBvcmRlcnMgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IG9yZGVycyA9IFt7XG4gICAgICBpZDogJzQ2ODcxMjg0JyxcbiAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICBzdGF0ZTogJ09SREVSX1NUQVRFX1BMQUNFRCcsXG4gICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTIwVDA4OjM4OjU4LjI3MFonKSxcbiAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgIGN1cnJlbnRQcmljZTogMS4wNTIwNixcbiAgICAgIHZvbHVtZTogMC4wMSxcbiAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICBjb21tZW50OiAnQ09NTUVOVDInXG4gICAgfV07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0T3JkZXJzJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIG9yZGVyc30pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0T3JkZXJzKCdhY2NvdW50SWQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKG9yZGVycyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRPcmRlcn1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBvcmRlciBmcm9tIEFQSSBieSBpZCcsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgb3JkZXIgPSB7XG4gICAgICBpZDogJzQ2ODcxMjg0JyxcbiAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICBzdGF0ZTogJ09SREVSX1NUQVRFX1BMQUNFRCcsXG4gICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTIwVDA4OjM4OjU4LjI3MFonKSxcbiAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgIGN1cnJlbnRQcmljZTogMS4wNTIwNixcbiAgICAgIHZvbHVtZTogMC4wMSxcbiAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICBjb21tZW50OiAnQ09NTUVOVDInXG4gICAgfTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRPcmRlcicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEub3JkZXJJZCA9PT0gJzQ2ODcxMjg0JyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgb3JkZXJ9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldE9yZGVyKCdhY2NvdW50SWQnLCAnNDY4NzEyODQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKG9yZGVyKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldEhpc3RvcnlPcmRlcnNCeVRpY2tldH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBoaXN0b3J5IG9yZGVycyBmcm9tIEFQSSBieSB0aWNrZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGhpc3RvcnlPcmRlcnMgPSBbe1xuICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICBjdXJyZW50UHJpY2U6IDEuMjYxLFxuICAgICAgY3VycmVudFZvbHVtZTogMCxcbiAgICAgIGRvbmVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfRklMTEVEJyxcbiAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi4yNjBaJyksXG4gICAgICB0eXBlOiAnT1JERVJfVFlQRV9CVVknLFxuICAgICAgdm9sdW1lOiAwLjA3XG4gICAgfV07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0JyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS50aWNrZXQgPT09ICc0NjIxNDY5MicgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge1xuICAgICAgICAgIHR5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGhpc3RvcnlPcmRlcnMsXG4gICAgICAgICAgc3luY2hyb25pemluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQoJ2FjY291bnRJZCcsICc0NjIxNDY5MicpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goe2hpc3RvcnlPcmRlcnMsIHN5bmNocm9uaXppbmc6IGZhbHNlfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbn1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBoaXN0b3J5IG9yZGVycyBmcm9tIEFQSSBieSBwb3NpdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgaGlzdG9yeU9yZGVycyA9IFt7XG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIGN1cnJlbnRQcmljZTogMS4yNjEsXG4gICAgICBjdXJyZW50Vm9sdW1lOiAwLFxuICAgICAgZG9uZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICBwb3NpdGlvbklkOiAnNDYyMTQ2OTInLFxuICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9GSUxMRUQnLFxuICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjI2MFonKSxcbiAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWScsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmXG4gICAgICAgIGRhdGEucG9zaXRpb25JZCA9PT0gJzQ2MjE0NjkyJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7XG4gICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgaGlzdG9yeU9yZGVycyxcbiAgICAgICAgICBzeW5jaHJvbml6aW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKCdhY2NvdW50SWQnLCAnNDYyMTQ2OTInKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHtoaXN0b3J5T3JkZXJzLCBzeW5jaHJvbml6aW5nOiBmYWxzZX0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIGhpc3Rvcnkgb3JkZXJzIGZyb20gQVBJIGJ5IHRpbWUgcmFuZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGhpc3RvcnlPcmRlcnMgPSBbe1xuICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICBjdXJyZW50UHJpY2U6IDEuMjYxLFxuICAgICAgY3VycmVudFZvbHVtZTogMCxcbiAgICAgIGRvbmVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfRklMTEVEJyxcbiAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi4yNjBaJyksXG4gICAgICB0eXBlOiAnT1JERVJfVFlQRV9CVVknLFxuICAgICAgdm9sdW1lOiAwLjA3XG4gICAgfV07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgZGF0YS5zdGFydFRpbWUgPT09ICcyMDIwLTA0LTE1VDAyOjQ1OjAwLjAwMFonICYmIGRhdGEuZW5kVGltZSA9PT0gJzIwMjAtMDQtMTVUMDI6NDY6MDAuMDAwWicgJiZcbiAgICAgICAgZGF0YS5vZmZzZXQgPT09IDEgJiYgZGF0YS5saW1pdCA9PT0gMTAwICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBoaXN0b3J5T3JkZXJzLFxuICAgICAgICAgIHN5bmNocm9uaXppbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlKCdhY2NvdW50SWQnLCBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowMC4wMDBaJyksXG4gICAgICBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NjowMC4wMDBaJyksIDEsIDEwMCk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaCh7aGlzdG9yeU9yZGVycywgc3luY2hyb25pemluZzogZmFsc2V9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldERlYWxzQnlUaWNrZXR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgZGVhbHMgZnJvbSBBUEkgYnkgdGlja2V0JywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBkZWFscyA9IFt7XG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgZW50cnlUeXBlOiAnREVBTF9FTlRSWV9JTicsXG4gICAgICBpZDogJzMzMjMwMDk5JyxcbiAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgb3JkZXJJZDogJzQ2MjE0NjkyJyxcbiAgICAgIHBvc2l0aW9uSWQ6ICc0NjIxNDY5MicsXG4gICAgICBwcmljZTogMS4yNjEwMSxcbiAgICAgIHByb2ZpdDogMCxcbiAgICAgIHN3YXA6IDAsXG4gICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgdHlwZTogJ0RFQUxfVFlQRV9CVVknLFxuICAgICAgdm9sdW1lOiAwLjA3XG4gICAgfV07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0RGVhbHNCeVRpY2tldCcgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEudGlja2V0ID09PSAnNDYyMTQ2OTInICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBkZWFscyxcbiAgICAgICAgICBzeW5jaHJvbml6aW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldERlYWxzQnlUaWNrZXQoJ2FjY291bnRJZCcsICc0NjIxNDY5MicpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goe2RlYWxzLCBzeW5jaHJvbml6aW5nOiBmYWxzZX0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0RGVhbHNCeVBvc2l0aW9ufVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIGRlYWxzIGZyb20gQVBJIGJ5IHBvc2l0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBkZWFscyA9IFt7XG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgZW50cnlUeXBlOiAnREVBTF9FTlRSWV9JTicsXG4gICAgICBpZDogJzMzMjMwMDk5JyxcbiAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgb3JkZXJJZDogJzQ2MjE0NjkyJyxcbiAgICAgIHBvc2l0aW9uSWQ6ICc0NjIxNDY5MicsXG4gICAgICBwcmljZTogMS4yNjEwMSxcbiAgICAgIHByb2ZpdDogMCxcbiAgICAgIHN3YXA6IDAsXG4gICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgdHlwZTogJ0RFQUxfVFlQRV9CVVknLFxuICAgICAgdm9sdW1lOiAwLjA3XG4gICAgfV07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0RGVhbHNCeVBvc2l0aW9uJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5wb3NpdGlvbklkID09PSAnNDYyMTQ2OTInICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBkZWFscyxcbiAgICAgICAgICBzeW5jaHJvbml6aW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldERlYWxzQnlQb3NpdGlvbignYWNjb3VudElkJywgJzQ2MjE0NjkyJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaCh7ZGVhbHMsIHN5bmNocm9uaXppbmc6IGZhbHNlfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXREZWFsc0J5VGltZVJhbmdlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIGRlYWxzIGZyb20gQVBJIGJ5IHRpbWUgcmFuZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGRlYWxzID0gW3tcbiAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICBlbnRyeVR5cGU6ICdERUFMX0VOVFJZX0lOJyxcbiAgICAgIGlkOiAnMzMyMzAwOTknLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICBvcmRlcklkOiAnNDYyMTQ2OTInLFxuICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgIHByaWNlOiAxLjI2MTAxLFxuICAgICAgcHJvZml0OiAwLFxuICAgICAgc3dhcDogMCxcbiAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICB0eXBlOiAnREVBTF9UWVBFX0JVWScsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXREZWFsc0J5VGltZVJhbmdlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgZGF0YS5zdGFydFRpbWUgPT09ICcyMDIwLTA0LTE1VDAyOjQ1OjAwLjAwMFonICYmIGRhdGEuZW5kVGltZSA9PT0gJzIwMjAtMDQtMTVUMDI6NDY6MDAuMDAwWicgJiZcbiAgICAgICAgZGF0YS5vZmZzZXQgPT09IDEgJiYgZGF0YS5saW1pdCA9PT0gMTAwICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBkZWFscyxcbiAgICAgICAgICBzeW5jaHJvbml6aW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldERlYWxzQnlUaW1lUmFuZ2UoJ2FjY291bnRJZCcsIG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjAwLjAwMFonKSxcbiAgICAgIG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ2OjAwLjAwMFonKSwgMSwgMTAwKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHtkZWFscywgc3luY2hyb25pemluZzogZmFsc2V9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3JlbW92ZUhpc3Rvcnl9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJlbW92ZSBoaXN0b3J5IGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdyZW1vdmVIaXN0b3J5JyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcCcpIHtcbiAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQucmVtb3ZlSGlzdG9yeSgnYWNjb3VudElkJywgJ2FwcCcpO1xuICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjcmVtb3ZlQXBwbGljYXRpb259XG4gICAqL1xuICBpdCgnc2hvdWxkIHJlbW92ZSBhcHBsaWNhdGlvbiBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAncmVtb3ZlQXBwbGljYXRpb24nICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHJlcXVlc3RSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgY2xpZW50LnJlbW92ZUFwcGxpY2F0aW9uKCdhY2NvdW50SWQnKTtcbiAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3RyYWRlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBleGVjdXRlIGEgdHJhZGUgdmlhIG5ldyBBUEkgdmVyc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgdHJhZGUgPSB7XG4gICAgICBhY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMJyxcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9O1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIG51bWVyaWNDb2RlOiAxMDAwOSxcbiAgICAgIHN0cmluZ0NvZGU6ICdUUkFERV9SRVRDT0RFX0RPTkUnLFxuICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgY29tcGxldGVkJyxcbiAgICAgIG9yZGVySWQ6ICc0Njg3MDQ3MidcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgZGF0YS50cmFkZS5zaG91bGQubWF0Y2godHJhZGUpO1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcmVzcG9uc2V9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LnRyYWRlKCdhY2NvdW50SWQnLCB0cmFkZSk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaChyZXNwb25zZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCN0cmFkZX1cbiAgICovXG4gIGl0KCdzaG91bGQgZXhlY3V0ZSBhIHRyYWRlIHZpYSBBUEkgYW5kIHJlY2VpdmUgdHJhZGUgZXJyb3IgZnJvbSBvbGQgQVBJIHZlcnNpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHRyYWRlID0ge1xuICAgICAgYWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTCcsXG4gICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgdm9sdW1lOiAwLjA3XG4gICAgfTtcbiAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICBlcnJvcjogMTAwMDYsXG4gICAgICBkZXNjcmlwdGlvbjogJ1RSQURFX1JFVENPREVfUkVKRUNUJyxcbiAgICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IHJlamVjdGVkJyxcbiAgICAgIG9yZGVySWQ6ICc0Njg3MDQ3MidcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgZGF0YS50cmFkZS5zaG91bGQubWF0Y2godHJhZGUpO1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcmVzcG9uc2V9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2xpZW50LnRyYWRlKCdhY2NvdW50SWQnLCB0cmFkZSk7XG4gICAgICBzaG91bGQuZmFpbCgnVHJhZGUgZXJyb3IgZXhwZWN0ZWQnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcXVhbCgnUmVxdWVzdCByZWplY3RlZCcpO1xuICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdUcmFkZUVycm9yJyk7XG4gICAgICBlcnIuc3RyaW5nQ29kZS5zaG91bGQuZXF1YWwoJ1RSQURFX1JFVENPREVfUkVKRUNUJyk7XG4gICAgICBlcnIubnVtZXJpY0NvZGUuc2hvdWxkLmVxdWFsKDEwMDA2KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNzdWJzY3JpYmV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGNvbm5lY3QgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCcsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnc3Vic2NyaWJlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJyAmJlxuICAgICAgICBkYXRhLmluc3RhbmNlSW5kZXggPT09IDEpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQuc3Vic2NyaWJlKCdhY2NvdW50SWQnLCAxKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgcmVxdWVzdFJlY2VpdmVkLnNob3VsZC5iZS50cnVlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNzdWJzY3JpYmV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugd2hlbiBhY2NvdW50IGxpbWl0IGlzIHJlYWNoZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgc2lub24uYXNzZXJ0Lm1hdGNoKGNsaWVudC5zb2NrZXRJbnN0YW5jZXMubGVuZ3RoLCAxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICBjbGllbnQuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbJ2FjY291bnRJZCcgKyBpXSA9IDA7XG4gICAgfVxuXG4gICAgaW8ucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb25uZWN0Jyk7XG4gICAgaW8ub24oJ2Nvbm5lY3QnLCBzb2NrZXQgPT4ge1xuICAgICAgc29ja2V0Lm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdzdWJzY3JpYmUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkMTAxJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmXG4gICAgICAgICAgZGF0YS5pbnN0YW5jZUluZGV4ID09PSAxKSB7XG4gICAgICAgICAgc29ja2V0LmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYXdhaXQgY2xpZW50LnN1YnNjcmliZSgnYWNjb3VudElkMTAxJywgMSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIHNpbm9uLmFzc2VydC5tYXRjaChjbGllbnQuc29ja2V0SW5zdGFuY2VzLmxlbmd0aCwgMik7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNzdWJzY3JpYmV9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHVybiBlcnJvciBpZiBjb25uZWN0IHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZmFpbGVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdzdWJzY3JpYmUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHJlcXVlc3RSZWNlaXZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICBpZDogMSwgZXJyb3I6ICdOb3RBdXRoZW50aWNhdGVkRXJyb3InLCBtZXNzYWdlOiAnRXJyb3IgbWVzc2FnZScsXG4gICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2xpZW50LnN1YnNjcmliZSgnYWNjb3VudElkJyk7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ05vdENvbm5lY3RlZEVycm9yJyk7XG4gICAgfVxuICAgIHN1Y2Nlc3Muc2hvdWxkLmJlLnRydWUoKTtcbiAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3JlY29ubmVjdH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVjb25uZWN0IHRvIE1ldGFUcmFkZXIgdGVybWluYWwnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3JlY29ubmVjdCcgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQucmVjb25uZWN0KCdhY2NvdW50SWQnKTtcbiAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldFN5bWJvbHN9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHN5bWJvbHMgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHN5bWJvbHMgPSBbJ0VVUlVTRCddO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldFN5bWJvbHMnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7XG4gICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgc3ltYm9sc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldFN5bWJvbHMoJ2FjY291bnRJZCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goc3ltYm9scyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRTeW1ib2xTcGVjaWZpY2F0aW9ufVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBzeW1ib2wgc3BlY2lmaWNhdGlvbiBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgc3BlY2lmaWNhdGlvbiA9IHtcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICB0aWNrU2l6ZTogMC4wMDAwMSxcbiAgICAgIG1pblZvbHVtZTogMC4wMSxcbiAgICAgIG1heFZvbHVtZTogMTAwLFxuICAgICAgdm9sdW1lU3RlcDogMC4wMVxuICAgIH07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnQVVETlpEJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7XG4gICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICBzcGVjaWZpY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbignYWNjb3VudElkJywgJ0FVRE5aRCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goc3BlY2lmaWNhdGlvbik7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRTeW1ib2xQcmljZX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgc3ltYm9sIHByaWNlIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBwcmljZSA9IHtcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICBiaWQ6IDEuMDUyOTcsXG4gICAgICBhc2s6IDEuMDUzMDksXG4gICAgICBwcm9maXRUaWNrVmFsdWU6IDAuNTk3MzEsXG4gICAgICBsb3NzVGlja1ZhbHVlOiAwLjU5NzM2XG4gICAgfTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRTeW1ib2xQcmljZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnQVVETlpEJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcHJpY2V9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldFN5bWJvbFByaWNlKCdhY2NvdW50SWQnLCAnQVVETlpEJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaChwcmljZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRDYW5kbGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIGNhbmRsZSBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgY2FuZGxlID0ge1xuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIHRpbWVmcmFtZTogJzE1bScsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0wN1QwMzo0NTowMC4wMDBaJyksXG4gICAgICBicm9rZXJUaW1lOiAnMjAyMC0wNC0wNyAwNjo0NTowMC4wMDAnLFxuICAgICAgb3BlbjogMS4wMzI5NyxcbiAgICAgIGhpZ2g6IDEuMDYzMDksXG4gICAgICBsb3c6IDEuMDI3MDUsXG4gICAgICBjbG9zZTogMS4wNDMsXG4gICAgICB0aWNrVm9sdW1lOiAxNDM1LFxuICAgICAgc3ByZWFkOiAxNyxcbiAgICAgIHZvbHVtZTogMzQ1XG4gICAgfTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRDYW5kbGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnN5bWJvbCA9PT0gJ0FVRE5aRCcgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycgJiYgZGF0YS50aW1lZnJhbWUgPT09ICcxNW0nKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBjYW5kbGV9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldENhbmRsZSgnYWNjb3VudElkJywgJ0FVRE5aRCcsICcxNW0nKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKGNhbmRsZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRUaWNrfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBsYXRlc3QgdGljayBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgdGljayA9IHtcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0wN1QwMzo0NTowMC4wMDBaJyksXG4gICAgICBicm9rZXJUaW1lOiAnMjAyMC0wNC0wNyAwNjo0NTowMC4wMDAnLFxuICAgICAgYmlkOiAxLjA1Mjk3LFxuICAgICAgYXNrOiAxLjA1MzA5LFxuICAgICAgbGFzdDogMC41Mjk4LFxuICAgICAgdm9sdW1lOiAwLjEzLFxuICAgICAgc2lkZTogJ2J1eSdcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldFRpY2snICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnN5bWJvbCA9PT0gJ0FVRE5aRCcgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHRpY2t9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldFRpY2soJ2FjY291bnRJZCcsICdBVUROWkQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHRpY2spO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0Qm9va31cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgbGF0ZXN0IG9yZGVyIGJvb2sgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGJvb2sgPSB7XG4gICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMDdUMDM6NDU6MDAuMDAwWicpLFxuICAgICAgYnJva2VyVGltZTogJzIwMjAtMDQtMDcgMDY6NDU6MDAuMDAwJyxcbiAgICAgIGJvb2s6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdCT09LX1RZUEVfU0VMTCcsXG4gICAgICAgICAgcHJpY2U6IDEuMDUzMDksXG4gICAgICAgICAgdm9sdW1lOiA1LjY3XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnQk9PS19UWVBFX0JVWScsXG4gICAgICAgICAgcHJpY2U6IDEuMDUyOTcsXG4gICAgICAgICAgdm9sdW1lOiAzLjQ1XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldEJvb2snICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnN5bWJvbCA9PT0gJ0FVRE5aRCcgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGJvb2t9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldEJvb2soJ2FjY291bnRJZCcsICdBVUROWkQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKGJvb2spO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjc2VuZFVwdGltZX1cbiAgICovXG4gIGl0KCdzaG91bGQgc2VudCB1cHRpbWUgc3RhdHMgdG8gdGhlIHNlcnZlcicsIGFzeW5jICgpID0+IHtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdzYXZlVXB0aW1lJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YS51cHRpbWUpID09PSBKU09OLnN0cmluZ2lmeSh7JzFoJzogMTAwfSkgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IGNsaWVudC5zYXZlVXB0aW1lKCdhY2NvdW50SWQnLCB7JzFoJzogMTAwfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCN1bnN1YnNjcmliZX1cbiAgICovXG4gIGl0KCdzaG91bGQgdW5zdWJzY3JpYmUgZnJvbSBhY2NvdW50IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuXG4gICAgbGV0IHJlc3BvbnNlID0ge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogJ2FjY291bnRJZCd9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3Vuc3Vic2NyaWJlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcpIHtcbiAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywgT2JqZWN0LmFzc2lnbih7cmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0sIHJlc3BvbnNlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgY2xpZW50LnVuc3Vic2NyaWJlKCdhY2NvdW50SWQnKTtcbiAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVxdWVzdFJlY2VpdmVkLCB0cnVlKTtcbiAgICBjbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cy5zaG91bGQubm90LmhhdmUucHJvcGVydHkoJ2FjY291bnRJZCcpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjdW5zdWJzY3JpYmV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGlnbm9yZSBub3QgZm91bmQgZXhjZXB0aW9uIG9uIHVuc3Vic2NyaWJlJywgYXN5bmMgKCkgPT4ge1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgaWQ6IDEsIGVycm9yOiAnVmFsaWRhdGlvbkVycm9yJywgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgZGV0YWlsczogW3twYXJhbWV0ZXI6ICd2b2x1bWUnLCBtZXNzYWdlOiAnUmVxdWlyZWQgdmFsdWUuJ31dLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2xpZW50LnVuc3Vic2NyaWJlKCdhY2NvdW50SWQnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbkVycm9yIGV4dGVjdGVkJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ1ZhbGlkYXRpb25FcnJvcicpO1xuICAgICAgZXJyLmRldGFpbHMuc2hvdWxkLm1hdGNoKFt7XG4gICAgICAgIHBhcmFtZXRlcjogJ3ZvbHVtZScsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXF1aXJlZCB2YWx1ZS4nXG4gICAgICB9XSk7XG4gICAgfVxuICAgIHNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlcXVlc3QnKTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgIGlkOiAxLCBlcnJvcjogJ05vdEZvdW5kRXJyb3InLCBtZXNzYWdlOiAnQWNjb3VudCBub3QgZm91bmQnLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQudW5zdWJzY3JpYmUoJ2FjY291bnRJZCcpO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCN0cmFkZX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBWYWxpZGF0aW9uRXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgdHJhZGUgPSB7XG4gICAgICAgIGFjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLFxuICAgICAgICBzeW1ib2w6ICdBVUROWkQnXG4gICAgICB9O1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgaWQ6IDEsIGVycm9yOiAnVmFsaWRhdGlvbkVycm9yJywgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICBkZXRhaWxzOiBbe3BhcmFtZXRlcjogJ3ZvbHVtZScsIG1lc3NhZ2U6ICdSZXF1aXJlZCB2YWx1ZS4nfV0sIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC50cmFkZSgnYWNjb3VudElkJywgdHJhZGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb25FcnJvciBleHRlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnVmFsaWRhdGlvbkVycm9yJyk7XG4gICAgICAgIGVyci5kZXRhaWxzLnNob3VsZC5tYXRjaChbe1xuICAgICAgICAgIHBhcmFtZXRlcjogJ3ZvbHVtZScsXG4gICAgICAgICAgbWVzc2FnZTogJ1JlcXVpcmVkIHZhbHVlLidcbiAgICAgICAgfV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0UG9zaXRpb259XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgTm90Rm91bmRFcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICAgIGlkOiAxLCBlcnJvcjogJ05vdEZvdW5kRXJyb3InLCBtZXNzYWdlOiAnUG9zaXRpb24gaWQgMTIzNCBub3QgZm91bmQnLFxuICAgICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5nZXRQb3NpdGlvbignYWNjb3VudElkJywgJzEyMzQnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3RGb3VuZEVycm9yIGV4dGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdOb3RGb3VuZEVycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRQb3NpdGlvbn1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBOb3RTeW5jaHJvbml6ZWRFcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICAgIGlkOiAxLCBlcnJvcjogJ05vdFN5bmNocm9uaXplZEVycm9yJywgbWVzc2FnZTogJ0Vycm9yIG1lc3NhZ2UnLFxuICAgICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5nZXRQb3NpdGlvbignYWNjb3VudElkJywgJzEyMzQnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3RTeW5jaHJvbml6ZWRFcnJvciBleHRlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnTm90U3luY2hyb25pemVkRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KS50aW1lb3V0KDgwMDApO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0UG9zaXRpb259XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgTm90Q29ubmVjdGVkRXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgICBpZDogMSwgZXJyb3I6ICdOb3RBdXRoZW50aWNhdGVkRXJyb3InLCBtZXNzYWdlOiAnRXJyb3IgbWVzc2FnZScsXG4gICAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmdldFBvc2l0aW9uKCdhY2NvdW50SWQnLCAnMTIzNCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdENvbm5lY3RlZEVycm9yIGV4dGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdOb3RDb25uZWN0ZWRFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0UG9zaXRpb259XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgb3RoZXIgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgaWQ6IDEsIGVycm9yOiAnRXJyb3InLCBtZXNzYWdlOiAnRXJyb3IgbWVzc2FnZScsXG4gICAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmdldFBvc2l0aW9uKCdhY2NvdW50SWQnLCAnMTIzNCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsRXJyb3IgZXh0ZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ0ludGVybmFsRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KS50aW1lb3V0KDgwMDApO1xuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjb25uZWN0aW9uIHN0YXR1cyBzeW5jaHJvbml6YXRpb24nLCAoKSA9PiB7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIGF1dGhlbnRpY2F0ZWQgc3luY2hyb25pemF0aW9uIGV2ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25Db25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDJ9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uQ29ubmVjdGVkLCAnMTpwcy1tcGEtMScsIDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIGF1dGhlbnRpY2F0ZWQgc3luY2hyb25pemF0aW9uIGV2ZW50IHdpdGggc2Vzc2lvbiBpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uQ29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDIsIHJlcGxpY2FzOiA0LCBzZXNzaW9uSWQ6ICd3cm9uZyd9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxLCByZXBsaWNhczogMiwgc2Vzc2lvbklkOiBjbGllbnQuX3Nlc3Npb25JZH0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxDb3VudChsaXN0ZW5lci5vbkNvbm5lY3RlZCwgMSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkNvbm5lY3RlZCwgJzE6cHMtbXBhLTEnLCAyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBicm9rZXIgY29ubmVjdGlvbiBzdGF0dXMgZXZlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZDogKCkgPT4ge31cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZCwgJzE6cHMtbXBhLTEnLCB0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2FsbCBhbiBvbkRpc2Nvbm5lY3QgaWYgdGhlcmUgd2FzIG5vIHNpZ25hbCBmb3IgYSBsb25nIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbG9jayA9IHNpbm9uLnVzZUZha2VUaW1lcnMoe3Nob3VsZEFkdmFuY2VUaW1lOiB0cnVlfSk7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25EaXNjb25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkOiAoKSA9PiB7fVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uRGlzY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIHJlcGxpY2FzOiAyfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYygxMDAwMCk7XG4gICAgICBhd2FpdCBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYyg1NTAwMCk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxLCByZXBsaWNhczogMn0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDEwMDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQobGlzdGVuZXIub25EaXNjb25uZWN0ZWQpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDU1MDAwKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkLCAnMTpwcy1tcGEtMScpO1xuICAgICAgY2xvY2sucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjbG9zZSBzdHJlYW0gb24gdGltZW91dCBpZiBhbm90aGVyIHN0cmVhbSBleGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbG9jayA9IHNpbm9uLnVzZUZha2VUaW1lcnMoe3Nob3VsZEFkdmFuY2VUaW1lOiB0cnVlfSk7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25EaXNjb25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvblN0cmVhbUNsb3NlZDogKCkgPT4ge30sXG4gICAgICAgIG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQ6ICgpID0+IHt9XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25UaW1lb3V0U3R1YiA9IHNhbmRib3guc3R1YihjbGllbnQuX3N1YnNjcmlwdGlvbk1hbmFnZXIsICdvblRpbWVvdXQnKS5yZXNvbHZlcygpO1xuICAgICAgY29uc3Qgb25TdHJlYW1DbG9zZWRTdHViID0gc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25TdHJlYW1DbG9zZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY29uc3Qgb25EaXNjb25uZWN0ZWRTdHViID0gc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25EaXNjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGNsaWVudC5fc3Vic2NyaXB0aW9uTWFuYWdlciwgJ29uRGlzY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIHJlcGxpY2FzOiAyfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTUwMDApO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMicsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIHJlcGxpY2FzOiAyfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMicsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDE1MDAwKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3RhdHVzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0yJywgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoNTUwMDApO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChvbkRpc2Nvbm5lY3RlZFN0dWIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3RhdHVzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJywgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTInLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYygxNTAwMCk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTInLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQob25EaXNjb25uZWN0ZWRTdHViKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYyg1NTAwMCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChvblN0cmVhbUNsb3NlZFN0dWIsICcxOnBzLW1wYS0xJyk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKG9uRGlzY29ubmVjdGVkU3R1Yik7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKG9uVGltZW91dFN0dWIpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDE1MDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKG9uRGlzY29ubmVjdGVkU3R1YiwgJzE6cHMtbXBhLTInKTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQoY2xpZW50Ll9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKG9uVGltZW91dFN0dWIsICdhY2NvdW50SWQnLCAxKTtcbiAgICAgIGNsb2NrLnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBzZXJ2ZXItc2lkZSBoZWFsdGggc3RhdHVzIGV2ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4ge30sXG4gICAgICAgIG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkhlYWx0aFN0YXR1czogKCkgPT4ge31cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkhlYWx0aFN0YXR1cycpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGhlYWx0aFN0YXR1czoge3Jlc3RBcGlIZWFsdGh5OiB0cnVlfSwgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25IZWFsdGhTdGF0dXMsICcxOnBzLW1wYS0xJywge3Jlc3RBcGlIZWFsdGh5OiB0cnVlfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgZGlzY29ubmVjdGVkIHN5bmNocm9uaXphdGlvbiBldmVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkRpc2Nvbm5lY3RlZDogKCkgPT4ge31cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkRpc2Nvbm5lY3RlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdkaXNjb25uZWN0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkRpc2Nvbm5lY3RlZCwgJzE6cHMtbXBhLTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xvc2UgdGhlIHN0cmVhbSBpZiBob3N0IG5hbWUgZGlzY29ubmVjdGVkIGFuZCBhbm90aGVyIHN0cmVhbSBleGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25EaXNjb25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvblN0cmVhbUNsb3NlZDogKCkgPT4ge30sXG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25EaXNjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25TdHJlYW1DbG9zZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY29uc3Qgb25EaXNjb25uZWN0ZWRTdHViID0gc2FuZGJveC5zdHViKGNsaWVudC5fc3Vic2NyaXB0aW9uTWFuYWdlciwgJ29uRGlzY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIHJlcGxpY2FzOiAyfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0yJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDJ9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2Rpc2Nvbm5lY3RlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uU3RyZWFtQ2xvc2VkLCAnMTpwcy1tcGEtMScpO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChsaXN0ZW5lci5vbkRpc2Nvbm5lY3RlZCk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKG9uRGlzY29ubmVjdGVkU3R1Yik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdkaXNjb25uZWN0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTInLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShsaXN0ZW5lci5vbkRpc2Nvbm5lY3RlZCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChvbkRpc2Nvbm5lY3RlZFN0dWIsICdhY2NvdW50SWQnLCAxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3Rlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbicsICgpID0+IHtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBjbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG9ubHkgYWNjZXB0IHBhY2tldHMgd2l0aCBvd24gc3luY2hyb25pemF0aW9uIGlkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkOiAoKSA9PiB7fSxcbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzYW5kYm94LnN0dWIoY2xpZW50Ll9zb2NrZXRJbnN0YW5jZXNbMF0uc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLCBcbiAgICAgICAgJ2FjdGl2ZVN5bmNocm9uaXphdGlvbklkcycpLmdldCgoKSA9PiBbJ3N5bmNocm9uaXphdGlvbklkJ10pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgXG4gICAgICAgIGFjY291bnRJbmZvcm1hdGlvbjoge30sIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsQ291bnQobGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkLCAxKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2FjY291bnRJbmZvcm1hdGlvbicsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIFxuICAgICAgICBhY2NvdW50SW5mb3JtYXRpb246IHt9LCBpbnN0YW5jZUluZGV4OiAxLCBzeW5jaHJvbml6YXRpb25JZDogJ3dyb25nJ30pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxDb3VudChsaXN0ZW5lci5vbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQsIDEpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgXG4gICAgICAgIGFjY291bnRJbmZvcm1hdGlvbjoge30sIGluc3RhbmNlSW5kZXg6IDEsIHN5bmNocm9uaXphdGlvbklkOiAnc3luY2hyb25pemF0aW9uSWQnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbENvdW50KGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCwgMik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNzeW5jaHJvbml6ZX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIHdpdGggTWV0YVRyYWRlciB0ZXJtaW5hbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bmNocm9uaXplJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgICBkYXRhLmhvc3QgPT09ICdwcy1tcGEtMScgJiZcbiAgICAgICAgICBkYXRhLnN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSA9PT0gJzIwMjAtMDEtMDFUMDA6MDA6MDAuMDAwWicgJiZcbiAgICAgICAgICBkYXRhLnN0YXJ0aW5nRGVhbFRpbWUgPT09ICcyMDIwLTAxLTAyVDAwOjAwOjAwLjAwMFonICYmIGRhdGEucmVxdWVzdElkID09PSAnc3luY2hyb25pemF0aW9uSWQnICYmXG4gICAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBkYXRhLmluc3RhbmNlSW5kZXggPT09IDEpIHtcbiAgICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgY2xpZW50LnN5bmNocm9uaXplKCdhY2NvdW50SWQnLCAxLCAncHMtbXBhLTEnLCAnc3luY2hyb25pemF0aW9uSWQnLCBuZXcgRGF0ZSgnMjAyMC0wMS0wMVQwMDowMDowMC4wMDBaJyksXG4gICAgICAgIG5ldyBEYXRlKCcyMDIwLTAxLTAyVDAwOjAwOjAwLjAwMFonKSwgZW1wdHlIYXNoLCBlbXB0eUhhc2gsIGVtcHR5SGFzaCk7XG4gICAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBzeW5jaHJvbml6YXRpb24gc3RhcnRlZCBldmVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNsaWVudC5fc29ja2V0SW5zdGFuY2VzWzBdLnN5bmNocm9uaXphdGlvblRocm90dGxlciA9IHN5bmNocm9uaXphdGlvblRocm90dGxlcjtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25TeW5jaHJvbml6YXRpb25TdGFydGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uU3luY2hyb25pemF0aW9uU3RhcnRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblBvc2l0aW9uc1N5bmNocm9uaXplZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzeW5jaHJvbml6YXRpb25TdGFydGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaW5zdGFuY2VJbmRleDogMSxcbiAgICAgICAgc3luY2hyb25pemF0aW9uSWQ6ICdzeW5jaHJvbml6YXRpb25JZCcsIGhvc3Q6ICdwcy1tcGEtMSd9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2FjY291bnRJbmZvcm1hdGlvbicsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIFxuICAgICAgICBhY2NvdW50SW5mb3JtYXRpb24sIGluc3RhbmNlSW5kZXg6IDEsIGhvc3Q6ICdwcy1tcGEtMScsIHN5bmNocm9uaXphdGlvbklkOiAnc3luY2hyb25pemF0aW9uSWQnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25TeW5jaHJvbml6YXRpb25TdGFydGVkLCAnMTpwcy1tcGEtMScsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChsaXN0ZW5lci5vblBvc2l0aW9uc1N5bmNocm9uaXplZCk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3Mgc3luY2hyb25pemF0aW9uIHN0YXJ0ZWQgZXZlbnQgd2l0aG91dCB1cGRhdGluZyBwb3NpdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgPSBzeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uU3luY2hyb25pemF0aW9uU3RhcnRlZDogKCkgPT4ge30sXG4gICAgICAgIG9uUG9zaXRpb25zU3luY2hyb25pemVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkOiAoKSA9PiB7fSxcbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3luY2hyb25pemF0aW9uU3RhcnRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGluc3RhbmNlSW5kZXg6IDEsXG4gICAgICAgIHN5bmNocm9uaXphdGlvbklkOiAnc3luY2hyb25pemF0aW9uSWQnLCBob3N0OiAncHMtbXBhLTEnLCBwb3NpdGlvbnNVcGRhdGVkOiBmYWxzZSxcbiAgICAgICAgb3JkZXJzVXBkYXRlZDogdHJ1ZX0pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgXG4gICAgICAgIGFjY291bnRJbmZvcm1hdGlvbiwgaW5zdGFuY2VJbmRleDogMSwgaG9zdDogJ3BzLW1wYS0xJywgc3luY2hyb25pemF0aW9uSWQ6ICdzeW5jaHJvbml6YXRpb25JZCd9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQsICcxOnBzLW1wYS0xJywgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQsICcxOnBzLW1wYS0xJywgJ3N5bmNocm9uaXphdGlvbklkJyk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3Mgc3luY2hyb25pemF0aW9uIHN0YXJ0ZWQgZXZlbnQgd2l0aG91dCB1cGRhdGluZyBvcmRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgPSBzeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uU3luY2hyb25pemF0aW9uU3RhcnRlZDogKCkgPT4ge30sXG4gICAgICAgIG9uUG9zaXRpb25zU3luY2hyb25pemVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkOiAoKSA9PiB7fSxcbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3luY2hyb25pemF0aW9uU3RhcnRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGluc3RhbmNlSW5kZXg6IDEsXG4gICAgICAgIHN5bmNocm9uaXphdGlvbklkOiAnc3luY2hyb25pemF0aW9uSWQnLCBob3N0OiAncHMtbXBhLTEnLCBwb3NpdGlvbnNVcGRhdGVkOiB0cnVlLFxuICAgICAgICBvcmRlcnNVcGRhdGVkOiBmYWxzZX0pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgXG4gICAgICAgIGFjY291bnRJbmZvcm1hdGlvbiwgaW5zdGFuY2VJbmRleDogMSwgaG9zdDogJ3BzLW1wYS0xJywgc3luY2hyb25pemF0aW9uSWQ6ICdzeW5jaHJvbml6YXRpb25JZCd9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQsICcxOnBzLW1wYS0xJywgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChsaXN0ZW5lci5vblBvc2l0aW9uc1N5bmNocm9uaXplZCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQsICcxOnBzLW1wYS0xJywgJ3N5bmNocm9uaXphdGlvbklkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIGFjY291bnQgaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJyxcbiAgICAgICAgaG9zdDogJ3BzLW1wYS0xJywgYWNjb3VudEluZm9ybWF0aW9uLCBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQsICcxOnBzLW1wYS0xJywgYWNjb3VudEluZm9ybWF0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3luY2hyb25pemUgcG9zaXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fVFlQRV9CVVknLFxuICAgICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgICBtYWdpYzogMTAwMCxcbiAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgICB1cGRhdGVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICAgIG9wZW5QcmljZTogMS4yNjEwMSxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjI0ODgzLFxuICAgICAgICBjdXJyZW50VGlja1ZhbHVlOiAxLFxuICAgICAgICB2b2x1bWU6IDAuMDcsXG4gICAgICAgIHN3YXA6IDAsXG4gICAgICAgIHByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTY2LFxuICAgICAgICBjb21taXNzaW9uOiAtMC4yNSxcbiAgICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICAgIHN0b3BMb3NzOiAxLjE3NzIxLFxuICAgICAgICB1bnJlYWxpemVkUHJvZml0OiAtODUuMjU5OTk5OTk5OTk5MDEsXG4gICAgICAgIHJlYWxpemVkUHJvZml0OiAtNi41MzY5OTMxNjg5OTI5MjJlLTEzXG4gICAgICB9XTtcbiAgICAgIGNsaWVudC5fc29ja2V0SW5zdGFuY2VzWzBdLnN5bmNocm9uaXphdGlvblRocm90dGxlciA9IHN5bmNocm9uaXphdGlvblRocm90dGxlcjtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Qb3NpdGlvbnNSZXBsYWNlZDogKCkgPT4ge30sXG4gICAgICAgIG9uUG9zaXRpb25zU3luY2hyb25pemVkOiAoKSA9PiB7fSxcbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblBvc2l0aW9uc1JlcGxhY2VkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUG9zaXRpb25zU3luY2hyb25pemVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAncG9zaXRpb25zJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgcG9zaXRpb25zLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25JZDogJ3N5bmNocm9uaXphdGlvbklkJywgaG9zdDogJ3BzLW1wYS0xJ30pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Qb3NpdGlvbnNSZXBsYWNlZCwgJzE6cHMtbXBhLTEnLCBwb3NpdGlvbnMpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQsICcxOnBzLW1wYS0xJywgJ3N5bmNocm9uaXphdGlvbklkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIG9yZGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBvcmRlcnMgPSBbe1xuICAgICAgICBpZDogJzQ2ODcxMjg0JyxcbiAgICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJyxcbiAgICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9QTEFDRUQnLFxuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTIwVDA4OjM4OjU4LjI3MFonKSxcbiAgICAgICAgb3BlblByaWNlOiAxLjAzLFxuICAgICAgICBjdXJyZW50UHJpY2U6IDEuMDUyMDYsXG4gICAgICAgIHZvbHVtZTogMC4wMSxcbiAgICAgICAgY3VycmVudFZvbHVtZTogMC4wMSxcbiAgICAgICAgY29tbWVudDogJ0NPTU1FTlQyJ1xuICAgICAgfV07XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uUGVuZGluZ09yZGVyc1JlcGxhY2VkOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkOiAoKSA9PiB7fSxcbiAgICAgIH07XG4gICAgICBjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgPSBzeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblBlbmRpbmdPcmRlcnNSZXBsYWNlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdvcmRlcnMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBvcmRlcnMsIGluc3RhbmNlSW5kZXg6IDEsXG4gICAgICAgIHN5bmNocm9uaXphdGlvbklkOiAnc3luY2hyb25pemF0aW9uSWQnLCBob3N0OiAncHMtbXBhLTEnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25QZW5kaW5nT3JkZXJzUmVwbGFjZWQsICcxOnBzLW1wYS0xJywgb3JkZXJzKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCwgJzE6cHMtbXBhLTEnLCAnc3luY2hyb25pemF0aW9uSWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3luY2hyb25pemUgaGlzdG9yeSBvcmRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgaGlzdG9yeU9yZGVycyA9IFt7XG4gICAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgICBjdXJyZW50UHJpY2U6IDEuMjYxLFxuICAgICAgICBjdXJyZW50Vm9sdW1lOiAwLFxuICAgICAgICBkb25lVGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9GSUxMRUQnLFxuICAgICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi4yNjBaJyksXG4gICAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWScsXG4gICAgICAgIHZvbHVtZTogMC4wN1xuICAgICAgfV07XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uSGlzdG9yeU9yZGVyQWRkZWQ6ICgpID0+IHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uSGlzdG9yeU9yZGVyQWRkZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdoaXN0b3J5T3JkZXJzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaGlzdG9yeU9yZGVycyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgaG9zdDogJ3BzLW1wYS0xJ30pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25IaXN0b3J5T3JkZXJBZGRlZCwgJzE6cHMtbXBhLTEnLCBoaXN0b3J5T3JkZXJzWzBdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3luY2hyb25pemUgZGVhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgZGVhbHMgPSBbe1xuICAgICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICAgIGVudHJ5VHlwZTogJ0RFQUxfRU5UUllfSU4nLFxuICAgICAgICBpZDogJzMzMjMwMDk5JyxcbiAgICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgICAgb3JkZXJJZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgcHJpY2U6IDEuMjYxMDEsXG4gICAgICAgIHByb2ZpdDogMCxcbiAgICAgICAgc3dhcDogMCxcbiAgICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgICB0eXBlOiAnREVBTF9UWVBFX0JVWScsXG4gICAgICAgIHZvbHVtZTogMC4wN1xuICAgICAgfV07XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uRGVhbEFkZGVkOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkRlYWxBZGRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2RlYWxzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgZGVhbHMsIGluc3RhbmNlSW5kZXg6IDEsXG4gICAgICAgIGhvc3Q6ICdwcy1tcGEtMSd9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uRGVhbEFkZGVkLCAnMTpwcy1tcGEtMScsIGRlYWxzWzBdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBzeW5jaHJvbml6YXRpb24gdXBkYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB1cGRhdGUgPSB7XG4gICAgICAgIGFjY291bnRJbmZvcm1hdGlvbjoge1xuICAgICAgICAgIGJyb2tlcjogJ1RydWUgRUNOIFRyYWRpbmcgTHRkJyxcbiAgICAgICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgICAgICAgc2VydmVyOiAnSUNNYXJrZXRzU0MtRGVtbycsXG4gICAgICAgICAgYmFsYW5jZTogNzMxOS45LFxuICAgICAgICAgIGVxdWl0eTogNzMwNi42NDk5MTMyMDAwMDEsXG4gICAgICAgICAgbWFyZ2luOiAxODQuMSxcbiAgICAgICAgICBmcmVlTWFyZ2luOiA3MTIwLjIyLFxuICAgICAgICAgIGxldmVyYWdlOiAxMDAsXG4gICAgICAgICAgbWFyZ2luTGV2ZWw6IDM5NjcuNTgyODM1NDJcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlZFBvc2l0aW9uczogW3tcbiAgICAgICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgICB0eXBlOiAnUE9TSVRJT05fVFlQRV9CVVknLFxuICAgICAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgICAgIHVwZGF0ZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgICAgICBvcGVuUHJpY2U6IDEuMjYxMDEsXG4gICAgICAgICAgY3VycmVudFByaWNlOiAxLjI0ODgzLFxuICAgICAgICAgIGN1cnJlbnRUaWNrVmFsdWU6IDEsXG4gICAgICAgICAgdm9sdW1lOiAwLjA3LFxuICAgICAgICAgIHN3YXA6IDAsXG4gICAgICAgICAgcHJvZml0OiAtODUuMjU5OTk5OTk5OTk5NjYsXG4gICAgICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICAgICAgc3RvcExvc3M6IDEuMTc3MjEsXG4gICAgICAgICAgdW5yZWFsaXplZFByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTAxLFxuICAgICAgICAgIHJlYWxpemVkUHJvZml0OiAtNi41MzY5OTMxNjg5OTI5MjJlLTEzXG4gICAgICAgIH1dLFxuICAgICAgICByZW1vdmVkUG9zaXRpb25JZHM6IFsnMTIzNCddLFxuICAgICAgICB1cGRhdGVkT3JkZXJzOiBbe1xuICAgICAgICAgIGlkOiAnNDY4NzEyODQnLFxuICAgICAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9QTEFDRUQnLFxuICAgICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMjBUMDg6Mzg6NTguMjcwWicpLFxuICAgICAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgICAgICBjdXJyZW50UHJpY2U6IDEuMDUyMDYsXG4gICAgICAgICAgdm9sdW1lOiAwLjAxLFxuICAgICAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICAgICAgY29tbWVudDogJ0NPTU1FTlQyJ1xuICAgICAgICB9XSxcbiAgICAgICAgY29tcGxldGVkT3JkZXJJZHM6IFsnMjM0NSddLFxuICAgICAgICBoaXN0b3J5T3JkZXJzOiBbe1xuICAgICAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgICAgIGN1cnJlbnRQcmljZTogMS4yNjEsXG4gICAgICAgICAgY3VycmVudFZvbHVtZTogMCxcbiAgICAgICAgICBkb25lVGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgICAgICBwb3NpdGlvbklkOiAnNDYyMTQ2OTInLFxuICAgICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfRklMTEVEJyxcbiAgICAgICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjI2MFonKSxcbiAgICAgICAgICB0eXBlOiAnT1JERVJfVFlQRV9CVVknLFxuICAgICAgICAgIHZvbHVtZTogMC4wN1xuICAgICAgICB9XSxcbiAgICAgICAgZGVhbHM6IFt7XG4gICAgICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICAgICAgZW50cnlUeXBlOiAnREVBTF9FTlRSWV9JTicsXG4gICAgICAgICAgaWQ6ICczMzIzMDA5OScsXG4gICAgICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICAgIG9yZGVySWQ6ICc0NjIxNDY5MicsXG4gICAgICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgICBwcmljZTogMS4yNjEwMSxcbiAgICAgICAgICBwcm9maXQ6IDAsXG4gICAgICAgICAgc3dhcDogMCxcbiAgICAgICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgICAgICB0eXBlOiAnREVBTF9UWVBFX0JVWScsXG4gICAgICAgICAgdm9sdW1lOiAwLjA3XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvblBvc2l0aW9uVXBkYXRlZDogKCkgPT4ge30sXG4gICAgICAgIG9uUG9zaXRpb25SZW1vdmVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZW5kaW5nT3JkZXJVcGRhdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZW5kaW5nT3JkZXJDb21wbGV0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkhpc3RvcnlPcmRlckFkZGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25EZWFsQWRkZWQ6ICgpID0+IHt9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUG9zaXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUG9zaXRpb25SZW1vdmVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUGVuZGluZ09yZGVyVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblBlbmRpbmdPcmRlckNvbXBsZXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkhpc3RvcnlPcmRlckFkZGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uRGVhbEFkZGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIE9iamVjdC5hc3NpZ24oe3R5cGU6ICd1cGRhdGUnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgICBob3N0OiAncHMtbXBhLTEnfSwgdXBkYXRlKSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkLCAnMTpwcy1tcGEtMScsIHVwZGF0ZS5hY2NvdW50SW5mb3JtYXRpb24pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Qb3NpdGlvblVwZGF0ZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLnVwZGF0ZWRQb3NpdGlvbnNbMF0pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Qb3NpdGlvblJlbW92ZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLnJlbW92ZWRQb3NpdGlvbklkc1swXSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblBlbmRpbmdPcmRlclVwZGF0ZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLnVwZGF0ZWRPcmRlcnNbMF0pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25QZW5kaW5nT3JkZXJDb21wbGV0ZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLmNvbXBsZXRlZE9yZGVySWRzWzBdKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLmhpc3RvcnlPcmRlcnNbMF0pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25EZWFsQWRkZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLmRlYWxzWzBdKTtcbiAgICB9KTtcblxuICB9KTtcblxuICBkZXNjcmliZSgnbWFya2V0IGRhdGEgc3luY2hyb25pemF0aW9uJywgKCkgPT4ge1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGNsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcmV0cnkgcmVxdWVzdCBvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgaWQ6ICc0Njg3MTI4NCcsXG4gICAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0yMFQwODozODo1OC4yNzBaJyksXG4gICAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgICB2b2x1bWU6IDAuMDEsXG4gICAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICAgIH07XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKHJlcXVlc3RDb3VudGVyID4gMSAmJiBkYXRhLnR5cGUgPT09ICdnZXRPcmRlcicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmXG4gICAgICAgICAgZGF0YS5vcmRlcklkID09PSAnNDY4NzEyODQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIG9yZGVyfSk7XG4gICAgICAgIH0gXG4gICAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0T3JkZXIoJ2FjY291bnRJZCcsICc0Njg3MTI4NCcpO1xuICAgICAgYWN0dWFsLnNob3VsZC5tYXRjaChvcmRlcik7XG4gICAgfSkudGltZW91dCgyMDAwMCk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfcnBjUmVxdWVzdH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHdhaXQgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIG9uIHRvbyBtYW55IHJlcXVlc3RzIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgaWQ6ICc0Njg3MTI4NCcsXG4gICAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0yMFQwODozODo1OC4yNzBaJyksXG4gICAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgICB2b2x1bWU6IDAuMDEsXG4gICAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICAgIH07XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKHJlcXVlc3RDb3VudGVyID4gMCAmJiBkYXRhLnR5cGUgPT09ICdnZXRPcmRlcicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmXG4gICAgICAgICAgZGF0YS5vcmRlcklkID09PSAnNDY4NzEyODQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIG9yZGVyfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgICAgIGlkOiAxLCBlcnJvcjogJ1Rvb01hbnlSZXF1ZXN0c0Vycm9yJywgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgQVBJIGFsbG93cyAxMDAwMCByZXF1ZXN0cyBwZXIgNjAgbWludXRlcyB0byBhdm9pZCBvdmVybG9hZGluZyBvdXIgc2VydmVycy4nLFxuICAgICAgICAgICAgc3RhdHVzX2NvZGU6IDQyOSwgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgcGVyaW9kSW5NaW51dGVzOiA2MCwgbWF4UmVxdWVzdHNGb3JQZXJpb2Q6IDEwMDAwLCBcbiAgICAgICAgICAgICAgcmVjb21tZW5kZWRSZXRyeVRpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgKyAxMDAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldE9yZGVyKCdhY2NvdW50SWQnLCAnNDY4NzEyODQnKTtcbiAgICAgIGFjdHVhbC5zaG91bGQubWF0Y2gob3JkZXIpO1xuICAgICAgKERhdGUubm93KCkgLSBzdGFydFRpbWUpLnNob3VsZC5iZS5hcHByb3hpbWF0ZWx5KDEwMDAsIDEwMCk7XG4gICAgfSkudGltZW91dCgxMDAwMCk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfcnBjUmVxdWVzdH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJldHVybiB0b28gbWFueSByZXF1ZXN0cyBleGNlcHRpb24gaWYgcmVjb21tZW5kZWQgdGltZSBpcyBiZXlvbmQgbWF4IHJlcXVlc3QgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0Q291bnRlciA9IDA7XG4gICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgIGlkOiAnNDY4NzEyODQnLFxuICAgICAgICB0eXBlOiAnT1JERVJfVFlQRV9CVVlfTElNSVQnLFxuICAgICAgICBzdGF0ZTogJ09SREVSX1NUQVRFX1BMQUNFRCcsXG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIG1hZ2ljOiAxMjM0NTYsXG4gICAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMjBUMDg6Mzg6NTguMjcwWicpLFxuICAgICAgICBvcGVuUHJpY2U6IDEuMDMsXG4gICAgICAgIGN1cnJlbnRQcmljZTogMS4wNTIwNixcbiAgICAgICAgdm9sdW1lOiAwLjAxLFxuICAgICAgICBjdXJyZW50Vm9sdW1lOiAwLjAxLFxuICAgICAgICBjb21tZW50OiAnQ09NTUVOVDInXG4gICAgICB9O1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChyZXF1ZXN0Q291bnRlciA+IDAgJiYgZGF0YS50eXBlID09PSAnZ2V0T3JkZXInICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICAgICAgICBkYXRhLm9yZGVySWQgPT09ICc0Njg3MTI4NCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgb3JkZXJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICAgICAgaWQ6IDEsIGVycm9yOiAnVG9vTWFueVJlcXVlc3RzRXJyb3InLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBBUEkgYWxsb3dzIDEwMDAwIHJlcXVlc3RzIHBlciA2MCBtaW51dGVzIHRvIGF2b2lkIG92ZXJsb2FkaW5nIG91ciBzZXJ2ZXJzLicsXG4gICAgICAgICAgICBzdGF0dXNfY29kZTogNDI5LCBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBwZXJpb2RJbk1pbnV0ZXM6IDYwLCBtYXhSZXF1ZXN0c0ZvclBlcmlvZDogMTAwMDAsIFxuICAgICAgICAgICAgICByZWNvbW1lbmRlZFJldHJ5VGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmdldE9yZGVyKCdhY2NvdW50SWQnLCAnNDY4NzEyODQnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29NYW55UmVxdWVzdHNFcnJvciBleHBlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnVG9vTWFueVJlcXVlc3RzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KS50aW1lb3V0KDEwMDAwKTsgICAgXG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfcnBjUmVxdWVzdH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSByZXF1ZXN0IG9uIHZhbGlkYXRpb24gZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdENvdW50ZXIgPSAwO1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChyZXF1ZXN0Q291bnRlciA+IDAgJiYgZGF0YS50eXBlID09PSAnc3Vic2NyaWJlVG9NYXJrZXREYXRhJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgICBkYXRhLnN5bWJvbCA9PT0gJ0VVUlVTRCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBkYXRhLmluc3RhbmNlSW5kZXggPT09IDEpIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgICBpZDogMSwgZXJyb3I6ICdWYWxpZGF0aW9uRXJyb3InLCBtZXNzYWdlOiAnRXJyb3IgbWVzc2FnZScsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0Q291bnRlciArKztcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LnN1YnNjcmliZVRvTWFya2V0RGF0YSgnYWNjb3VudElkJywgMSwgJ0VVUlVTRCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb25FcnJvciBleHBlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnVmFsaWRhdGlvbkVycm9yJyk7XG4gICAgICB9XG4gICAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVxdWVzdENvdW50ZXIsIDEpO1xuICAgIH0pLnRpbWVvdXQoNjAwMCk7XG4gICAgXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjX3JwY1JlcXVlc3R9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgdHJhZGUgcmVxdWVzdHMgb24gZmFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0Q291bnRlciA9IDA7XG4gICAgICBsZXQgdHJhZGUgPSB7XG4gICAgICAgIGFjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLFxuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICB2b2x1bWU6IDAuMDdcbiAgICAgIH07XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICAgIGlmKHJlcXVlc3RDb3VudGVyID4gMCkge1xuICAgICAgICAgICAgc2lub24uYXNzZXJ0LmZhaWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdENvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQudHJhZGUodHJhZGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVvdXRFcnJvciBleHBlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnVGltZW91dEVycm9yJyk7XG4gICAgICB9XG4gICAgfSkudGltZW91dCg2MDAwKTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbm90IHJldHJ5IHJlcXVlc3QgaWYgY29ubmVjdGlvbiBjbG9zZWQgYmV0d2VlbiByZXRyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICAgIGxldCByZXNwb25zZSA9IHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnfTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAndW5zdWJzY3JpYmUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJykge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIE9iamVjdC5hc3NpZ24oe3JlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9LCByZXNwb25zZSkpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0T3JkZXJzJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgICByZXF1ZXN0Q291bnRlcisrO1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgICBpZDogMSwgZXJyb3I6ICdOb3RTeW5jaHJvbml6ZWRFcnJvcicsIG1lc3NhZ2U6ICdFcnJvciBtZXNzYWdlJyxcbiAgICAgICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGllbnQudW5zdWJzY3JpYmUoJ2FjY291bnRJZCcpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmdldE9yZGVycygnYWNjb3VudElkJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90U3luY2hyb25pemVkRXJyb3IgZXhwZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ05vdFN5bmNocm9uaXplZEVycm9yJyk7XG4gICAgICB9XG4gICAgICByZXF1ZXN0Q291bnRlci5zaG91bGQuZXF1YWwoMSk7XG4gICAgICBjbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cy5zaG91bGQubm90LmhhdmUucHJvcGVydHkoJ2FjY291bnRJZCcpO1xuICAgIH0pO1xuICBcbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfcnBjUmVxdWVzdH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJldHVybiB0aW1lb3V0IGVycm9yIGlmIG5vIHNlcnZlciByZXNwb25zZSByZWNlaXZlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB0cmFkZSA9IHtcbiAgICAgICAgYWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTCcsXG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIHZvbHVtZTogMC4wN1xuICAgICAgfTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQudHJhZGUodHJhZGUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVvdXRFcnJvciBleHRlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnVGltZW91dEVycm9yJyk7XG4gICAgICB9XG4gICAgfSkudGltZW91dCgyMDAwMCk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNzdWJzY3JpYmVUb01hcmtldERhdGF9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBzdWJzY3JpYmUgdG8gbWFya2V0IGRhdGEgd2l0aCBNZXRhVHJhZGVyIHRlcm1pbmFsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdzdWJzY3JpYmVUb01hcmtldERhdGEnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnN5bWJvbCA9PT0gJ0VVUlVTRCcgJiZcbiAgICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmIGRhdGEuaW5zdGFuY2VJbmRleCA9PT0gMSAmJlxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEuc3Vic2NyaXB0aW9ucykgPT09IEpTT04uc3RyaW5naWZ5KFt7dHlwZTogJ3F1b3Rlcyd9XSkpIHtcbiAgICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgY2xpZW50LnN1YnNjcmliZVRvTWFya2V0RGF0YSgnYWNjb3VudElkJywgMSwgJ0VVUlVTRCcsIFt7dHlwZTogJ3F1b3Rlcyd9XSk7XG4gICAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uc31cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJlZnJlc2ggbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAncmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgXG4gICAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBkYXRhLmluc3RhbmNlSW5kZXggPT09IDEgJiZcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhLnN1YnNjcmlwdGlvbnMpID09PSBKU09OLnN0cmluZ2lmeShbe3N5bWJvbDogJ0VVUlVTRCd9XSkpIHtcbiAgICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgY2xpZW50LnJlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucygnYWNjb3VudElkJywgMSwgW3tzeW1ib2w6ICdFVVJVU0QnfV0pO1xuICAgICAgcmVxdWVzdFJlY2VpdmVkLnNob3VsZC5iZS50cnVlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCN1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgdW5zdWJzY3JpYmUgZnJvbSBtYXJrZXQgZGF0YSB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnN5bWJvbCA9PT0gJ0VVUlVTRCcgJiZcbiAgICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmIGRhdGEuaW5zdGFuY2VJbmRleCA9PT0gMSAmJlxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEuc3Vic2NyaXB0aW9ucykgPT09IEpTT04uc3RyaW5naWZ5KFt7dHlwZTogJ3F1b3Rlcyd9XSkpIHtcbiAgICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgY2xpZW50LnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoJ2FjY291bnRJZCcsIDEsICdFVVJVU0QnLCBbe3R5cGU6ICdxdW90ZXMnfV0pO1xuICAgICAgcmVxdWVzdFJlY2VpdmVkLnNob3VsZC5iZS50cnVlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIHN5bWJvbCBzcGVjaWZpY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzcGVjaWZpY2F0aW9ucyA9IFt7XG4gICAgICAgIHN5bWJvbDogJ0VVUlVTRCcsXG4gICAgICAgIHRpY2tTaXplOiAwLjAwMDAxLFxuICAgICAgICBtaW5Wb2x1bWU6IDAuMDEsXG4gICAgICAgIG1heFZvbHVtZTogMjAwLFxuICAgICAgICB2b2x1bWVTdGVwOiAwLjAxXG4gICAgICB9XTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQ6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgb25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJyxcbiAgICAgICAge3R5cGU6ICdzcGVjaWZpY2F0aW9ucycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIHNwZWNpZmljYXRpb25zLCBpbnN0YW5jZUluZGV4OiAxLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICAgIHJlbW92ZWRTeW1ib2xzOiBbJ0FVRE5aRCddfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCwgJzE6cHMtbXBhLTEnLCBzcGVjaWZpY2F0aW9ucywgWydBVUROWkQnXSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkLCAnMTpwcy1tcGEtMScsIHNwZWNpZmljYXRpb25zWzBdKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQsICcxOnBzLW1wYS0xJywgJ0FVRE5aRCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzeW5jaHJvbml6ZSBzeW1ib2wgcHJpY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHByaWNlcyA9IFt7XG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIGJpZDogMS4wNTkxNixcbiAgICAgICAgYXNrOiAxLjA1OTI3LFxuICAgICAgICBwcm9maXRUaWNrVmFsdWU6IDAuNjAyLFxuICAgICAgICBsb3NzVGlja1ZhbHVlOiAwLjYwMjAzXG4gICAgICB9XTtcbiAgICAgIGxldCB0aWNrcyA9IFt7XG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTA3VDAzOjQ1OjAwLjAwMFonKSxcbiAgICAgICAgYnJva2VyVGltZTogJzIwMjAtMDQtMDcgMDY6NDU6MDAuMDAwJyxcbiAgICAgICAgYmlkOiAxLjA1Mjk3LFxuICAgICAgICBhc2s6IDEuMDUzMDksXG4gICAgICAgIGxhc3Q6IDAuNTI5OCxcbiAgICAgICAgdm9sdW1lOiAwLjEzLFxuICAgICAgICBzaWRlOiAnYnV5J1xuICAgICAgfV07XG4gICAgICBsZXQgY2FuZGxlcyA9IFt7XG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIHRpbWVmcmFtZTogJzE1bScsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTA3VDAzOjQ1OjAwLjAwMFonKSxcbiAgICAgICAgYnJva2VyVGltZTogJzIwMjAtMDQtMDcgMDY6NDU6MDAuMDAwJyxcbiAgICAgICAgb3BlbjogMS4wMzI5NyxcbiAgICAgICAgaGlnaDogMS4wNjMwOSxcbiAgICAgICAgbG93OiAxLjAyNzA1LFxuICAgICAgICBjbG9zZTogMS4wNDMsXG4gICAgICAgIHRpY2tWb2x1bWU6IDE0MzUsXG4gICAgICAgIHNwcmVhZDogMTcsXG4gICAgICAgIHZvbHVtZTogMzQ1XG4gICAgICB9XTtcbiAgICAgIGxldCBib29rcyA9IFt7XG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTA3VDAzOjQ1OjAwLjAwMFonKSxcbiAgICAgICAgYnJva2VyVGltZTogJzIwMjAtMDQtMDcgMDY6NDU6MDAuMDAwJyxcbiAgICAgICAgYm9vazogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdCT09LX1RZUEVfU0VMTCcsXG4gICAgICAgICAgICBwcmljZTogMS4wNTMwOSxcbiAgICAgICAgICAgIHZvbHVtZTogNS42N1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ0JPT0tfVFlQRV9CVVknLFxuICAgICAgICAgICAgcHJpY2U6IDEuMDUyOTcsXG4gICAgICAgICAgICB2b2x1bWU6IDMuNDVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1dO1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvblN5bWJvbFByaWNlVXBkYXRlZDogKCkgPT4ge30sXG4gICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZDogKCkgPT4ge30sXG4gICAgICAgIG9uQ2FuZGxlc1VwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvblRpY2tzVXBkYXRlZDogKCkgPT4ge30sXG4gICAgICAgIG9uQm9va3NVcGRhdGVkOiAoKSA9PiB7fVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uU3ltYm9sUHJpY2VVcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uU3ltYm9sUHJpY2VzVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkNhbmRsZXNVcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uVGlja3NVcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uQm9va3NVcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAncHJpY2VzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJywgcHJpY2VzLFxuICAgICAgICB0aWNrcywgY2FuZGxlcywgYm9va3MsIGVxdWl0eTogMTAwLCBtYXJnaW46IDIwMCwgZnJlZU1hcmdpbjogNDAwLCBtYXJnaW5MZXZlbDogNDAwMDAsIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uU3ltYm9sUHJpY2VzVXBkYXRlZCwgJzE6cHMtbXBhLTEnLCBwcmljZXMsIDEwMCwgMjAwLCA0MDAsIDQwMDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uQ2FuZGxlc1VwZGF0ZWQsICcxOnBzLW1wYS0xJywgY2FuZGxlcywgMTAwLCAyMDAsIDQwMCwgNDAwMDApO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25UaWNrc1VwZGF0ZWQsICcxOnBzLW1wYS0xJywgdGlja3MsIDEwMCwgMjAwLCA0MDAsIDQwMDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uQm9va3NVcGRhdGVkLCAnMTpwcy1tcGEtMScsIGJvb2tzLCAxMDAsIDIwMCwgNDAwLCA0MDAwMCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bWJvbFByaWNlVXBkYXRlZCwgJzE6cHMtbXBhLTEnLCBwcmljZXNbMF0pO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3YWl0IGZvciBzZXJ2ZXItc2lkZSB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb24nLCAoKSA9PiB7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjd2FpdFN5bmNocm9uaXplZH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHdhaXQgZm9yIHNlcnZlci1zaWRlIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnd2FpdFN5bmNocm9uaXplZCcgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmXG4gICAgICAgICAgZGF0YS5hcHBsaWNhdGlvblBhdHRlcm4gPT09ICdhcHAuKicgJiYgZGF0YS50aW1lb3V0SW5TZWNvbmRzID09PSAxMCAmJlxuICAgICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicgJiYgZGF0YS5pbnN0YW5jZUluZGV4ID09PSAxKSB7XG4gICAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGNsaWVudC53YWl0U3luY2hyb25pemVkKCdhY2NvdW50SWQnLCAxLCAnYXBwLionLCAxMCk7XG4gICAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgICB9KTtcblxuICB9KTtcblxuICBkZXNjcmliZSgnbGF0ZW5jeSBtb25pdG9yaW5nJywgKCkgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0xhdGVuY3lMaXN0ZW5lciNvblJlc3BvbnNlfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgaW52b2tlIGxhdGVuY3kgbGlzdGVuZXIgb24gcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYWNjb3VudElkO1xuICAgICAgbGV0IHJlcXVlc3RUeXBlO1xuICAgICAgbGV0IGFjdHVhbFRpbWVzdGFtcHM7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uUmVzcG9uc2U6IChhaWQsIHR5cGUsIHRzKSA9PiB7XG4gICAgICAgICAgYWNjb3VudElkID0gYWlkO1xuICAgICAgICAgIHJlcXVlc3RUeXBlID0gdHlwZTtcbiAgICAgICAgICBhY3R1YWxUaW1lc3RhbXBzID0gdHM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjbGllbnQuYWRkTGF0ZW5jeUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIGxldCBwcmljZSA9IHt9O1xuICAgICAgbGV0IHRpbWVzdGFtcHM7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldFN5bWJvbFByaWNlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5zeW1ib2wgPT09ICdBVUROWkQnICYmXG4gICAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycgJiYgZGF0YS50aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdTdGFydGVkKSB7XG4gICAgICAgICAgdGltZXN0YW1wcyA9IE9iamVjdC5hc3NpZ24oZGF0YS50aW1lc3RhbXBzLCB7c2VydmVyUHJvY2Vzc2luZ1N0YXJ0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBzZXJ2ZXJQcm9jZXNzaW5nRmluaXNoZWQ6IG5ldyBEYXRlKCl9KTtcbiAgICAgICAgICB0aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdTdGFydGVkID0gbmV3IERhdGUodGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nU3RhcnRlZCk7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHByaWNlLFxuICAgICAgICAgICAgdGltZXN0YW1wc30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGNsaWVudC5nZXRTeW1ib2xQcmljZSgnYWNjb3VudElkJywgJ0FVRE5aRCcpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDApKTtcbiAgICAgIGFjY291bnRJZC5zaG91bGQuZXF1YWwoJ2FjY291bnRJZCcpO1xuICAgICAgcmVxdWVzdFR5cGUuc2hvdWxkLmVxdWFsKCdnZXRTeW1ib2xQcmljZScpO1xuICAgICAgYWN0dWFsVGltZXN0YW1wcy5zaG91bGQubWF0Y2godGltZXN0YW1wcyk7XG4gICAgICBzaG91bGQuZXhpc3QoYWN0dWFsVGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nU3RhcnRlZCk7XG4gICAgICBzaG91bGQuZXhpc3QoYWN0dWFsVGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQpO1xuICAgICAgc2hvdWxkLmV4aXN0KGFjdHVhbFRpbWVzdGFtcHMuc2VydmVyUHJvY2Vzc2luZ1N0YXJ0ZWQpO1xuICAgICAgc2hvdWxkLmV4aXN0KGFjdHVhbFRpbWVzdGFtcHMuc2VydmVyUHJvY2Vzc2luZ0ZpbmlzaGVkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtMYXRlbmN5TGlzdGVuZXIjb25TeW1ib2xQcmljZX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG1lYXN1cmUgcHJpY2Ugc3RyZWFtaW5nIGxhdGVuY2llcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBwcmljZXMgPSBbe1xuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICB0aW1lc3RhbXBzOiB7XG4gICAgICAgICAgZXZlbnRHZW5lcmF0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgc2VydmVyUHJvY2Vzc2luZ1N0YXJ0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgc2VydmVyUHJvY2Vzc2luZ0ZpbmlzaGVkOiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgICAgbGV0IGFjY291bnRJZDtcbiAgICAgIGxldCBzeW1ib2w7XG4gICAgICBsZXQgYWN0dWFsVGltZXN0YW1wcztcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25TeW1ib2xQcmljZTogKGFpZCwgc3ltLCB0cykgPT4ge1xuICAgICAgICAgIGFjY291bnRJZCA9IGFpZDtcbiAgICAgICAgICBzeW1ib2wgPSBzeW07XG4gICAgICAgICAgYWN0dWFsVGltZXN0YW1wcyA9IHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2xpZW50LmFkZExhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdwcmljZXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBwcmljZXMsIGVxdWl0eTogMTAwLCBtYXJnaW46IDIwMCxcbiAgICAgICAgZnJlZU1hcmdpbjogNDAwLCBtYXJnaW5MZXZlbDogNDAwMDB9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGFjY291bnRJZC5zaG91bGQuZXF1YWwoJ2FjY291bnRJZCcpO1xuICAgICAgc3ltYm9sLnNob3VsZC5lcXVhbCgnQVVETlpEJyk7XG4gICAgICBhY3R1YWxUaW1lc3RhbXBzLnNob3VsZC5tYXRjaChwcmljZXNbMF0udGltZXN0YW1wcyk7XG4gICAgICBzaG91bGQuZXhpc3QoYWN0dWFsVGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0xhdGVuY3lMaXN0ZW5lciNvblVwZGF0ZX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG1lYXN1cmUgdXBkYXRlIGxhdGVuY2llcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB1cGRhdGUgPSB7XG4gICAgICAgIHRpbWVzdGFtcHM6IHtcbiAgICAgICAgICBldmVudEdlbmVyYXRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgICBzZXJ2ZXJQcm9jZXNzaW5nU3RhcnRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgICBzZXJ2ZXJQcm9jZXNzaW5nRmluaXNoZWQ6IG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCBhY2NvdW50SWQ7XG4gICAgICBsZXQgYWN0dWFsVGltZXN0YW1wcztcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25VcGRhdGU6IChhaWQsIHRzKSA9PiB7XG4gICAgICAgICAgYWNjb3VudElkID0gYWlkO1xuICAgICAgICAgIGFjdHVhbFRpbWVzdGFtcHMgPSB0cztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNsaWVudC5hZGRMYXRlbmN5TGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIE9iamVjdC5hc3NpZ24oe3R5cGU6ICd1cGRhdGUnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnfSwgdXBkYXRlKSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhY2NvdW50SWQuc2hvdWxkLmVxdWFsKCdhY2NvdW50SWQnKTtcbiAgICAgIGFjdHVhbFRpbWVzdGFtcHMuc2hvdWxkLm1hdGNoKHVwZGF0ZS50aW1lc3RhbXBzKTtcbiAgICAgIHNob3VsZC5leGlzdChhY3R1YWxUaW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TGF0ZW5jeUxpc3RlbmVyI29uVHJhZGV9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHRyYWRlIGxhdGVuY3knLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgdHJhZGUgPSB7fTtcbiAgICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgICAgbnVtZXJpY0NvZGU6IDEwMDA5LFxuICAgICAgICBzdHJpbmdDb2RlOiAnVFJBREVfUkVUQ09ERV9ET05FJyxcbiAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgY29tcGxldGVkJyxcbiAgICAgICAgb3JkZXJJZDogJzQ2ODcwNDcyJ1xuICAgICAgfTtcbiAgICAgIGxldCB0aW1lc3RhbXBzID0ge1xuICAgICAgICBjbGllbnRFeGVjdXRpb25TdGFydGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICBzZXJ2ZXJFeGVjdXRpb25TdGFydGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICBzZXJ2ZXJFeGVjdXRpb25GaW5pc2hlZDogbmV3IERhdGUoKSxcbiAgICAgICAgdHJhZGVFeGVjdXRlZDogbmV3IERhdGUoKVxuICAgICAgfTtcbiAgICAgIGxldCBhY2NvdW50SWQ7XG4gICAgICBsZXQgYWN0dWFsVGltZXN0YW1wcztcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25UcmFkZTogKGFpZCwgdHMpID0+IHtcbiAgICAgICAgICBhY2NvdW50SWQgPSBhaWQ7XG4gICAgICAgICAgYWN0dWFsVGltZXN0YW1wcyA9IHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2xpZW50LmFkZExhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgZGF0YS50cmFkZS5zaG91bGQubWF0Y2godHJhZGUpO1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHJlc3BvbnNlLFxuICAgICAgICAgICAgdGltZXN0YW1wc30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGNsaWVudC50cmFkZSgnYWNjb3VudElkJywgdHJhZGUpO1xuICAgICAgYWNjb3VudElkLnNob3VsZC5lcXVhbCgnYWNjb3VudElkJyk7XG4gICAgICBhY3R1YWxUaW1lc3RhbXBzLnNob3VsZC5tYXRjaCh0aW1lc3RhbXBzKTtcbiAgICAgIHNob3VsZC5leGlzdChhY3R1YWxUaW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCk7XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWNvbm5lY3QgdG8gc2VydmVyIG9uIGRpc2Nvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzKHtzaG91bGRBZHZhbmNlVGltZTogdHJ1ZX0pO1xuICAgIGNvbnN0IHRyYWRlID0ge1xuICAgICAgYWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTCcsXG4gICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgdm9sdW1lOiAwLjA3XG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgIG51bWVyaWNDb2RlOiAxMDAwOSxcbiAgICAgIHN0cmluZ0NvZGU6ICdUUkFERV9SRVRDT0RFX0RPTkUnLFxuICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgY29tcGxldGVkJyxcbiAgICAgIG9yZGVySWQ6ICc0Njg3MDQ3MidcbiAgICB9O1xuICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgIG9uUmVjb25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgIH07XG4gICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25SZWNvbm5lY3RlZCcpLnJlc29sdmVzKCk7XG4gICAgc2FuZGJveC5zdHViKGNsaWVudC5fcGFja2V0T3JkZXJlciwgJ29uUmVjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3N1YnNjcmlwdGlvbk1hbmFnZXIsICdvblJlY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICBjbGllbnQuYWRkUmVjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIsICdhY2NvdW50SWQnKTtcbiAgICBsZXQgcmVxdWVzdENvdW50ZXIgPSAwO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICByZXF1ZXN0Q291bnRlcisrO1xuICAgICAgICBhd2FpdCBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgXG4gICAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcmVzcG9uc2V9KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gIFxuICAgIGNsaWVudC50cmFkZSgnYWNjb3VudElkJywgdHJhZGUpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTUwMCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKGxpc3RlbmVyLm9uUmVjb25uZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGNsaWVudC5fc3Vic2NyaXB0aW9uTWFuYWdlci5vblJlY29ubmVjdGVkLCAwLCBbJ2FjY291bnRJZCddKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChjbGllbnQuX3BhY2tldE9yZGVyZXIub25SZWNvbm5lY3RlZCwgWydhY2NvdW50SWQnXSk7XG5cbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd0cmFkZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICAgICAgcmVxdWVzdENvdW50ZXIrKztcbiAgICAgICAgYXdhaXQgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIFxuICAgICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHJlc3BvbnNlfSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICBcbiAgICBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDE1MDApO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVxdWVzdENvdW50ZXIsIDIpO1xuICAgIGNsb2NrLnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZW1vdmUgcmVjb25uZWN0IGxpc3RlbmVyJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNsb2NrID0gc2lub24udXNlRmFrZVRpbWVycyh7c2hvdWxkQWR2YW5jZVRpbWU6IHRydWV9KTtcblxuICAgIGxldCB0cmFkZSA9IHtcbiAgICAgIGFjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLFxuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIHZvbHVtZTogMC4wN1xuICAgIH07XG4gICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgbnVtZXJpY0NvZGU6IDEwMDA5LFxuICAgICAgc3RyaW5nQ29kZTogJ1RSQURFX1JFVENPREVfRE9ORScsXG4gICAgICBtZXNzYWdlOiAnUmVxdWVzdCBjb21wbGV0ZWQnLFxuICAgICAgb3JkZXJJZDogJzQ2ODcwNDcyJ1xuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSB7b25SZWNvbm5lY3RlZDogYXN5bmMgKCkgPT4ge319O1xuICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUmVjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgIGNsaWVudC5hZGRSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lciwgJ2FjY291bnRJZCcpO1xuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3N1YnNjcmlwdGlvbk1hbmFnZXIsICdvblJlY29ubmVjdGVkJyk7XG4gICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGRhdGEudHJhZGUuc2hvdWxkLm1hdGNoKHRyYWRlKTtcbiAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCByZXNwb25zZX0pO1xuICAgICAgfVxuICAgICAgc2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGNsaWVudC50cmFkZSgnYWNjb3VudElkJywgdHJhZGUpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTEwMCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKGxpc3RlbmVyLm9uUmVjb25uZWN0ZWQpO1xuICAgIGNsaWVudC5yZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGRhdGEudHJhZGUuc2hvdWxkLm1hdGNoKHRyYWRlKTtcbiAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCByZXNwb25zZX0pO1xuICAgICAgfVxuICAgICAgc2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGNsaWVudC50cmFkZSgnYWNjb3VudElkJywgdHJhZGUpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTEwMCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKGxpc3RlbmVyLm9uUmVjb25uZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5tYXRjaChyZXF1ZXN0Q291bnRlciwgMik7XG4gICAgY2xvY2sucmVzdG9yZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjcXVldWVQYWNrZXR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHByb2Nlc3MgcGFja2V0cyBpbiBvcmRlcicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjbG9jayA9IHNpbm9uLnVzZUZha2VUaW1lcnMoe3Nob3VsZEFkdmFuY2VUaW1lOiB0cnVlfSk7XG4gICAgbGV0IG9yZGVyc0NhbGxUaW1lID0gMDtcbiAgICBsZXQgcG9zaXRpb25zQ2FsbFRpbWUgPSAwO1xuICAgIGxldCBkaXNjb25uZWN0ZWRDYWxsVGltZSA9IDA7XG4gICAgbGV0IHByaWNlc0NhbGxUaW1lID0gMDtcbiAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICBvbkNvbm5lY3RlZDogKCkgPT4ge30sXG4gICAgICBvbkRpc2Nvbm5lY3RlZDogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwMDApKTtcbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgfSxcbiAgICAgIG9uUGVuZGluZ09yZGVyc1JlcGxhY2VkOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMDApKTtcbiAgICAgICAgb3JkZXJzQ2FsbFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgfSxcbiAgICAgIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZDogKCkgPT4ge30sXG4gICAgICBvblBvc2l0aW9uc1JlcGxhY2VkOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuICAgICAgICBwb3NpdGlvbnNDYWxsVGltZSA9IERhdGUubm93KCk7XG4gICAgICB9LFxuICAgICAgb25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQ6ICgpID0+IHt9LFxuICAgICAgb25TeW1ib2xQcmljZVVwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgb25TeW1ib2xQcmljZXNVcGRhdGVkOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuICAgICAgICBwcmljZXNDYWxsVGltZSA9IERhdGUubm93KCk7XG4gICAgICB9LFxuICAgIH07XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXMgPT4gcmVzb2x2ZSA9IHJlcyk7XG4gICAgY2xpZW50LmNsb3NlKCk7XG4gICAgaW8uY2xvc2UoKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICBhd2FpdCBwcm9taXNlO1xuICAgIGlvID0gbmV3IFNlcnZlcig2Nzg1LCB7cGF0aDogJy93cycsIHBpbmdUaW1lb3V0OiAxMDAwMDAwfSk7XG4gICAgc2FuZGJveC5zdHViKGh0dHBDbGllbnQsICdyZXF1ZXN0JykucmVzb2x2ZXMoe3VybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6Njc4NSd9KTtcbiAgICBjbGllbnQgPSBuZXcgTWV0YUFwaVdlYnNvY2tldENsaWVudChodHRwQ2xpZW50LCAndG9rZW4nLCB7YXBwbGljYXRpb246ICdhcHBsaWNhdGlvbicsIFxuICAgICAgZG9tYWluOiAncHJvamVjdC1zdG9jay5hZ2lsaXVtbGFicy5jbG91ZCcsIHJlcXVlc3RUaW1lb3V0OiAxLjUsIHVzZVNoYXJlZENsaWVudEFwaTogZmFsc2UsXG4gICAgICByZXRyeU9wdHM6IHsgcmV0cmllczogMywgbWluRGVsYXlJblNlY29uZHM6IDAuMSwgbWF4RGVsYXlJblNlY29uZHM6IDAuNX0sXG4gICAgICBldmVudFByb2Nlc3Npbmc6IHtzZXF1ZW50aWFsUHJvY2Vzc2luZzogdHJ1ZX19KTtcbiAgICBpby5vbignY29ubmVjdCcsIHNvY2tldCA9PiB7XG4gICAgICBzZXJ2ZXIgPSBzb2NrZXQ7XG4gICAgICBpZiAoc29ja2V0LnJlcXVlc3QuX3F1ZXJ5WydhdXRoLXRva2VuJ10gIT09ICd0b2tlbicpIHtcbiAgICAgICAgc29ja2V0LmVtaXQoe2Vycm9yOiAnVW5hdXRob3JpemVkRXJyb3InLCBtZXNzYWdlOiAnQXV0aG9yaXphdGlvbiB0b2tlbiBpbnZhbGlkJ30pO1xuICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0UG9zaXRpb25zJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwb3NpdGlvbnM6IFtdfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF3YWl0IGNsaWVudC5nZXRQb3NpdGlvbnMoJ2FjY291bnRJZCcpO1xuICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3BhY2tldE9yZGVyZXIsICdyZXN0b3JlT3JkZXInKS5jYWxsc0Zha2UoKGFyZykgPT4ge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDIsIHNlcXVlbmNlTnVtYmVyOiAxfSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYyg1OTAwMCk7XG4gICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnb3JkZXJzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgb3JkZXJzOiBbXSwgaW5zdGFuY2VJbmRleDogMSxcbiAgICAgIGhvc3Q6ICdwcy1tcGEtMScsIHNlcXVlbmNlTnVtYmVyOiAyfSk7XG4gICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAncHJpY2VzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgcHJpY2VzOiBbe3N5bWJvbDogJ0VVUlVTRCd9XSwgXG4gICAgICBpbnN0YW5jZUluZGV4OiAxLCBob3N0OiAncHMtbXBhLTEnLCBlcXVpdHk6IDEwMCwgbWFyZ2luOiAyMDAsIGZyZWVNYXJnaW46IDQwMCwgbWFyZ2luTGV2ZWw6IDQwMDAwfSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYygzMDAwKTtcbiAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdwb3NpdGlvbnMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBwb3NpdGlvbnM6IFtdLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgaG9zdDogJ3BzLW1wYS0xJywgc2VxdWVuY2VOdW1iZXI6IDN9KTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDIwMDAwKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgcHJpY2VzQ2FsbFRpbWUuc2hvdWxkLm5vdC5lcWwoMCk7XG4gICAgKG9yZGVyc0NhbGxUaW1lKS5zaG91bGQuYmUuYWJvdmUocHJpY2VzQ2FsbFRpbWUpO1xuICAgIChkaXNjb25uZWN0ZWRDYWxsVGltZSkuc2hvdWxkLmJlLmFib3ZlKG9yZGVyc0NhbGxUaW1lKTtcbiAgICAocG9zaXRpb25zQ2FsbFRpbWUpLnNob3VsZC5iZS5hYm92ZShkaXNjb25uZWN0ZWRDYWxsVGltZSk7XG4gICAgY2xvY2sucmVzdG9yZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjcXVldWVQYWNrZXR9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCBwcm9jZXNzIG9sZCBzeW5jaHJvbml6YXRpb24gcGFja2V0IHdpdGhvdXQgZ2FwcyBpbiBzZXF1ZW5jZSBudW1iZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgIG9uU3luY2hyb25pemF0aW9uU3RhcnRlZDogc2lub24uZmFrZSgpLFxuICAgICAgb25QZW5kaW5nT3JkZXJzUmVwbGFjZWQ6IHNpbm9uLmZha2UoKSxcbiAgICAgIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZDogKCkgPT4ge31cbiAgICB9O1xuICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3BhY2tldE9yZGVyZXIsICdyZXN0b3JlT3JkZXInKS5jYWxsc0Zha2UoYXJnID0+IFthcmddKTtcblxuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIsICdhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMnKS5nZXQoKCkgPT4gWydBQkMnXSk7XG4gICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3luY2hyb25pemF0aW9uU3RhcnRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMSwgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxNzgsIHN5bmNocm9uaXphdGlvbklkOiAnQUJDJ30pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ29yZGVycycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIG9yZGVyczogW10sXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMiwgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxODEsIHN5bmNocm9uaXphdGlvbklkOiAnQUJDJ30pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkKTtcblxuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIsICdhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMnKS5nZXQoKCkgPT4gWydERUYnXSk7XG4gICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3luY2hyb25pemF0aW9uU3RhcnRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMywgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxOTAsIHN5bmNocm9uaXphdGlvbklkOiAnREVGJ30pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ29yZGVycycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIG9yZGVyczogW10sXG4gICAgICBzZXF1ZW5jZU51bWJlcjogNCwgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxOTIsIHN5bmNocm9uaXphdGlvbklkOiAnQUJDJ30pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ29yZGVycycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIG9yZGVyczogW10sXG4gICAgICBzZXF1ZW5jZU51bWJlcjogNSwgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxOTUsIHN5bmNocm9uaXphdGlvbklkOiAnREVGJ30pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVHdpY2UobGlzdGVuZXIub25TeW5jaHJvbml6YXRpb25TdGFydGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVHdpY2UobGlzdGVuZXIub25QZW5kaW5nT3JkZXJzUmVwbGFjZWQpO1xuICB9KTtcblxufSk7XG4iXX0=