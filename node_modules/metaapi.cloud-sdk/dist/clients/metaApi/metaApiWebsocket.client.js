'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

var _socket = require('socket.io-client');

var _socket2 = _interopRequireDefault(_socket);

var _timeoutError = require('../timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _errorHandler = require('../errorHandler');

var _optionsValidator = require('../optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _notSynchronizedError = require('./notSynchronizedError');

var _notSynchronizedError2 = _interopRequireDefault(_notSynchronizedError);

var _notConnectedError = require('./notConnectedError');

var _notConnectedError2 = _interopRequireDefault(_notConnectedError);

var _tradeError = require('./tradeError');

var _tradeError2 = _interopRequireDefault(_tradeError);

var _packetOrderer = require('./packetOrderer');

var _packetOrderer2 = _interopRequireDefault(_packetOrderer);

var _synchronizationThrottler = require('./synchronizationThrottler');

var _synchronizationThrottler2 = _interopRequireDefault(_synchronizationThrottler);

var _subscriptionManager = require('./subscriptionManager');

var _subscriptionManager2 = _interopRequireDefault(_subscriptionManager);

var _logger = require('../../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let PacketLogger;
if (typeof window === 'undefined') {
  // don't import PacketLogger for browser version
  PacketLogger = require('./packetLogger').default;
}

/**
 * MetaApi websocket API client (see https://metaapi.cloud/docs/client/websocket/overview/)
 */
class MetaApiWebsocketClient {

  /**
   * Constructs MetaApi websocket API client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {String} token authorization token
   * @param {Object} opts websocket client options
   */
  // eslint-disable-next-line complexity
  constructor(httpClient, token, opts) {
    const validator = new _optionsValidator2.default();
    opts = opts || {};
    opts.packetOrderingTimeout = validator.validateNonZero(opts.packetOrderingTimeout, 60, 'packetOrderingTimeout');
    opts.synchronizationThrottler = opts.synchronizationThrottler || {};
    this._httpClient = httpClient;
    this._application = opts.application || 'MetaApi';
    this._domain = opts.domain || 'agiliumtrade.agiliumtrade.ai';
    this._url = `https://mt-client-api-v1.${this._domain}`;
    this._requestTimeout = validator.validateNonZero(opts.requestTimeout, 60, 'requestTimeout') * 1000;
    this._connectTimeout = validator.validateNonZero(opts.connectTimeout, 60, 'connectTimeout') * 1000;
    const retryOpts = opts.retryOpts || {};
    this._retries = validator.validateNumber(retryOpts.retries, 5, 'retryOpts.retries');
    this._minRetryDelayInSeconds = validator.validateNonZero(retryOpts.minDelayInSeconds, 1, 'retryOpts.minDelayInSeconds');
    this._maxRetryDelayInSeconds = validator.validateNonZero(retryOpts.maxDelayInSeconds, 30, 'retryOpts.maxDelayInSeconds');
    this._maxAccountsPerInstance = 100;
    this._subscribeCooldownInSeconds = validator.validateNonZero(retryOpts.subscribeCooldownInSeconds, 600, 'retryOpts.subscribeCooldownInSeconds');
    const eventProcessing = opts.eventProcessing || {};
    this._sequentialEventProcessing = validator.validateBoolean(eventProcessing.sequentialProcessing, true, 'eventProcessing.sequentialProcessing');
    this._useSharedClientApi = validator.validateBoolean(opts.useSharedClientApi, false, 'useSharedClientApi');
    this._token = token;
    this._synchronizationListeners = {};
    this._latencyListeners = [];
    this._reconnectListeners = [];
    this._connectedHosts = {};
    this._socketInstances = [];
    this._socketInstancesByAccounts = {};
    this._synchronizationThrottlerOpts = opts.synchronizationThrottler;
    this._subscriptionManager = new _subscriptionManager2.default(this);
    this._statusTimers = {};
    this._eventQueues = {};
    this._synchronizationFlags = {};
    this._subscribeLock = null;
    this._firstConnect = true;
    this._packetOrderer = new _packetOrderer2.default(this, opts.packetOrderingTimeout);
    if (opts.packetLogger && opts.packetLogger.enabled) {
      this._packetLogger = new PacketLogger(opts.packetLogger);
      this._packetLogger.start();
    }
    this._logger = _logger2.default.getLogger('MetaApiWebsocketClient');
  }

  /**
   * Restarts the account synchronization process on an out of order packet
   * @param {String} accountId account id
   * @param {Number} instanceIndex instance index
   * @param {Number} expectedSequenceNumber expected s/n
   * @param {Number} actualSequenceNumber actual s/n
   * @param {Object} packet packet data
   * @param {Date} receivedAt time the packet was received at
   */
  onOutOfOrderPacket(accountId, instanceIndex, expectedSequenceNumber, actualSequenceNumber, packet, receivedAt) {
    this._logger.error('MetaApi websocket client received an out of order ' + `packet type ${packet.type} for account id ${accountId}:${instanceIndex}. Expected s/n ` + `${expectedSequenceNumber} does not match the actual of ${actualSequenceNumber}`);
    this.ensureSubscribe(accountId, instanceIndex);
  }

  /**
   * Patch server URL for use in unit tests
   * @param {String} url patched server URL
   */
  set url(url) {
    this._url = url;
  }

  /**
   * Returns the list of socket instance dictionaries
   * @return {Object[]} list of socket instance dictionaries
   */
  get socketInstances() {
    return this._socketInstances;
  }

  /**
   * Returns the dictionary of socket instances by account ids
   * @return {Object} dictionary of socket instances by account ids
   */
  get socketInstancesByAccounts() {
    return this._socketInstancesByAccounts;
  }

  /**
   * Returns the list of subscribed account ids
   * @param {String} socketInstanceIndex socket instance index
   * @return {string[]} list of subscribed account ids
   */
  subscribedAccountIds(socketInstanceIndex) {
    const connectedIds = [];
    (0, _keys2.default)(this._connectedHosts).forEach(instanceId => {
      const accountId = instanceId.split(':')[0];
      if (!connectedIds.includes(accountId) && this._socketInstancesByAccounts[accountId] !== undefined && (this._socketInstancesByAccounts[accountId] === socketInstanceIndex || socketInstanceIndex === undefined)) {
        connectedIds.push(accountId);
      }
    });
    return connectedIds;
  }

  /**
   * Returns websocket client connection status
   * @param socketInstanceIndex socket instance index
   * @returns {Boolean} websocket client connection status
   */
  connected(socketInstanceIndex) {
    const instance = this._socketInstances.length > socketInstanceIndex ? this._socketInstances[socketInstanceIndex] : null;
    return instance && instance.socket && instance.socket.connected || false;
  }

  /**
   * Returns list of accounts assigned to instance
   * @param socketInstanceIndex socket instance index
   * @returns 
   */
  getAssignedAccounts(socketInstanceIndex) {
    const accountIds = [];
    (0, _keys2.default)(this._socketInstancesByAccounts).forEach(key => {
      if (this._socketInstancesByAccounts[key] === socketInstanceIndex) {
        accountIds.push(key);
      }
    });
    return accountIds;
  }

  /**
   * Locks subscription for a socket instance based on TooManyRequestsError metadata
   * @param socketInstanceIndex socket instance index
   * @param metadata TooManyRequestsError metadata
   */
  async lockSocketInstance(socketInstanceIndex, metadata) {
    if (metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
      this._subscribeLock = {
        recommendedRetryTime: metadata.recommendedRetryTime,
        lockedAtAccounts: this.subscribedAccountIds().length,
        lockedAtTime: Date.now()
      };
    } else {
      const subscribedAccounts = this.subscribedAccountIds(socketInstanceIndex);
      if (subscribedAccounts.length === 0) {
        const socketInstance = this.socketInstances[socketInstanceIndex];
        socketInstance.socket.close();
        await this._reconnect(socketInstanceIndex);
      } else {
        const instance = this._socketInstances[socketInstanceIndex];
        instance.subscribeLock = {
          recommendedRetryTime: metadata.recommendedRetryTime,
          type: metadata.type,
          lockedAtAccounts: subscribedAccounts.length
        };
      }
    }
  }

  /**
   * Connects to MetaApi server via socket.io protocol
   * @returns {Promise} promise which resolves when connection is established
   */
  async connect() {
    let clientId = Math.random();
    let resolve, reject;
    let resolved = false;
    let result = new _promise2.default((res, rej) => {
      resolve = res;
      reject = rej;
    });
    const socketInstanceIndex = this._socketInstances.length;
    const instance = {
      id: socketInstanceIndex,
      connected: false,
      requestResolves: {},
      resolved: false,
      connectResult: result,
      sessionId: _randomstring2.default.generate(32),
      isReconnecting: false,
      socket: null,
      synchronizationThrottler: new _synchronizationThrottler2.default(this, socketInstanceIndex, this._synchronizationThrottlerOpts),
      subscribeLock: null
    };
    instance.connected = true;
    this._socketInstances.push(instance);
    const serverUrl = await this._getServerUrl();
    instance.synchronizationThrottler.start();
    const socketInstance = (0, _socket2.default)(serverUrl, {
      path: '/ws',
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
      timeout: this._connectTimeout,
      extraHeaders: {
        'Client-Id': clientId
      },
      query: {
        'auth-token': this._token,
        clientId: clientId,
        protocol: 2
      }
    });
    instance.socket = socketInstance;
    if (this._socketInstances.length === 1) {
      this._packetOrderer.start();
    }
    socketInstance.on('connect', async () => {
      // eslint-disable-next-line no-console
      this._logger.info('MetaApi websocket client connected to the MetaApi server');
      instance.isReconnecting = false;
      if (!resolved) {
        resolved = true;
        resolve();
      } else {
        await this._fireReconnected(instance.id);
      }
      if (!instance.connected) {
        instance.socket.close();
      }
    });
    socketInstance.on('reconnect', async () => {
      instance.isReconnecting = false;
      await this._fireReconnected(instance.id);
    });
    socketInstance.on('connect_error', err => {
      // eslint-disable-next-line no-console
      this._logger.error('MetaApi websocket client connection error', err);
      instance.isReconnecting = false;
      if (!resolved) {
        resolved = true;
        reject(err);
      }
    });
    socketInstance.on('connect_timeout', timeout => {
      // eslint-disable-next-line no-console
      this._logger.error('MetaApi websocket client connection timeout');
      instance.isReconnecting = false;
      if (!resolved) {
        resolved = true;
        reject(new _timeoutError2.default('MetaApi websocket client connection timed out'));
      }
    });
    socketInstance.on('disconnect', async reason => {
      instance.synchronizationThrottler.onDisconnect();
      // eslint-disable-next-line no-console
      this._logger.info('MetaApi websocket client disconnected from the MetaApi ' + 'server because of ' + reason);
      instance.isReconnecting = false;
      await this._reconnect(instance.id);
    });
    socketInstance.on('error', async error => {
      // eslint-disable-next-line no-console
      this._logger.error('MetaApi websocket client error', error);
      instance.isReconnecting = false;
      await this._reconnect(instance.id);
    });
    socketInstance.on('response', data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }
      this._logger.debug(() => `${data.accountId}: Response received: ${(0, _stringify2.default)({
        requestId: data.requestId, timestamps: data.timestamps })}`);
      let requestResolve = instance.requestResolves[data.requestId] || { resolve: () => {}, reject: () => {} };
      delete instance.requestResolves[data.requestId];
      this._convertIsoTimeToDate(data);
      requestResolve.resolve(data);
      if (data.timestamps && requestResolve.type) {
        data.timestamps.clientProcessingFinished = new Date();
        for (let listener of this._latencyListeners) {
          _promise2.default.resolve().then(() => requestResolve.type === 'trade' ? listener.onTrade(data.accountId, data.timestamps) : listener.onResponse(data.accountId, requestResolve.type, data.timestamps)).catch(error => this._logger.error('Failed to process onResponse event for account ' + data.accountId + ', request type ' + requestResolve.type, error));
        }
      }
    });
    socketInstance.on('processingError', data => {
      let requestResolve = instance.requestResolves[data.requestId] || { resolve: () => {}, reject: () => {} };
      delete instance.requestResolves[data.requestId];
      requestResolve.reject(this._convertError(data));
    });
    socketInstance.on('synchronization', async data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }
      this._logger.trace(() => `${data.accountId}:${data.instanceIndex}: Sync packet received: ${(0, _stringify2.default)({
        type: data.type, sequenceNumber: data.sequenceNumber, sequenceTimestamp: data.sequenceTimestamp,
        synchronizationId: data.synchronizationId, application: data.application, host: data.host })}`);
      if (!data.synchronizationId || instance.synchronizationThrottler.activeSynchronizationIds.includes(data.synchronizationId)) {
        if (this._packetLogger) {
          await this._packetLogger.logPacket(data);
        }
        this._convertIsoTimeToDate(data);
      } else {
        data.type = 'noop';
      }
      this.queuePacket(data);
    });
    return result;
  }

  /**
   * Closes connection to MetaApi server
   */
  close() {
    this._socketInstances.forEach(async instance => {
      if (instance.connected) {
        instance.connected = false;
        await instance.socket.close();
        for (let requestResolve of (0, _values2.default)(instance.requestResolves)) {
          requestResolve.reject(new Error('MetaApi connection closed'));
        }
        instance.requestResolves = {};
      }
    });
    this._synchronizationListeners = {};
    this._latencyListeners = [];
    this._socketInstancesByAccounts = {};
    this._socketInstances = [];
    this._packetOrderer.stop();
  }

  /**
   * MetaTrader account information (see https://metaapi.cloud/docs/client/models/metatraderAccountInformation/)
   * @typedef {Object} MetatraderAccountInformation
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} broker broker name
   * @property {String} currency account base currency ISO code
   * @property {String} server broker server name
   * @property {Number} balance account balance
   * @property {Number} equity account liquidation value
   * @property {Number} margin used margin
   * @property {Number} freeMargin free margin
   * @property {Number} leverage account leverage coefficient
   * @property {Number} marginLevel margin level calculated as % of equity/margin
   * @property {Boolean} tradeAllowed flag indicating that trading is allowed
   * @property {Boolean} [investorMode] flag indicating that investor password was used (supported for g2 only)
   * @property {String} marginMode margin calculation mode, one of ACCOUNT_MARGIN_MODE_EXCHANGE,
   * ACCOUNT_MARGIN_MODE_RETAIL_NETTING, ACCOUNT_MARGIN_MODE_RETAIL_HEDGING
   * @property {String} name Account owner name
   * @property {Number} login Account login
   * @property {Number} credit Account credit in the deposit currency
   */

  /**
   * Returns account information for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readAccountInformation/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */
  async getAccountInformation(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getAccountInformation' });
    return response.accountInformation;
  }

  /**
   * MetaTrader position
   * @typedef {Object} MetatraderPosition
   * @property {Number} id position id (ticket number)
   * @property {String} type position type (one of POSITION_TYPE_BUY, POSITION_TYPE_SELL)
   * @property {String} symbol position symbol
   * @property {Number} magic position magic number, identifies the EA which opened the position
   * @property {Date} time time position was opened at
   * @property {String} brokerTime time position was opened at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} updateTime last position modification time
   * @property {Number} openPrice position open price
   * @property {Number} currentPrice current price
   * @property {Number} currentTickValue current tick value
   * @property {Number} [stopLoss] optional position stop loss price
   * @property {Number} [takeProfit] optional position take profit price
   * @property {Number} volume position volume
   * @property {Number} swap position cumulative swap
   * @property {Number} profit position cumulative profit
   * @property {String} [comment] optional position comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} unrealizedProfit profit of the part of the position which is not yet closed, including swap
   * @property {Number} realizedProfit profit of the already closed part, including commissions and swap
   * @property {Number} commission position commission
   * @property {String} reason position opening reason. One of POSITION_REASON_CLIENT, POSITION_REASON_EXPERT,
   * POSITION_REASON_MOBILE, POSITION_REASON_WEB, POSITION_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties#enum_position_reason',
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {String} [originalComment] position original comment (present if possible to restore from history)
   * @property {String} [updatePending] flag indicating that position original comment and clientId was not identified
   * yet and will be updated in a future packet
   */

  /**
   * Returns positions for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPositions/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */
  async getPositions(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getPositions' });
    return response.positions;
  }

  /**
   * Returns specific position for a MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPosition/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */
  async getPosition(accountId, positionId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getPosition', positionId });
    return response.position;
  }

  /**
   * MetaTrader order
   * @typedef {Object} MetatraderOrder
   * @property {Number} id order id (ticket number)
   * @property {String} type order type (one of ORDER_TYPE_SELL, ORDER_TYPE_BUY, ORDER_TYPE_BUY_LIMIT,
   * ORDER_TYPE_SELL_LIMIT, ORDER_TYPE_BUY_STOP, ORDER_TYPE_SELL_STOP). See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type
   * @property {String} state order state one of (ORDER_STATE_STARTED, ORDER_STATE_PLACED, ORDER_STATE_CANCELED,
   * ORDER_STATE_PARTIAL, ORDER_STATE_FILLED, ORDER_STATE_REJECTED, ORDER_STATE_EXPIRED, ORDER_STATE_REQUEST_ADD,
   * ORDER_STATE_REQUEST_MODIFY, ORDER_STATE_REQUEST_CANCEL). See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_state
   * @property {Number} magic order magic number, identifies the EA which created the order
   * @property {Date} time time order was created at
   * @property {String} brokerTime time time order was created at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} [doneTime] time order was executed or canceled at. Will be specified for
   * completed orders only
   * @property {String} [doneBrokerTime] time order was executed or canceled at, in broker timezone,
   * YYYY-MM-DD HH:mm:ss.SSS format. Will be specified for completed orders only
   * @property {String} symbol order symbol
   * @property {Number} openPrice order open price (market price for market orders, limit price for limit orders or stop
   * price for stop orders)
   * @property {Number} currentPrice current price
   * @property {Number} [stopLoss] order stop loss price
   * @property {Number} [takeProfit] order take profit price
   * @property {Number} volume order requested quantity
   * @property {Number} currentVolume order remaining quantity, i.e. requested quantity - filled quantity
   * @property {String} positionId order position id. Present only if the order has a position attached to it
   * @property {String} [comment] order comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} originalComment optional order original comment (present if possible to restore original comment
   * from history)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {Boolean} [updatePending] flag indicating that order client id and original comment was not
   * identified yet and will be updated in a future synchronization packet
   * @property {String} reason order opening reason. One of ORDER_REASON_CLIENT, ORDER_REASON_MOBILE, ORDER_REASON_WEB,
   * ORDER_REASON_EXPERT, ORDER_REASON_SL, ORDER_REASON_TP, ORDER_REASON_SO, ORDER_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_reason.
   * @property {String} fillingMode order filling mode. One of ORDER_FILLING_FOK, ORDER_FILLING_IOC,
   * ORDER_FILLING_RETURN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling.
   * @property {String} expirationType order expiration type. One of ORDER_TIME_GTC, ORDER_TIME_DAY,
   * ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time
   * @property {Date} expirationTime optional order expiration time
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {String} [closeByPositionId] identifier of an opposite position used for closing by order
   * ORDER_TYPE_CLOSE_BY
   * @property {Number} [stopLimitPrice] the Limit order price for the StopLimit order
   */

  /**
   * Returns open orders for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrders/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */
  async getOrders(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getOrders' });
    return response.orders;
  }

  /**
   * Returns specific open order for a MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrder/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} orderId order id (ticket number)
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */
  async getOrder(accountId, orderId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getOrder', orderId });
    return response.order;
  }

  /**
   * MetaTrader history orders search query response
   * @typedef {Object} MetatraderHistoryOrders
   * @property {Array<MetatraderOrder>} historyOrders array of history orders returned
   * @property {Boolean} synchronizing flag indicating that history order initial synchronization is still in progress
   * and thus search results may be incomplete
   */

  /**
   * Returns the history of completed orders for a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTicket/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByTicket(accountId, ticket) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByTicket', ticket });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns the history of completed orders for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByPosition/)
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByPosition(accountId, positionId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByPosition',
      positionId });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns the history of completed orders for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTimeRange/)
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByTimeRange',
      startTime, endTime, offset, limit });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * MetaTrader history deals search query response
   * @typedef {Object} MetatraderDeals
   * @property {Array<MetatraderDeal>} deals array of history deals returned
   * @property {Boolean} synchronizing flag indicating that deal initial synchronization is still in progress
   * and thus search results may be incomplete
   */

  /**
   * MetaTrader deal
   * @typedef {Object} MetatraderDeal
   * @property {String} id deal id (ticket number)
   * @property {String} type deal type (one of DEAL_TYPE_BUY, DEAL_TYPE_SELL, DEAL_TYPE_BALANCE, DEAL_TYPE_CREDIT,
   * DEAL_TYPE_CHARGE, DEAL_TYPE_CORRECTION, DEAL_TYPE_BONUS, DEAL_TYPE_COMMISSION, DEAL_TYPE_COMMISSION_DAILY,
   * DEAL_TYPE_COMMISSION_MONTHLY, DEAL_TYPE_COMMISSION_AGENT_DAILY, DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
   * DEAL_TYPE_INTEREST, DEAL_TYPE_BUY_CANCELED, DEAL_TYPE_SELL_CANCELED, DEAL_DIVIDEND, DEAL_DIVIDEND_FRANKED,
   * DEAL_TAX). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_type
   * @property {String} entryType deal entry type (one of DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT,
   * DEAL_ENTRY_OUT_BY). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_entry
   * @property {String} [symbol] symbol deal relates to
   * @property {Number} [magic] deal magic number, identifies the EA which initiated the deal
   * @property {Date} time time the deal was conducted at
   * @property {String} brokerTime time time the deal was conducted at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Number} [volume] deal volume
   * @property {Number} [price] the price the deal was conducted at
   * @property {Number} [commission] deal commission
   * @property {Number} [swap] deal swap
   * @property {Number} profit deal profit
   * @property {String} [positionId] id of position the deal relates to
   * @property {String} [orderId] id of order the deal relates to
   * @property {String} [comment] deal comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [originalComment] deal original comment (present if possible to restore original comment
   * from history)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {Boolean} [updatePending] flag indicating that deal client id and original comment was not
   * identified yet and will be updated in a future synchronization packet
   * @property {String} [reason] optional deal execution reason. One of DEAL_REASON_CLIENT, DEAL_REASON_MOBILE,
   * DEAL_REASON_WEB, DEAL_REASON_EXPERT, DEAL_REASON_SL, DEAL_REASON_TP, DEAL_REASON_SO, DEAL_REASON_ROLLOVER,
   * DEAL_REASON_VMARGIN, DEAL_REASON_SPLIT, DEAL_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_reason.
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   */

  /**
   * Returns history deals with a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTicket/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByTicket(accountId, ticket) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getDealsByTicket', ticket });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns history deals for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByPosition/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByPosition(accountId, positionId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getDealsByPosition', positionId });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns history deals with for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTimeRange/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getDealsByTimeRange', startTime,
      endTime, offset, limit });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Clears the order and transaction history of a specified application so that it can be synchronized from scratch
   * (see https://metaapi.cloud/docs/client/websocket/api/removeHistory/).
   * @param {String} accountId id of the MetaTrader account to remove history for
   * @param {String} [application] application to remove history for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeHistory(accountId, application) {
    return this._rpcRequest(accountId, { application, type: 'removeHistory' });
  }

  /**
   * Clears the order and transaction history of a specified application and removes the application (see
   * https://metaapi.cloud/docs/client/websocket/api/removeApplication/).
   * @param {String} accountId id of the MetaTrader account to remove history and application for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeApplication(accountId) {
    return this._rpcRequest(accountId, { type: 'removeApplication' });
  }

  /**
   * MetaTrader trade response
   * @typedef {Object} MetatraderTradeResponse
   * @property {Number} numericCode numeric response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are 0, 10008-10010, 10025. The rest
   * codes are errors
   * @property {String} stringCode string response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are ERR_NO_ERROR,
   * TRADE_RETCODE_PLACED, TRADE_RETCODE_DONE, TRADE_RETCODE_DONE_PARTIAL, TRADE_RETCODE_NO_CHANGES. The rest codes are
   * errors.
   * @property {String} message human-readable response message
   * @property {String} orderId order id which was created/modified during the trade
   * @property {String} positionId position id which was modified during the trade
   */

  /**
   * Execute a trade on a connected MetaTrader account (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {String} accountId id of the MetaTrader account to execute trade for
   * @param {MetatraderTrade} trade trade to execute (see docs for possible trade types)
   * @returns {Promise<MetatraderTradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  async trade(accountId, trade) {
    let response = await this._rpcRequest(accountId, { type: 'trade', trade });
    response.response = response.response || {};
    response.response.stringCode = response.response.stringCode || response.response.description;
    response.response.numericCode = response.response.numericCode !== undefined ? response.response.numericCode : response.response.error;
    if (['ERR_NO_ERROR', 'TRADE_RETCODE_PLACED', 'TRADE_RETCODE_DONE', 'TRADE_RETCODE_DONE_PARTIAL', 'TRADE_RETCODE_NO_CHANGES'].includes(response.response.stringCode || response.response.description)) {
      return response.response;
    } else {
      throw new _tradeError2.default(response.response.message, response.response.numericCode, response.response.stringCode);
    }
  }

  /**
   * Creates a task that ensures the account gets subscribed to the server
   * @param {String} accountId account id to subscribe
   * @param {Number} [instanceNumber] instance index number
   */
  ensureSubscribe(accountId, instanceNumber) {
    this._subscriptionManager.subscribe(accountId, instanceNumber);
  }

  /**
   * Subscribes to the Metatrader terminal events (see https://metaapi.cloud/docs/client/websocket/api/subscribe/).
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} [instanceNumber] instance index number
   * @returns {Promise} promise which resolves when subscription started
   */
  subscribe(accountId, instanceNumber) {
    return this._rpcRequest(accountId, { type: 'subscribe', instanceIndex: instanceNumber });
  }

  /**
   * Reconnects to the Metatrader terminal (see https://metaapi.cloud/docs/client/websocket/api/reconnect/).
   * @param {String} accountId id of the MetaTrader account to reconnect
   * @returns {Promise} promise which resolves when reconnection started
   */
  reconnect(accountId) {
    return this._rpcRequest(accountId, { type: 'reconnect' });
  }

  /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/).
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceIndex instance index
   * @param {String} host name of host to synchronize with
   * @param {String} synchronizationId synchronization request id
   * @param {Date} startingHistoryOrderTime from what date to start synchronizing history orders from. If not specified,
   * the entire order history will be downloaded.
   * @param {Date} startingDealTime from what date to start deal synchronization from. If not specified, then all
   * history deals will be downloaded.
   * @param {String} specificationsMd5 specifications MD5 hash
   * @param {String} positionsMd5 positions MD5 hash
   * @param {String} ordersMd5 orders MD5 hash
   * @returns {Promise} promise which resolves when synchronization started
   */
  synchronize(accountId, instanceIndex, host, synchronizationId, startingHistoryOrderTime, startingDealTime, specificationsMd5, positionsMd5, ordersMd5) {
    const syncThrottler = this._socketInstances[this._socketInstancesByAccounts[accountId]].synchronizationThrottler;
    return syncThrottler.scheduleSynchronize(accountId, { requestId: synchronizationId,
      type: 'synchronize', startingHistoryOrderTime, startingDealTime, instanceIndex, host,
      specificationsMd5, positionsMd5, ordersMd5 });
  }

  /**
   * Waits for server-side terminal state synchronization to complete.
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/waitSynchronized/).
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceNumber instance index number
   * @param {String} applicationPattern MetaApi application regular expression pattern, default is .*
   * @param {Number} timeoutInSeconds timeout in seconds, default is 300 seconds
   * @returns {Promise} promise which resolves when synchronization started
   */
  waitSynchronized(accountId, instanceNumber, applicationPattern, timeoutInSeconds) {
    return this._rpcRequest(accountId, { type: 'waitSynchronized', applicationPattern, timeoutInSeconds,
      instanceIndex: instanceNumber }, timeoutInSeconds + 1);
  }

  /**
   * Market data subscription
   * @typedef {Object} MarketDataSubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   * @property {string} [timeframe] when subscription type is candles, defines the timeframe according to which the
   * candles must be generated. Allowed values for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h,
   * 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @property {number} [intervalInMilliseconds] defines how frequently the terminal will stream data to client. If not
   * set, then the value configured in account will be used
   */

  /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update
   * @returns {Promise} promise which resolves when subscription request was processed
   */
  subscribeToMarketData(accountId, instanceNumber, symbol, subscriptions) {
    return this._rpcRequest(accountId, { type: 'subscribeToMarketData', symbol, subscriptions,
      instanceIndex: instanceNumber });
  }

  /**
   * Refreshes market data subscriptions on the server to prevent them from expiring
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Array} subscriptions array of subscriptions to refresh
   */
  refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptions) {
    return this._rpcRequest(accountId, { type: 'refreshMarketDataSubscriptions', subscriptions,
      instanceIndex: instanceNumber });
  }

  /**
   * Market data unsubscription
   * @typedef {Object} MarketDataUnsubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   */

  /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */
  unsubscribeFromMarketData(accountId, instanceNumber, symbol, subscriptions) {
    return this._rpcRequest(accountId, { type: 'unsubscribeFromMarketData', symbol, subscriptions,
      instanceIndex: instanceNumber });
  }

  /**
   * Retrieves symbols available on an account (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbols/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */
  async getSymbols(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getSymbols' });
    return response.symbols;
  }

  /**
   * Retrieves specification for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolSpecification/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol specification for
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */
  async getSymbolSpecification(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getSymbolSpecification', symbol });
    return response.specification;
  }

  /**
   * Retrieves price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolPrice/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {String} symbol symbol to retrieve price for
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */
  async getSymbolPrice(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getSymbolPrice', symbol });
    return response.price;
  }

  /**
   * Retrieves price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readCandle/).
   * @param {string} accountId id of the MetaTrader account to retrieve candle for
   * @param {string} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */
  async getCandle(accountId, symbol, timeframe) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getCandle', symbol, timeframe });
    return response.candle;
  }

  /**
   * Retrieves latest tick for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readTick/).
   * @param {string} accountId id of the MetaTrader account to retrieve symbol tick for
   * @param {string} symbol symbol to retrieve tick for
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */
  async getTick(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getTick', symbol });
    return response.tick;
  }

  /**
   * Retrieves latest order book for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readBook/).
   * @param {string} accountId id of the MetaTrader account to retrieve symbol order book for
   * @param {string} symbol symbol to retrieve order book for
   * @returns {Promise<MetatraderBook>} promise which resolves when order book is retrieved
   */
  async getBook(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getBook', symbol });
    return response.book;
  }

  /**
   * Sends client uptime stats to the server.
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */
  saveUptime(accountId, uptime) {
    return this._rpcRequest(accountId, { type: 'saveUptime', uptime });
  }

  /**
   * Unsubscribe from account (see
   * https://metaapi.cloud/docs/client/websocket/api/synchronizing/unsubscribe).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @returns {Promise} promise which resolves when socket unsubscribed
   */
  async unsubscribe(accountId) {
    this._subscriptionManager.cancelAccount(accountId);
    try {
      await this._rpcRequest(accountId, { type: 'unsubscribe' });
      delete this._socketInstancesByAccounts[accountId];
    } catch (err) {
      if (!(err instanceof _errorHandler.NotFoundError)) {
        throw err;
      }
    }
  }

  /**
   * Adds synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to add
   */
  addSynchronizationListener(accountId, listener) {
    let listeners = this._synchronizationListeners[accountId];
    if (!listeners) {
      listeners = [];
      this._synchronizationListeners[accountId] = listeners;
    }
    listeners.push(listener);
  }

  /**
   * Removes synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to remove
   */
  removeSynchronizationListener(accountId, listener) {
    let listeners = this._synchronizationListeners[accountId];
    if (!listeners) {
      listeners = [];
    }
    listeners = listeners.filter(l => l !== listener);
    this._synchronizationListeners[accountId] = listeners;
  }

  /**
   * Adds latency listener
   * @param {LatencyListener} listener latency listener to add
   */
  addLatencyListener(listener) {
    this._latencyListeners.push(listener);
  }

  /**
   * Removes latency listener
   * @param {LatencyListener} listener latency listener to remove
   */
  removeLatencyListener(listener) {
    this._latencyListeners = this._latencyListeners.filter(l => l !== listener);
  }

  /**
   * Adds reconnect listener
   * @param {ReconnectListener} listener reconnect listener to add
   * @param {String} accountId account id of listener
   */
  addReconnectListener(listener, accountId) {
    this._reconnectListeners.push({ accountId, listener });
  }

  /**
   * Removes reconnect listener
   * @param {ReconnectListener} listener listener to remove
   */
  removeReconnectListener(listener) {
    this._reconnectListeners = this._reconnectListeners.filter(l => l.listener !== listener);
  }

  /**
   * Removes all listeners. Intended for use in unit tests.
   */
  removeAllListeners() {
    this._synchronizationListeners = {};
    this._reconnectListeners = [];
  }

  /**
   * Queues an account packet for processing
   * @param {Object} packet packet to process
   */
  queuePacket(packet) {
    const accountId = packet.accountId;
    const packets = this._packetOrderer.restoreOrder(packet).filter(p => p.type !== 'noop');
    if (this._sequentialEventProcessing && packet.sequenceNumber !== undefined) {
      const events = packets.map(packetItem => () => _promise2.default.resolve(this._processSynchronizationPacket(packetItem)));
      if (!this._eventQueues[accountId]) {
        this._eventQueues[accountId] = events;
        this._callAccountEvents(accountId);
      } else {
        this._eventQueues[accountId] = this._eventQueues[accountId].concat(events);
      }
    } else {
      packets.forEach(packetItem => this._processSynchronizationPacket(packetItem));
    }
  }

  /**
   * Queues account event for processing
   * @param {String} accountId account id
   * @param {Promise} event event to execute
   */
  queueEvent(accountId, event) {
    if (this._sequentialEventProcessing) {
      if (!this._eventQueues[accountId]) {
        this._eventQueues[accountId] = [event];
        this._callAccountEvents(accountId);
      } else {
        this._eventQueues[accountId].push(event);
      }
    } else {
      event();
    }
  }

  async _callAccountEvents(accountId) {
    if (this._eventQueues[accountId]) {
      while (this._eventQueues[accountId].length) {
        await this._eventQueues[accountId][0]();
        this._eventQueues[accountId].shift();
      }
      delete this._eventQueues[accountId];
    }
  }

  async _reconnect(socketInstanceIndex) {
    const instance = this.socketInstances[socketInstanceIndex];
    if (instance) {
      while (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
        await this._tryReconnect(socketInstanceIndex);
      }
    }
  }

  _tryReconnect(socketInstanceIndex) {
    const instance = this.socketInstances[socketInstanceIndex];
    return new _promise2.default(resolve => setTimeout(async () => {
      if (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
        try {
          instance.sessionId = _randomstring2.default.generate(32);
          const clientId = Math.random();
          instance.socket.close();
          instance.socket.io.opts.extraHeaders['Client-Id'] = clientId;
          instance.socket.io.opts.query.clientId = clientId;
          instance.isReconnecting = true;
          instance.socket.io.uri = await this._getServerUrl();
          instance.socket.connect();
        } catch (error) {
          instance.isReconnecting = false;
        }
      }
      resolve();
    }, 1000));
  }

  //eslint-disable-next-line complexity, max-statements
  async _rpcRequest(accountId, request, timeoutInSeconds) {
    let socketInstanceIndex = null;
    if (this._socketInstancesByAccounts[accountId] !== undefined) {
      socketInstanceIndex = this._socketInstancesByAccounts[accountId];
    } else {
      while (this._subscribeLock && (new Date(this._subscribeLock.recommendedRetryTime).getTime() > Date.now() && this.subscribedAccountIds().length < this._subscribeLock.lockedAtAccounts || new Date(this._subscribeLock.lockedAtTime).getTime() + this._subscribeCooldownInSeconds * 1000 > Date.now() && this.subscribedAccountIds().length >= this._subscribeLock.lockedAtAccounts)) {
        await new _promise2.default(res => setTimeout(res, 1000));
      }
      for (let index = 0; index < this._socketInstances.length; index++) {
        const accountCounter = this.getAssignedAccounts(index).length;
        const instance = this.socketInstances[index];
        if (instance.subscribeLock) {
          if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER' && (new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() || this.subscribedAccountIds(index).length >= instance.subscribeLock.lockedAtAccounts)) {
            continue;
          }
          if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER' && new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() && this.subscribedAccountIds(index).length >= instance.subscribeLock.lockedAtAccounts) {
            continue;
          }
        }
        if (accountCounter < this._maxAccountsPerInstance) {
          socketInstanceIndex = index;
          break;
        }
      }
      if (socketInstanceIndex === null) {
        socketInstanceIndex = this._socketInstances.length;
        await this.connect();
      }
      this._socketInstancesByAccounts[accountId] = socketInstanceIndex;
    }
    const instance = this._socketInstances[socketInstanceIndex];
    if (!instance.connected) {
      await this.connect();
    } else if (!this.connected(socketInstanceIndex)) {
      await instance.connectResult;
    }
    if (request.type === 'subscribe') {
      request.sessionId = instance.sessionId;
    }
    if (['trade', 'subscribe'].includes(request.type)) {
      return this._makeRequest(accountId, request, timeoutInSeconds);
    }
    let retryCounter = 0;
    while (true) {
      //eslint-disable-line no-constant-condition
      try {
        return await this._makeRequest(accountId, request, timeoutInSeconds);
      } catch (err) {
        if (err.name === 'TooManyRequestsError') {
          let calcRetryCounter = retryCounter;
          let calcRequestTime = 0;
          while (calcRetryCounter < this._retries) {
            calcRetryCounter++;
            calcRequestTime += Math.min(Math.pow(2, calcRetryCounter) * this._minRetryDelayInSeconds, this._maxRetryDelayInSeconds) * 1000;
          }
          const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
          if (Date.now() + calcRequestTime > retryTime && retryCounter < this._retries) {
            if (Date.now() < retryTime) {
              await new _promise2.default(res => setTimeout(res, retryTime - Date.now()));
            }
            retryCounter++;
          } else {
            throw err;
          }
        } else if (['NotSynchronizedError', 'TimeoutError', 'NotAuthenticatedError', 'InternalError'].includes(err.name) && retryCounter < this._retries) {
          await new _promise2.default(res => setTimeout(res, Math.min(Math.pow(2, retryCounter) * this._minRetryDelayInSeconds, this._maxRetryDelayInSeconds) * 1000));
          retryCounter++;
        } else {
          throw err;
        }
        if (this._socketInstancesByAccounts[accountId] === undefined) {
          throw err;
        }
      }
    }
  }

  _makeRequest(accountId, request, timeoutInSeconds) {
    const socketInstance = this._socketInstances[this._socketInstancesByAccounts[accountId]];
    let requestId = request.requestId || _randomstring2.default.generate(32);
    request.timestamps = { clientProcessingStarted: new Date() };
    let result = _promise2.default.race([new _promise2.default((resolve, reject) => socketInstance.requestResolves[requestId] = { resolve, reject, type: request.type }), new _promise2.default((resolve, reject) => setTimeout(() => reject(new _timeoutError2.default('MetaApi websocket client ' + `request ${request.requestId} of type ${request.type} timed out. Please make sure your account is connected ` + 'to broker before retrying your request.')), timeoutInSeconds * 1000 || this._requestTimeout))]);
    request.accountId = accountId;
    request.application = request.application || this._application;
    if (!request.requestId) {
      request.requestId = requestId;
    }
    this._logger.debug(() => `${accountId}: Sending request: ${(0, _stringify2.default)(request)}`);
    socketInstance.socket.emit('request', request);
    return result;
  }

  // eslint-disable-next-line complexity
  _convertError(data) {
    if (data.error === 'ValidationError') {
      return new _errorHandler.ValidationError(data.message, data.details);
    } else if (data.error === 'NotFoundError') {
      return new _errorHandler.NotFoundError(data.message);
    } else if (data.error === 'NotSynchronizedError') {
      return new _notSynchronizedError2.default(data.message);
    } else if (data.error === 'TimeoutError') {
      return new _timeoutError2.default(data.message);
    } else if (data.error === 'NotAuthenticatedError') {
      return new _notConnectedError2.default(data.message);
    } else if (data.error === 'TradeError') {
      return new _tradeError2.default(data.message, data.numericCode, data.stringCode);
    } else if (data.error === 'UnauthorizedError') {
      this.close();
      return new _errorHandler.UnauthorizedError(data.message);
    } else if (data.error === 'TooManyRequestsError') {
      return new _errorHandler.TooManyRequestsError(data.message, data.metadata);
    } else {
      return new _errorHandler.InternalError(data.message);
    }
  }

  // eslint-disable-next-line complexity
  _convertIsoTimeToDate(packet) {
    // eslint-disable-next-line guard-for-in
    for (let field in packet) {
      let value = packet[field];
      if (typeof value === 'string' && field.match(/time$|Time$/) && !field.match(/brokerTime$|BrokerTime$|timeframe$/)) {
        packet[field] = new Date(value);
      }
      if (Array.isArray(value)) {
        for (let item of value) {
          this._convertIsoTimeToDate(item);
        }
      }
      if (typeof value === 'object') {
        this._convertIsoTimeToDate(value);
      }
    }
    if (packet && packet.timestamps) {
      // eslint-disable-next-line guard-for-in
      for (let field in packet.timestamps) {
        packet.timestamps[field] = new Date(packet.timestamps[field]);
      }
    }
    if (packet && packet.type === 'prices') {
      for (let price of packet.prices || []) {
        if (price.timestamps) {
          // eslint-disable-next-line guard-for-in
          for (let field in price.timestamps) {
            price.timestamps[field] = new Date(price.timestamps[field]);
          }
        }
      }
    }
  }

  /**
   * MetaTrader symbol specification. Contains symbol specification (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolSpecification/)
   * @typedef {Object} MetatraderSymbolSpecification
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} tickSize tick size
   * @property {Number} minVolume minimum order volume for the symbol
   * @property {Number} maxVolume maximum order volume for the symbol
   * @property {Number} volumeStep order volume step for the symbol
   * @property {Array<String>} list of allowed order filling modes. Can contain ORDER_FILLING_FOK, ORDER_FILLING_IOC or
   * both. See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode for more
   * details.
   * @property {String} deal execution mode. Possible values are SYMBOL_TRADE_EXECUTION_REQUEST,
   * SYMBOL_TRADE_EXECUTION_INSTANT, SYMBOL_TRADE_EXECUTION_MARKET, SYMBOL_TRADE_EXECUTION_EXCHANGE. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_execution for more
   * details.
   * @property {Number} contractSize trade contract size
   * @property {MetatraderSessions} quoteSessions quote sessions, indexed by day of week
   * @property {MetatraderSessions} tradeSessions trade sessions, indexed by day of week
   * @property {String} [tradeMode] order execution type. Possible values are SYMBOL_TRADE_MODE_DISABLED,
   * SYMBOL_TRADE_MODE_LONGONLY, SYMBOL_TRADE_MODE_SHORTONLY, SYMBOL_TRADE_MODE_CLOSEONLY, SYMBOL_TRADE_MODE_FULL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_mode for more
   * details
   * @property {Number} [bondAccruedInterest] accrued interest – accumulated coupon interest, i.e. part of the coupon
   * interest calculated in proportion to the number of days since the coupon bond issuance or the last coupon interest
   * payment
   * @property {Number} [bondFaceValue] face value – initial bond value set by the issuer
   * @property {Number} [optionStrike] the strike price of an option. The price at which an option buyer can buy (in a
   * Call option) or sell (in a Put option) the underlying asset, and the option seller is obliged to sell or buy the
   * appropriate amount of the underlying asset.
   * @property {Number} [optionPriceSensivity] option/warrant sensitivity shows by how many points the price of the
   * option's underlying asset should change so that the price of the option changes by one point
   * @property {Number} [liquidityRate] liquidity Rate is the share of the asset that can be used for the margin
   * @property {Number} initialMargin initial margin means the amount in the margin currency required for opening a
   * position with the volume of one lot. It is used for checking a client's assets when he or she enters the market
   * @property {Number} maintenanceMargin the maintenance margin. If it is set, it sets the margin amount in the margin
   * currency of the symbol, charged from one lot. It is used for checking a client's assets when his/her account state
   * changes. If the maintenance margin is equal to 0, the initial margin is used
   * @property {Number} hedgedMargin contract size or margin value per one lot of hedged positions (oppositely directed
   * positions of one symbol). Two margin calculation methods are possible for hedged positions. The calculation method
   * is defined by the broker
   * @property {Boolean} [hedgedMarginUsesLargerLeg] calculating hedging margin using the larger leg (Buy or Sell)
   * @properties {String} marginCurrency margin currency
   * @property {String} priceCalculationMode contract price calculation mode. One of SYMBOL_CALC_MODE_UNKNOWN,
   * SYMBOL_CALC_MODE_FOREX, SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE, SYMBOL_CALC_MODE_FUTURES, SYMBOL_CALC_MODE_CFD,
   * SYMBOL_CALC_MODE_CFDINDEX, SYMBOL_CALC_MODE_CFDLEVERAGE, SYMBOL_CALC_MODE_EXCH_STOCKS,
   * SYMBOL_CALC_MODE_EXCH_FUTURES, SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS, SYMBOL_CALC_MODE_EXCH_BONDS,
   * SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX, SYMBOL_CALC_MODE_EXCH_BONDS_MOEX, SYMBOL_CALC_MODE_SERV_COLLATERAL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_calc_mode for more details
   * @property {String} baseCurrency base currency
   * @property {String} [profitCurrency] profit currency
   * @property {String} swapMode swap calculation model. Allowed values are SYMBOL_SWAP_MODE_DISABLED,
   * SYMBOL_SWAP_MODE_POINTS, SYMBOL_SWAP_MODE_CURRENCY_SYMBOL, SYMBOL_SWAP_MODE_CURRENCY_MARGIN,
   * SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT, SYMBOL_SWAP_MODE_INTEREST_CURRENT, SYMBOL_SWAP_MODE_INTEREST_OPEN,
   * SYMBOL_SWAP_MODE_REOPEN_CURRENT, SYMBOL_SWAP_MODE_REOPEN_BID. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_swap_mode for more details
   * @property {Number} [swapLong] long swap value
   * @property {Number} [swapShort] short swap value
   * @property {String} [swapRollover3Days] day of week to charge 3 days swap rollover. Allowed values are SUNDAY,
   * MONDAY, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, NONE
   * @property {Array<String>} allowedExpirationModes allowed order expiration modes. Allowed values are
   * SYMBOL_EXPIRATION_GTC, SYMBOL_EXPIRATION_DAY, SYMBOL_EXPIRATION_SPECIFIED, SYMBOL_EXPIRATION_SPECIFIED_DAY.
   * See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_expiration_mode for more
   * details
   * @property {Array<String>} allowedOrderTypes allowed order types. Allowed values are SYMBOL_ORDER_MARKET,
   * SYMBOL_ORDER_LIMIT, SYMBOL_ORDER_STOP, SYMBOL_ORDER_STOP_LIMIT, SYMBOL_ORDER_SL, SYMBOL_ORDER_TP,
   * SYMBOL_ORDER_CLOSEBY. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_order_mode for more details
   * @property {String} orderGTCMode if the expirationMode property is set to SYMBOL_EXPIRATION_GTC (good till
   * canceled), the expiration of pending orders, as well as of Stop Loss/Take Profit orders should be additionally set
   * using this enumeration. Allowed values are SYMBOL_ORDERS_GTC, SYMBOL_ORDERS_DAILY,
   * SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_order_gtc_mode for more
   * details
   * @property {Number} digits digits after a decimal point
   * @property {String} [path] path in the symbol tree
   * @property {String} description symbol description
   * @property {Date} [startTime] date of the symbol trade beginning (usually used for futures)
   * @property {Date} [expirationTime] date of the symbol trade end (usually used for futures)
   */

  /**
   * Metatrader trade or quote session container, indexed by weekday
   * @typedef {Object} MetatraderSessions
   * @property {Array<MetatraderSession>} [SUNDAY] array of sessions for SUNDAY
   * @property {Array<MetatraderSession>} [MONDAY] array of sessions for MONDAY
   * @property {Array<MetatraderSession>} [TUESDAY] array of sessions for TUESDAY
   * @property {Array<MetatraderSession>} [WEDNESDAY] array of sessions for WEDNESDAY
   * @property {Array<MetatraderSession>} [THURSDAY] array of sessions for THURSDAY
   * @property {Array<MetatraderSession>} [FRIDAY] array of sessions for FRIDAY
   * @property {Array<MetatraderSession>} [SATURDAY] array of sessions for SATURDAY
   */

  /**
   * Metatrader trade or quote session
   * @typedef {Object} MetatraderSession
   * @property {String} from session start time, in hh.mm.ss.SSS format
   * @property {String} to session end time, in hh.mm.ss.SSS format
   */

  /**
   * MetaTrader symbol price. Contains current price for a symbol (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolPrice/)
   * @typedef {Object} MetatraderSymbolPrice
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} bid bid price
   * @property {Number} ask ask price
   * @property {Number} profitTickValue tick value for a profitable position
   * @property {Number} lossTickValue tick value for a losing position
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {Date} time quote time, in ISO format
   * @property {String} brokerTime time quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */

  /**
   * MetaTrader candle
   * @typedef {Object} MetatraderCandle
   * @property {string} symbol symbol (e.g. currency pair or an index)
   * @property {string} timeframe timeframe candle was generated for, e.g. 1h. One of 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m,
   * 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn
   * @property {Date} time candle opening time
   * @property {string} brokerTime candle opening time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} open open price
   * @property {number} high high price
   * @property {number} low low price
   * @property {number} close close price
   * @property {number} tickVolume tick volume, i.e. number of ticks inside the candle
   * @property {number} spread spread in points
   * @property {number} volume trade volume
   */

  /**
   * MetaTrader tick data
   * @typedef {Object} MetatraderTick
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} [bid] bid price
   * @property {number} [ask] ask price
   * @property {number} [last] last deal price
   * @property {number} [volume] volume for the current last deal price
   * @property {string} side is tick a result of buy or sell deal, one of buy or sell
   */

  /**
   * MetaTrader order book
   * @typedef {Object} MetatraderBook
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Array<MetatraderBookEntry>} book list of order book entries
   */

  /**
   * MetaTrader order book entry
   * @typedef {Object} MetatraderBookEntry
   * @property {string} type entry type, one of BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET,
   * BOOK_TYPE_BUY_MARKET
   * @property {number} price price
   * @property {number} volume volume
   */

  // eslint-disable-next-line complexity,max-statements
  async _processSynchronizationPacket(data) {
    try {
      const socketInstance = this._socketInstances[this._socketInstancesByAccounts[data.accountId]];
      if (data.synchronizationId && socketInstance) {
        socketInstance.synchronizationThrottler.updateSynchronizationId(data.synchronizationId);
      }
      const instanceNumber = data.instanceIndex || 0;
      let instanceId = data.accountId + ':' + instanceNumber + ':' + (data.host || 0);
      let instanceIndex = instanceNumber + ':' + (data.host || 0);

      const isOnlyActiveInstance = () => {
        const activeInstanceIds = (0, _keys2.default)(this._connectedHosts).filter(instance => instance.startsWith(data.accountId + ':' + instanceNumber));
        return !activeInstanceIds.length || activeInstanceIds.length === 1 && activeInstanceIds[0] === instanceId;
      };

      const cancelDisconnectTimer = () => {
        if (this._statusTimers[instanceId]) {
          clearTimeout(this._statusTimers[instanceId]);
        }
      };

      const resetDisconnectTimer = () => {
        cancelDisconnectTimer();
        this._statusTimers[instanceId] = setTimeout(async () => {
          if (isOnlyActiveInstance()) {
            this._subscriptionManager.onTimeout(data.accountId, instanceNumber);
          }
          this.queueEvent(data.accountId, () => _promise2.default.resolve(onDisconnected(true)));
        }, 60000);
      };

      // eslint-disable-next-line complexity
      const onDisconnected = async (isTimeout = false) => {
        if (this._connectedHosts[instanceId]) {
          if (isOnlyActiveInstance()) {
            const onDisconnectedPromises = [];
            if (!isTimeout) {
              onDisconnectedPromises.push(this._subscriptionManager.onDisconnected(data.accountId, instanceNumber));
            }
            for (let listener of this._synchronizationListeners[data.accountId] || []) {
              onDisconnectedPromises.push(_promise2.default.resolve(listener.onDisconnected(instanceIndex))
              // eslint-disable-next-line no-console
              .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about disconnected event', err)));
            }
            await _promise2.default.all(onDisconnectedPromises);
          } else {
            const onStreamClosedPromises = [];
            this._packetOrderer.onStreamClosed(instanceId);
            if (socketInstance) {
              socketInstance.synchronizationThrottler.removeIdByParameters(data.accountId, instanceNumber, data.host);
            }
            for (let listener of this._synchronizationListeners[data.accountId] || []) {
              onStreamClosedPromises.push(_promise2.default.resolve(listener.onStreamClosed(instanceIndex))
              // eslint-disable-next-line no-console
              .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about stream closed event', err)));
            }
            await _promise2.default.all(onStreamClosedPromises);
          }
          delete this._connectedHosts[instanceId];
        }
      };
      if (data.type === 'authenticated') {
        resetDisconnectTimer();
        if (!data.sessionId || socketInstance && data.sessionId === socketInstance.sessionId) {
          this._connectedHosts[instanceId] = data.host;
          const onConnectedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onConnectedPromises.push(_promise2.default.resolve(listener.onConnected(instanceIndex, data.replicas))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about connected event', err)));
          }
          this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
          await _promise2.default.all(onConnectedPromises);
        }
      } else if (data.type === 'disconnected') {
        cancelDisconnectTimer();
        await onDisconnected();
      } else if (data.type === 'synchronizationStarted') {
        const promises = [];
        this._synchronizationFlags[data.synchronizationId] = {
          accountId: data.accountId,
          positionsUpdated: data.positionsUpdated !== undefined ? data.positionsUpdated : true,
          ordersUpdated: data.ordersUpdated !== undefined ? data.ordersUpdated : true
        };
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          promises.push(_promise2.default.resolve((async () => {
            await listener.onSynchronizationStarted(instanceIndex, data.specificationsUpdated !== undefined ? data.specificationsUpdated : true, data.positionsUpdated !== undefined ? data.positionsUpdated : true, data.ordersUpdated !== undefined ? data.ordersUpdated : true);
          })())
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about synchronization started event', err)));
        }
        await _promise2.default.all(promises);
      } else if (data.type === 'accountInformation') {
        if (data.accountInformation) {
          const onAccountInformationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onAccountInformationUpdatedPromises.push(_promise2.default.resolve((async () => {
              await listener.onAccountInformationUpdated(instanceIndex, data.accountInformation);
              if (this._synchronizationFlags[data.synchronizationId]) {
                if (!this._synchronizationFlags[data.synchronizationId].positionsUpdated) {
                  await listener.onPositionsSynchronized(instanceIndex, data.synchronizationId);
                }
                if (!this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                  await listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId);
                }
              }
            })())
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about accountInformation event', err)));
          }
          await _promise2.default.all(onAccountInformationUpdatedPromises);
          delete this._synchronizationFlags[data.synchronizationId];
        }
      } else if (data.type === 'deals') {
        for (let deal of data.deals || []) {
          const onDealAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onDealAddedPromises.push(_promise2.default.resolve(listener.onDealAdded(instanceIndex, deal))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about deals event', err)));
          }
          await _promise2.default.all(onDealAddedPromises);
        }
      } else if (data.type === 'orders') {
        const onPendingOrdersReplacedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onPendingOrdersReplacedPromises.push(_promise2.default.resolve((async () => {
            await listener.onPendingOrdersReplaced(instanceIndex, data.orders || []);
            await listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId);
          })())
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about orders event', err)));
        }
        await _promise2.default.all(onPendingOrdersReplacedPromises);
      } else if (data.type === 'historyOrders') {
        for (let historyOrder of data.historyOrders || []) {
          const onHistoryOrderAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onHistoryOrderAddedPromises.push(_promise2.default.resolve(listener.onHistoryOrderAdded(instanceIndex, historyOrder))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about historyOrders event', err)));
          }
          await _promise2.default.all(onHistoryOrderAddedPromises);
        }
      } else if (data.type === 'positions') {
        const onPositionsReplacedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onPositionsReplacedPromises.push(_promise2.default.resolve((async () => {
            await listener.onPositionsReplaced(instanceIndex, data.positions || []);
            await listener.onPositionsSynchronized(instanceIndex, data.synchronizationId);
          })())
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about positions event', err)));
        }
        await _promise2.default.all(onPositionsReplacedPromises);
      } else if (data.type === 'update') {
        if (data.accountInformation) {
          const onAccountInformationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onAccountInformationUpdatedPromises.push(_promise2.default.resolve(listener.onAccountInformationUpdated(instanceIndex, data.accountInformation))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onAccountInformationUpdatedPromises);
        }
        for (let position of data.updatedPositions || []) {
          const onPositionUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onPositionUpdatedPromises.push(_promise2.default.resolve(listener.onPositionUpdated(instanceIndex, position))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onPositionUpdatedPromises);
        }
        for (let positionId of data.removedPositionIds || []) {
          const onPositionRemovedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onPositionRemovedPromises.push(_promise2.default.resolve(listener.onPositionRemoved(instanceIndex, positionId))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onPositionRemovedPromises);
        }
        for (let order of data.updatedOrders || []) {
          const onPendingOrderUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onPendingOrderUpdatedPromises.push(_promise2.default.resolve(listener.onPendingOrderUpdated(instanceIndex, order))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onPendingOrderUpdatedPromises);
        }
        for (let orderId of data.completedOrderIds || []) {
          const onPendingOrderCompletedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onPendingOrderCompletedPromises.push(_promise2.default.resolve(listener.onPendingOrderCompleted(instanceIndex, orderId))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onPendingOrderCompletedPromises);
        }
        for (let historyOrder of data.historyOrders || []) {
          const onHistoryOrderAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onHistoryOrderAddedPromises.push(_promise2.default.resolve(listener.onHistoryOrderAdded(instanceIndex, historyOrder))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onHistoryOrderAddedPromises);
        }
        for (let deal of data.deals || []) {
          const onDealAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onDealAddedPromises.push(_promise2.default.resolve(listener.onDealAdded(instanceIndex, deal))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onDealAddedPromises);
        }
        if (data.timestamps) {
          data.timestamps.clientProcessingFinished = new Date();
          const onUpdatePromises = [];
          // eslint-disable-next-line max-depth
          for (let listener of this._latencyListeners || []) {
            onUpdatePromises.push(_promise2.default.resolve(listener.onUpdate(data.accountId, data.timestamps))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify latency ` + 'listener about update event', err)));
          }
          await _promise2.default.all(onUpdatePromises);
        }
      } else if (data.type === 'dealSynchronizationFinished') {
        const onDealsSynchronizedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          if (socketInstance) {
            socketInstance.synchronizationThrottler.removeSynchronizationId(data.synchronizationId);
          }
          onDealsSynchronizedPromises.push(_promise2.default.resolve(listener.onDealsSynchronized(instanceIndex, data.synchronizationId))
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener about ` + 'dealSynchronizationFinished event', err)));
        }
        await _promise2.default.all(onDealsSynchronizedPromises);
      } else if (data.type === 'orderSynchronizationFinished') {
        const onHistoryOrdersSynchronizedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onHistoryOrdersSynchronizedPromises.push(_promise2.default.resolve(listener.onHistoryOrdersSynchronized(instanceIndex, data.synchronizationId))
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener about ` + 'orderSynchronizationFinished event', err)));
        }
        await _promise2.default.all(onHistoryOrdersSynchronizedPromises);
      } else if (data.type === 'status') {
        if (!this._connectedHosts[instanceId]) {
          if (this._statusTimers[instanceId] && data.authenticated && (this._subscriptionManager.isDisconnectedRetryMode(data.accountId, instanceNumber) || !this._subscriptionManager.isAccountSubscribing(data.accountId, instanceNumber))) {
            this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
            await new _promise2.default(res => setTimeout(res, 10));
            // eslint-disable-next-line no-console
            this._logger.info('it seems like we are not connected to a running API ' + 'server yet, retrying subscription for account ' + instanceId);
            this.ensureSubscribe(data.accountId, instanceNumber);
          }
        } else {
          resetDisconnectTimer();
          const onBrokerConnectionStatusChangedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onBrokerConnectionStatusChangedPromises.push(_promise2.default.resolve(listener.onBrokerConnectionStatusChanged(instanceIndex, !!data.connected))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify ` + 'listener about brokerConnectionStatusChanged event', err)));
          }
          await _promise2.default.all(onBrokerConnectionStatusChangedPromises);
          if (data.healthStatus) {
            const onHealthStatusPromises = [];
            // eslint-disable-next-line max-depth
            for (let listener of this._synchronizationListeners[data.accountId] || []) {
              onHealthStatusPromises.push(_promise2.default.resolve(listener.onHealthStatus(instanceIndex, data.healthStatus))
              // eslint-disable-next-line no-console
              .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify ` + 'listener about server-side healthStatus event', err)));
            }
            await _promise2.default.all(onHealthStatusPromises);
          }
        }
      } else if (data.type === 'downgradeSubscription') {
        // eslint-disable-next-line no-console
        this._logger.info(`${data.accountId}:${instanceIndex}: Market data subscriptions for symbol ` + `${data.symbol} were downgraded by the server due to rate limits. Updated subscriptions: ` + `${(0, _stringify2.default)(data.updates)}, removed subscriptions: ${(0, _stringify2.default)(data.unsubscriptions)}. ` + 'Please read https://metaapi.cloud/docs/client/rateLimiting/ for more details.');
        const onSubscriptionDowngradePromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onSubscriptionDowngradePromises.push(_promise2.default.resolve(listener.onSubscriptionDowngraded(instanceIndex, data.symbol, data.updates, data.unsubscriptions))
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about subscription downgrade event', err)));
        }
        await _promise2.default.all(onSubscriptionDowngradePromises);
      } else if (data.type === 'specifications') {
        const onSymbolSpecificationsUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onSymbolSpecificationsUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolSpecificationsUpdated(instanceIndex, data.specifications || [], data.removedSymbols || []))
          // eslint-disable-next-line no-console
          .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about specifications updated event', err)));
        }
        await _promise2.default.all(onSymbolSpecificationsUpdatedPromises);
        for (let specification of data.specifications || []) {
          const onSymbolSpecificationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onSymbolSpecificationUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolSpecificationUpdated(instanceIndex, specification))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about specification updated event', err)));
          }
          await _promise2.default.all(onSymbolSpecificationUpdatedPromises);
        }
        for (let removedSymbol of data.removedSymbols || []) {
          const onSymbolSpecificationRemovedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onSymbolSpecificationRemovedPromises.push(_promise2.default.resolve(listener.onSymbolSpecificationRemoved(instanceIndex, removedSymbol))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about specifications removed event', err)));
          }
          await _promise2.default.all(onSymbolSpecificationRemovedPromises);
        }
      } else if (data.type === 'prices') {
        let prices = data.prices || [];
        let candles = data.candles || [];
        let ticks = data.ticks || [];
        let books = data.books || [];
        const onSymbolPricesUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          if (prices.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolPricesUpdated(instanceIndex, prices, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about prices event', err)));
          }
          if (candles.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onCandlesUpdated(instanceIndex, candles, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about candles event', err)));
          }
          if (ticks.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onTicksUpdated(instanceIndex, ticks, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about ticks event', err)));
          }
          if (books.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onBooksUpdated(instanceIndex, books, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about books event', err)));
          }
        }
        await _promise2.default.all(onSymbolPricesUpdatedPromises);
        for (let price of prices) {
          const onSymbolPriceUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onSymbolPriceUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolPriceUpdated(instanceIndex, price))
            // eslint-disable-next-line no-console
            .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about price event', err)));
          }
          await _promise2.default.all(onSymbolPriceUpdatedPromises);
        }
        for (let price of prices) {
          if (price.timestamps) {
            price.timestamps.clientProcessingFinished = new Date();
            const onSymbolPricePromises = [];
            // eslint-disable-next-line max-depth
            for (let listener of this._latencyListeners || []) {
              onSymbolPricePromises.push(_promise2.default.resolve(listener.onSymbolPrice(data.accountId, price.symbol, price.timestamps))
              // eslint-disable-next-line no-console
              .catch(err => this._logger.error(`${data.accountId}:${instanceIndex}: Failed to notify latency ` + 'listener about price event', err)));
            }
            await _promise2.default.all(onSymbolPricePromises);
          }
        }
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      this._logger.error('Failed to process incoming synchronization packet', err);
    }
  }

  async _fireReconnected(socketInstanceIndex) {
    try {
      const reconnectListeners = [];
      for (let listener of this._reconnectListeners) {
        if (this._socketInstancesByAccounts[listener.accountId] === socketInstanceIndex) {
          reconnectListeners.push(listener);
        }
      }
      (0, _keys2.default)(this._synchronizationFlags).forEach(synchronizationId => {
        if (this._socketInstancesByAccounts[this._synchronizationFlags[synchronizationId].accountId] === socketInstanceIndex) {
          delete this._synchronizationFlags[synchronizationId];
        }
      });
      const reconnectAccountIds = reconnectListeners.map(listener => listener.accountId);
      this._subscriptionManager.onReconnected(socketInstanceIndex, reconnectAccountIds);
      this._packetOrderer.onReconnected(reconnectAccountIds);

      for (let listener of reconnectListeners) {
        _promise2.default.resolve(listener.listener.onReconnected()).catch(err => this._logger.error('Failed to notify reconnect listener', err));
      }
    } catch (err) {
      this._logger.error('Failed to process reconnected event', err);
    }
  }

  async _getServerUrl() {
    let url;
    if (this._useSharedClientApi) {
      url = this._url;
    } else {
      const opts = {
        url: `https://mt-provisioning-api-v1.${this._domain}/users/current/servers/mt-client-api`,
        method: 'GET',
        headers: {
          'auth-token': this._token
        },
        json: true
      };
      const response = await this._httpClient.request(opts);
      url = response.url;
    }
    const isSharedClientApi = url === this._url;
    let logMessage = 'Connecting MetaApi websocket client to the MetaApi server ' + `via ${url} ${isSharedClientApi ? 'shared' : 'dedicated'} server.`;
    if (this._firstConnect && !isSharedClientApi) {
      logMessage += ' Please note that it can take up to 3 minutes for your dedicated server to start for the ' + 'first time. During this time it is OK if you see some connection errors.';
      this._firstConnect = false;
    }
    this._logger.info(logMessage);
    return url;
  }

}
exports.default = MetaApiWebsocketClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvbWV0YUFwaVdlYnNvY2tldC5jbGllbnQuZXM2Il0sIm5hbWVzIjpbIlBhY2tldExvZ2dlciIsIndpbmRvdyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiTWV0YUFwaVdlYnNvY2tldENsaWVudCIsImNvbnN0cnVjdG9yIiwiaHR0cENsaWVudCIsInRva2VuIiwib3B0cyIsInZhbGlkYXRvciIsIk9wdGlvbnNWYWxpZGF0b3IiLCJwYWNrZXRPcmRlcmluZ1RpbWVvdXQiLCJ2YWxpZGF0ZU5vblplcm8iLCJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJfaHR0cENsaWVudCIsIl9hcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uIiwiX2RvbWFpbiIsImRvbWFpbiIsIl91cmwiLCJfcmVxdWVzdFRpbWVvdXQiLCJyZXF1ZXN0VGltZW91dCIsIl9jb25uZWN0VGltZW91dCIsImNvbm5lY3RUaW1lb3V0IiwicmV0cnlPcHRzIiwiX3JldHJpZXMiLCJ2YWxpZGF0ZU51bWJlciIsInJldHJpZXMiLCJfbWluUmV0cnlEZWxheUluU2Vjb25kcyIsIm1pbkRlbGF5SW5TZWNvbmRzIiwiX21heFJldHJ5RGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsIl9tYXhBY2NvdW50c1Blckluc3RhbmNlIiwiX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzIiwic3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMiLCJldmVudFByb2Nlc3NpbmciLCJfc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyIsInZhbGlkYXRlQm9vbGVhbiIsInNlcXVlbnRpYWxQcm9jZXNzaW5nIiwiX3VzZVNoYXJlZENsaWVudEFwaSIsInVzZVNoYXJlZENsaWVudEFwaSIsIl90b2tlbiIsIl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMiLCJfbGF0ZW5jeUxpc3RlbmVycyIsIl9yZWNvbm5lY3RMaXN0ZW5lcnMiLCJfY29ubmVjdGVkSG9zdHMiLCJfc29ja2V0SW5zdGFuY2VzIiwiX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJfc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyIsIl9zdWJzY3JpcHRpb25NYW5hZ2VyIiwiU3Vic2NyaXB0aW9uTWFuYWdlciIsIl9zdGF0dXNUaW1lcnMiLCJfZXZlbnRRdWV1ZXMiLCJfc3luY2hyb25pemF0aW9uRmxhZ3MiLCJfc3Vic2NyaWJlTG9jayIsIl9maXJzdENvbm5lY3QiLCJfcGFja2V0T3JkZXJlciIsIlBhY2tldE9yZGVyZXIiLCJwYWNrZXRMb2dnZXIiLCJlbmFibGVkIiwiX3BhY2tldExvZ2dlciIsInN0YXJ0IiwiX2xvZ2dlciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiLCJvbk91dE9mT3JkZXJQYWNrZXQiLCJhY2NvdW50SWQiLCJpbnN0YW5jZUluZGV4IiwiZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciIsImFjdHVhbFNlcXVlbmNlTnVtYmVyIiwicGFja2V0IiwicmVjZWl2ZWRBdCIsImVycm9yIiwidHlwZSIsImVuc3VyZVN1YnNjcmliZSIsInVybCIsInNvY2tldEluc3RhbmNlcyIsInNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJzdWJzY3JpYmVkQWNjb3VudElkcyIsInNvY2tldEluc3RhbmNlSW5kZXgiLCJjb25uZWN0ZWRJZHMiLCJmb3JFYWNoIiwiaW5zdGFuY2VJZCIsInNwbGl0IiwiaW5jbHVkZXMiLCJ1bmRlZmluZWQiLCJwdXNoIiwiY29ubmVjdGVkIiwiaW5zdGFuY2UiLCJsZW5ndGgiLCJzb2NrZXQiLCJnZXRBc3NpZ25lZEFjY291bnRzIiwiYWNjb3VudElkcyIsImtleSIsImxvY2tTb2NrZXRJbnN0YW5jZSIsIm1ldGFkYXRhIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJsb2NrZWRBdEFjY291bnRzIiwibG9ja2VkQXRUaW1lIiwiRGF0ZSIsIm5vdyIsInN1YnNjcmliZWRBY2NvdW50cyIsInNvY2tldEluc3RhbmNlIiwiY2xvc2UiLCJfcmVjb25uZWN0Iiwic3Vic2NyaWJlTG9jayIsImNvbm5lY3QiLCJjbGllbnRJZCIsIk1hdGgiLCJyYW5kb20iLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzb2x2ZWQiLCJyZXN1bHQiLCJyZXMiLCJyZWoiLCJpZCIsInJlcXVlc3RSZXNvbHZlcyIsImNvbm5lY3RSZXN1bHQiLCJzZXNzaW9uSWQiLCJyYW5kb21zdHJpbmciLCJnZW5lcmF0ZSIsImlzUmVjb25uZWN0aW5nIiwiU3luY2hyb25pemF0aW9uVGhyb3R0bGVyIiwic2VydmVyVXJsIiwiX2dldFNlcnZlclVybCIsInBhdGgiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJJbmZpbml0eSIsInRpbWVvdXQiLCJleHRyYUhlYWRlcnMiLCJxdWVyeSIsInByb3RvY29sIiwib24iLCJpbmZvIiwiX2ZpcmVSZWNvbm5lY3RlZCIsImVyciIsIlRpbWVvdXRFcnJvciIsInJlYXNvbiIsIm9uRGlzY29ubmVjdCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJkZWJ1ZyIsInJlcXVlc3RJZCIsInRpbWVzdGFtcHMiLCJyZXF1ZXN0UmVzb2x2ZSIsIl9jb252ZXJ0SXNvVGltZVRvRGF0ZSIsImNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCIsImxpc3RlbmVyIiwidGhlbiIsIm9uVHJhZGUiLCJvblJlc3BvbnNlIiwiY2F0Y2giLCJfY29udmVydEVycm9yIiwidHJhY2UiLCJzZXF1ZW5jZU51bWJlciIsInNlcXVlbmNlVGltZXN0YW1wIiwic3luY2hyb25pemF0aW9uSWQiLCJob3N0IiwiYWN0aXZlU3luY2hyb25pemF0aW9uSWRzIiwibG9nUGFja2V0IiwicXVldWVQYWNrZXQiLCJFcnJvciIsInN0b3AiLCJnZXRBY2NvdW50SW5mb3JtYXRpb24iLCJyZXNwb25zZSIsIl9ycGNSZXF1ZXN0IiwiYWNjb3VudEluZm9ybWF0aW9uIiwiZ2V0UG9zaXRpb25zIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJwb3NpdGlvbklkIiwicG9zaXRpb24iLCJnZXRPcmRlcnMiLCJvcmRlcnMiLCJnZXRPcmRlciIsIm9yZGVySWQiLCJvcmRlciIsImdldEhpc3RvcnlPcmRlcnNCeVRpY2tldCIsInRpY2tldCIsImhpc3RvcnlPcmRlcnMiLCJzeW5jaHJvbml6aW5nIiwiZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24iLCJnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwib2Zmc2V0IiwibGltaXQiLCJnZXREZWFsc0J5VGlja2V0IiwiZGVhbHMiLCJnZXREZWFsc0J5UG9zaXRpb24iLCJnZXREZWFsc0J5VGltZVJhbmdlIiwicmVtb3ZlSGlzdG9yeSIsInJlbW92ZUFwcGxpY2F0aW9uIiwidHJhZGUiLCJzdHJpbmdDb2RlIiwiZGVzY3JpcHRpb24iLCJudW1lcmljQ29kZSIsIlRyYWRlRXJyb3IiLCJtZXNzYWdlIiwiaW5zdGFuY2VOdW1iZXIiLCJzdWJzY3JpYmUiLCJyZWNvbm5lY3QiLCJzeW5jaHJvbml6ZSIsInN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSIsInN0YXJ0aW5nRGVhbFRpbWUiLCJzcGVjaWZpY2F0aW9uc01kNSIsInBvc2l0aW9uc01kNSIsIm9yZGVyc01kNSIsInN5bmNUaHJvdHRsZXIiLCJzY2hlZHVsZVN5bmNocm9uaXplIiwid2FpdFN5bmNocm9uaXplZCIsImFwcGxpY2F0aW9uUGF0dGVybiIsInRpbWVvdXRJblNlY29uZHMiLCJzdWJzY3JpYmVUb01hcmtldERhdGEiLCJzeW1ib2wiLCJzdWJzY3JpcHRpb25zIiwicmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zIiwidW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSIsImdldFN5bWJvbHMiLCJzeW1ib2xzIiwiZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbiIsInNwZWNpZmljYXRpb24iLCJnZXRTeW1ib2xQcmljZSIsInByaWNlIiwiZ2V0Q2FuZGxlIiwidGltZWZyYW1lIiwiY2FuZGxlIiwiZ2V0VGljayIsInRpY2siLCJnZXRCb29rIiwiYm9vayIsInNhdmVVcHRpbWUiLCJ1cHRpbWUiLCJ1bnN1YnNjcmliZSIsImNhbmNlbEFjY291bnQiLCJOb3RGb3VuZEVycm9yIiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJyZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImZpbHRlciIsImwiLCJhZGRMYXRlbmN5TGlzdGVuZXIiLCJyZW1vdmVMYXRlbmN5TGlzdGVuZXIiLCJhZGRSZWNvbm5lY3RMaXN0ZW5lciIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicGFja2V0cyIsInJlc3RvcmVPcmRlciIsInAiLCJldmVudHMiLCJtYXAiLCJwYWNrZXRJdGVtIiwiX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQiLCJfY2FsbEFjY291bnRFdmVudHMiLCJjb25jYXQiLCJxdWV1ZUV2ZW50IiwiZXZlbnQiLCJzaGlmdCIsIl90cnlSZWNvbm5lY3QiLCJzZXRUaW1lb3V0IiwiaW8iLCJ1cmkiLCJyZXF1ZXN0IiwiZ2V0VGltZSIsImluZGV4IiwiYWNjb3VudENvdW50ZXIiLCJfbWFrZVJlcXVlc3QiLCJyZXRyeUNvdW50ZXIiLCJuYW1lIiwiY2FsY1JldHJ5Q291bnRlciIsImNhbGNSZXF1ZXN0VGltZSIsIm1pbiIsInBvdyIsInJldHJ5VGltZSIsImNsaWVudFByb2Nlc3NpbmdTdGFydGVkIiwicmFjZSIsImVtaXQiLCJWYWxpZGF0aW9uRXJyb3IiLCJkZXRhaWxzIiwiTm90U3luY2hyb25pemVkRXJyb3IiLCJOb3RDb25uZWN0ZWRFcnJvciIsIlVuYXV0aG9yaXplZEVycm9yIiwiVG9vTWFueVJlcXVlc3RzRXJyb3IiLCJJbnRlcm5hbEVycm9yIiwiZmllbGQiLCJ2YWx1ZSIsIm1hdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbSIsInByaWNlcyIsInVwZGF0ZVN5bmNocm9uaXphdGlvbklkIiwiaXNPbmx5QWN0aXZlSW5zdGFuY2UiLCJhY3RpdmVJbnN0YW5jZUlkcyIsInN0YXJ0c1dpdGgiLCJjYW5jZWxEaXNjb25uZWN0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJyZXNldERpc2Nvbm5lY3RUaW1lciIsIm9uVGltZW91dCIsIm9uRGlzY29ubmVjdGVkIiwiaXNUaW1lb3V0Iiwib25EaXNjb25uZWN0ZWRQcm9taXNlcyIsImFsbCIsIm9uU3RyZWFtQ2xvc2VkUHJvbWlzZXMiLCJvblN0cmVhbUNsb3NlZCIsInJlbW92ZUlkQnlQYXJhbWV0ZXJzIiwib25Db25uZWN0ZWRQcm9taXNlcyIsIm9uQ29ubmVjdGVkIiwicmVwbGljYXMiLCJjYW5jZWxTdWJzY3JpYmUiLCJwcm9taXNlcyIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwic3BlY2lmaWNhdGlvbnNVcGRhdGVkIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMiLCJvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQiLCJvblBvc2l0aW9uc1N5bmNocm9uaXplZCIsIm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCIsImRlYWwiLCJvbkRlYWxBZGRlZFByb21pc2VzIiwib25EZWFsQWRkZWQiLCJvblBlbmRpbmdPcmRlcnNSZXBsYWNlZFByb21pc2VzIiwib25QZW5kaW5nT3JkZXJzUmVwbGFjZWQiLCJoaXN0b3J5T3JkZXIiLCJvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMiLCJvbkhpc3RvcnlPcmRlckFkZGVkIiwib25Qb3NpdGlvbnNSZXBsYWNlZFByb21pc2VzIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsInVwZGF0ZWRQb3NpdGlvbnMiLCJvblBvc2l0aW9uVXBkYXRlZFByb21pc2VzIiwib25Qb3NpdGlvblVwZGF0ZWQiLCJyZW1vdmVkUG9zaXRpb25JZHMiLCJvblBvc2l0aW9uUmVtb3ZlZFByb21pc2VzIiwib25Qb3NpdGlvblJlbW92ZWQiLCJ1cGRhdGVkT3JkZXJzIiwib25QZW5kaW5nT3JkZXJVcGRhdGVkUHJvbWlzZXMiLCJvblBlbmRpbmdPcmRlclVwZGF0ZWQiLCJjb21wbGV0ZWRPcmRlcklkcyIsIm9uUGVuZGluZ09yZGVyQ29tcGxldGVkUHJvbWlzZXMiLCJvblBlbmRpbmdPcmRlckNvbXBsZXRlZCIsIm9uVXBkYXRlUHJvbWlzZXMiLCJvblVwZGF0ZSIsIm9uRGVhbHNTeW5jaHJvbml6ZWRQcm9taXNlcyIsInJlbW92ZVN5bmNocm9uaXphdGlvbklkIiwib25EZWFsc1N5bmNocm9uaXplZCIsIm9uSGlzdG9yeU9yZGVyc1N5bmNocm9uaXplZFByb21pc2VzIiwib25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkIiwiYXV0aGVudGljYXRlZCIsImlzRGlzY29ubmVjdGVkUmV0cnlNb2RlIiwiaXNBY2NvdW50U3Vic2NyaWJpbmciLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkUHJvbWlzZXMiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwiaGVhbHRoU3RhdHVzIiwib25IZWFsdGhTdGF0dXNQcm9taXNlcyIsIm9uSGVhbHRoU3RhdHVzIiwidXBkYXRlcyIsInVuc3Vic2NyaXB0aW9ucyIsIm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlUHJvbWlzZXMiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZFByb21pc2VzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJzcGVjaWZpY2F0aW9ucyIsInJlbW92ZWRTeW1ib2xzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZFByb21pc2VzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCIsInJlbW92ZWRTeW1ib2wiLCJvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMiLCJvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkIiwiY2FuZGxlcyIsInRpY2tzIiwiYm9va3MiLCJvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcyIsIm9uU3ltYm9sUHJpY2VzVXBkYXRlZCIsImVxdWl0eSIsIm1hcmdpbiIsImZyZWVNYXJnaW4iLCJtYXJnaW5MZXZlbCIsImFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSIsIm9uQ2FuZGxlc1VwZGF0ZWQiLCJvblRpY2tzVXBkYXRlZCIsIm9uQm9va3NVcGRhdGVkIiwib25TeW1ib2xQcmljZVVwZGF0ZWRQcm9taXNlcyIsIm9uU3ltYm9sUHJpY2VVcGRhdGVkIiwib25TeW1ib2xQcmljZVByb21pc2VzIiwib25TeW1ib2xQcmljZSIsInJlY29ubmVjdExpc3RlbmVycyIsInJlY29ubmVjdEFjY291bnRJZHMiLCJvblJlY29ubmVjdGVkIiwibWV0aG9kIiwiaGVhZGVycyIsImpzb24iLCJpc1NoYXJlZENsaWVudEFwaSIsImxvZ01lc3NhZ2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSUEsWUFBSjtBQUNBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUFFO0FBQ25DRCxpQkFBZUUsUUFBUSxnQkFBUixFQUEwQkMsT0FBekM7QUFDRDs7QUFFRDs7O0FBR2UsTUFBTUMsc0JBQU4sQ0FBNkI7O0FBRTFDOzs7Ozs7QUFNQTtBQUNBQyxjQUFZQyxVQUFaLEVBQXdCQyxLQUF4QixFQUErQkMsSUFBL0IsRUFBcUM7QUFDbkMsVUFBTUMsWUFBWSxJQUFJQywwQkFBSixFQUFsQjtBQUNBRixXQUFPQSxRQUFRLEVBQWY7QUFDQUEsU0FBS0cscUJBQUwsR0FBNkJGLFVBQVVHLGVBQVYsQ0FBMEJKLEtBQUtHLHFCQUEvQixFQUFzRCxFQUF0RCxFQUEwRCx1QkFBMUQsQ0FBN0I7QUFDQUgsU0FBS0ssd0JBQUwsR0FBZ0NMLEtBQUtL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QUZHO0FBR1hDLGlCQUFTO0FBQ1Asd0JBQWMsS0FBS2xXO0FBRFosU0FIRTtBQU1YbVcsY0FBTTtBQU5LLE9BQWI7QUFRQSxZQUFNbk8sV0FBVyxNQUFNLEtBQUszSixXQUFMLENBQWlCNlAsT0FBakIsQ0FBeUJuUSxJQUF6QixDQUF2QjtBQUNBbUUsWUFBTThGLFNBQVM5RixHQUFmO0FBQ0Q7QUFDRCxVQUFNa1Usb0JBQW9CbFUsUUFBUSxLQUFLeEQsSUFBdkM7QUFDQSxRQUFJMlgsYUFBYSwrREFDZCxPQUFNblUsR0FBSSxJQUFHa1Usb0JBQW9CLFFBQXBCLEdBQStCLFdBQVksVUFEM0Q7QUFFQSxRQUFHLEtBQUt0VixhQUFMLElBQXNCLENBQUNzVixpQkFBMUIsRUFBNkM7QUFDM0NDLG9CQUFjLDhGQUNaLDBFQURGO0FBRUEsV0FBS3ZWLGFBQUwsR0FBcUIsS0FBckI7QUFDRDtBQUNELFNBQUtPLE9BQUwsQ0FBYTJFLElBQWIsQ0FBa0JxUSxVQUFsQjtBQUNBLFdBQU9uVSxHQUFQO0FBQ0Q7O0FBLzZEeUM7a0JBQXZCdkUsc0IiLCJmaWxlIjoibWV0YUFwaVdlYnNvY2tldC5jbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBzb2NrZXRJTyBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vdGltZW91dEVycm9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yLCBOb3RGb3VuZEVycm9yLCBJbnRlcm5hbEVycm9yLCBVbmF1dGhvcml6ZWRFcnJvciwgVG9vTWFueVJlcXVlc3RzRXJyb3J9IGZyb20gJy4uL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgT3B0aW9uc1ZhbGlkYXRvciBmcm9tICcuLi9vcHRpb25zVmFsaWRhdG9yJztcbmltcG9ydCBOb3RTeW5jaHJvbml6ZWRFcnJvciBmcm9tICcuL25vdFN5bmNocm9uaXplZEVycm9yJztcbmltcG9ydCBOb3RDb25uZWN0ZWRFcnJvciBmcm9tICcuL25vdENvbm5lY3RlZEVycm9yJztcbmltcG9ydCBUcmFkZUVycm9yIGZyb20gJy4vdHJhZGVFcnJvcic7XG5pbXBvcnQgUGFja2V0T3JkZXJlciBmcm9tICcuL3BhY2tldE9yZGVyZXInO1xuaW1wb3J0IFN5bmNocm9uaXphdGlvblRocm90dGxlciBmcm9tICcuL3N5bmNocm9uaXphdGlvblRocm90dGxlcic7XG5pbXBvcnQgU3Vic2NyaXB0aW9uTWFuYWdlciBmcm9tICcuL3N1YnNjcmlwdGlvbk1hbmFnZXInO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vLi4vbG9nZ2VyJztcblxubGV0IFBhY2tldExvZ2dlcjtcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyAvLyBkb24ndCBpbXBvcnQgUGFja2V0TG9nZ2VyIGZvciBicm93c2VyIHZlcnNpb25cbiAgUGFja2V0TG9nZ2VyID0gcmVxdWlyZSgnLi9wYWNrZXRMb2dnZXInKS5kZWZhdWx0O1xufVxuXG4vKipcbiAqIE1ldGFBcGkgd2Vic29ja2V0IEFQSSBjbGllbnQgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L292ZXJ2aWV3LylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YUFwaVdlYnNvY2tldENsaWVudCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgTWV0YUFwaSB3ZWJzb2NrZXQgQVBJIGNsaWVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0h0dHBDbGllbnR9IGh0dHBDbGllbnQgSFRUUCBjbGllbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgd2Vic29ja2V0IGNsaWVudCBvcHRpb25zXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCB0b2tlbiwgb3B0cykge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5wYWNrZXRPcmRlcmluZ1RpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMucGFja2V0T3JkZXJpbmdUaW1lb3V0LCA2MCwgJ3BhY2tldE9yZGVyaW5nVGltZW91dCcpO1xuICAgIG9wdHMuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyID0gb3B0cy5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgfHwge307XG4gICAgdGhpcy5faHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgdGhpcy5fYXBwbGljYXRpb24gPSBvcHRzLmFwcGxpY2F0aW9uIHx8ICdNZXRhQXBpJztcbiAgICB0aGlzLl9kb21haW4gPSBvcHRzLmRvbWFpbiB8fCAnYWdpbGl1bXRyYWRlLmFnaWxpdW10cmFkZS5haSc7XG4gICAgdGhpcy5fdXJsID0gYGh0dHBzOi8vbXQtY2xpZW50LWFwaS12MS4ke3RoaXMuX2RvbWFpbn1gO1xuICAgIHRoaXMuX3JlcXVlc3RUaW1lb3V0ID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhvcHRzLnJlcXVlc3RUaW1lb3V0LCA2MCwgJ3JlcXVlc3RUaW1lb3V0JykgKiAxMDAwO1xuICAgIHRoaXMuX2Nvbm5lY3RUaW1lb3V0ID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhvcHRzLmNvbm5lY3RUaW1lb3V0LCA2MCwgJ2Nvbm5lY3RUaW1lb3V0JykgKiAxMDAwO1xuICAgIGNvbnN0IHJldHJ5T3B0cyA9IG9wdHMucmV0cnlPcHRzIHx8IHt9O1xuICAgIHRoaXMuX3JldHJpZXMgPSB2YWxpZGF0b3IudmFsaWRhdGVOdW1iZXIocmV0cnlPcHRzLnJldHJpZXMsIDUsICdyZXRyeU9wdHMucmV0cmllcycpO1xuICAgIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJldHJ5T3B0cy5taW5EZWxheUluU2Vjb25kcywgMSxcbiAgICAgICdyZXRyeU9wdHMubWluRGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9tYXhSZXRyeURlbGF5SW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZXRyeU9wdHMubWF4RGVsYXlJblNlY29uZHMsIDMwLFxuICAgICAgJ3JldHJ5T3B0cy5tYXhEZWxheUluU2Vjb25kcycpO1xuICAgIHRoaXMuX21heEFjY291bnRzUGVySW5zdGFuY2UgPSAxMDA7XG4gICAgdGhpcy5fc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJldHJ5T3B0cy5zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcywgNjAwLCBcbiAgICAgICdyZXRyeU9wdHMuc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMnKTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NpbmcgPSBvcHRzLmV2ZW50UHJvY2Vzc2luZyB8fCB7fTtcbiAgICB0aGlzLl9zZXF1ZW50aWFsRXZlbnRQcm9jZXNzaW5nID0gdmFsaWRhdG9yLnZhbGlkYXRlQm9vbGVhbihldmVudFByb2Nlc3Npbmcuc2VxdWVudGlhbFByb2Nlc3NpbmcsIHRydWUsXG4gICAgICAnZXZlbnRQcm9jZXNzaW5nLnNlcXVlbnRpYWxQcm9jZXNzaW5nJyk7XG4gICAgdGhpcy5fdXNlU2hhcmVkQ2xpZW50QXBpID0gdmFsaWRhdG9yLnZhbGlkYXRlQm9vbGVhbihvcHRzLnVzZVNoYXJlZENsaWVudEFwaSwgZmFsc2UsICd1c2VTaGFyZWRDbGllbnRBcGknKTtcbiAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWNvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9jb25uZWN0ZWRIb3N0cyA9IHt9O1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHMgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzID0gb3B0cy5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlciA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMuX3N0YXR1c1RpbWVycyA9IHt9O1xuICAgIHRoaXMuX2V2ZW50UXVldWVzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3MgPSB7fTtcbiAgICB0aGlzLl9zdWJzY3JpYmVMb2NrID0gbnVsbDtcbiAgICB0aGlzLl9maXJzdENvbm5lY3QgPSB0cnVlO1xuICAgIHRoaXMuX3BhY2tldE9yZGVyZXIgPSBuZXcgUGFja2V0T3JkZXJlcih0aGlzLCBvcHRzLnBhY2tldE9yZGVyaW5nVGltZW91dCk7XG4gICAgaWYob3B0cy5wYWNrZXRMb2dnZXIgJiYgb3B0cy5wYWNrZXRMb2dnZXIuZW5hYmxlZCkge1xuICAgICAgdGhpcy5fcGFja2V0TG9nZ2VyID0gbmV3IFBhY2tldExvZ2dlcihvcHRzLnBhY2tldExvZ2dlcik7XG4gICAgICB0aGlzLl9wYWNrZXRMb2dnZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlXZWJzb2NrZXRDbGllbnQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0cyB0aGUgYWNjb3VudCBzeW5jaHJvbml6YXRpb24gcHJvY2VzcyBvbiBhbiBvdXQgb2Ygb3JkZXIgcGFja2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciBleHBlY3RlZCBzL25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFNlcXVlbmNlTnVtYmVyIGFjdHVhbCBzL25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBwYWNrZXQgZGF0YVxuICAgKiBAcGFyYW0ge0RhdGV9IHJlY2VpdmVkQXQgdGltZSB0aGUgcGFja2V0IHdhcyByZWNlaXZlZCBhdFxuICAgKi9cbiAgb25PdXRPZk9yZGVyUGFja2V0KGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCwgZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciwgYWN0dWFsU2VxdWVuY2VOdW1iZXIsIHBhY2tldCwgcmVjZWl2ZWRBdCkge1xuICAgIHRoaXMuX2xvZ2dlci5lcnJvcignTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlY2VpdmVkIGFuIG91dCBvZiBvcmRlciAnICtcbiAgICAgIGBwYWNrZXQgdHlwZSAke3BhY2tldC50eXBlfSBmb3IgYWNjb3VudCBpZCAke2FjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fS4gRXhwZWN0ZWQgcy9uIGAgK1xuICAgICAgYCR7ZXhwZWN0ZWRTZXF1ZW5jZU51bWJlcn0gZG9lcyBub3QgbWF0Y2ggdGhlIGFjdHVhbCBvZiAke2FjdHVhbFNlcXVlbmNlTnVtYmVyfWApO1xuICAgIHRoaXMuZW5zdXJlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUGF0Y2ggc2VydmVyIFVSTCBmb3IgdXNlIGluIHVuaXQgdGVzdHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBwYXRjaGVkIHNlcnZlciBVUkxcbiAgICovXG4gIHNldCB1cmwodXJsKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygc29ja2V0IGluc3RhbmNlIGRpY3Rpb25hcmllc1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gbGlzdCBvZiBzb2NrZXQgaW5zdGFuY2UgZGljdGlvbmFyaWVzXG4gICAqL1xuICBnZXQgc29ja2V0SW5zdGFuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zb2NrZXRJbnN0YW5jZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGljdGlvbmFyeSBvZiBzb2NrZXQgaW5zdGFuY2VzIGJ5IGFjY291bnQgaWRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGljdGlvbmFyeSBvZiBzb2NrZXQgaW5zdGFuY2VzIGJ5IGFjY291bnQgaWRzXG4gICAqL1xuICBnZXQgc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN1YnNjcmliZWQgYWNjb3VudCBpZHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvY2tldEluc3RhbmNlSW5kZXggc29ja2V0IGluc3RhbmNlIGluZGV4XG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIHN1YnNjcmliZWQgYWNjb3VudCBpZHNcbiAgICovXG4gIHN1YnNjcmliZWRBY2NvdW50SWRzKHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCBjb25uZWN0ZWRJZHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9jb25uZWN0ZWRIb3N0cykuZm9yRWFjaChpbnN0YW5jZUlkID0+IHtcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IGluc3RhbmNlSWQuc3BsaXQoJzonKVswXTtcbiAgICAgIGlmKCFjb25uZWN0ZWRJZHMuaW5jbHVkZXMoYWNjb3VudElkKSAmJiB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCB8fCBcbiAgICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBjb25uZWN0ZWRJZHMucHVzaChhY2NvdW50SWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0ZWRJZHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAqIEBwYXJhbSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2Vic29ja2V0IGNsaWVudCBjb25uZWN0aW9uIHN0YXR1c1xuICAgKi9cbiAgY29ubmVjdGVkKHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlcy5sZW5ndGggPiBzb2NrZXRJbnN0YW5jZUluZGV4ID8gXG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbc29ja2V0SW5zdGFuY2VJbmRleF0gOiBudWxsO1xuICAgIHJldHVybiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc29ja2V0ICYmIGluc3RhbmNlLnNvY2tldC5jb25uZWN0ZWQpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBhY2NvdW50cyBhc3NpZ25lZCB0byBpbnN0YW5jZVxuICAgKiBAcGFyYW0gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHJldHVybnMgXG4gICAqL1xuICBnZXRBc3NpZ25lZEFjY291bnRzKHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCBhY2NvdW50SWRzID0gW107XG4gICAgT2JqZWN0LmtleXModGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNba2V5XSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgICAgICBhY2NvdW50SWRzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjb3VudElkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyBzdWJzY3JpcHRpb24gZm9yIGEgc29ja2V0IGluc3RhbmNlIGJhc2VkIG9uIFRvb01hbnlSZXF1ZXN0c0Vycm9yIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0gbWV0YWRhdGEgVG9vTWFueVJlcXVlc3RzRXJyb3IgbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIGxvY2tTb2NrZXRJbnN0YW5jZShzb2NrZXRJbnN0YW5jZUluZGV4LCBtZXRhZGF0YSkge1xuICAgIGlmIChtZXRhZGF0YS50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJykge1xuICAgICAgdGhpcy5fc3Vic2NyaWJlTG9jayA9IHtcbiAgICAgICAgcmVjb21tZW5kZWRSZXRyeVRpbWU6IG1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lLFxuICAgICAgICBsb2NrZWRBdEFjY291bnRzOiB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKCkubGVuZ3RoLFxuICAgICAgICBsb2NrZWRBdFRpbWU6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN1YnNjcmliZWRBY2NvdW50cyA9IHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoc29ja2V0SW5zdGFuY2VJbmRleCk7XG4gICAgICBpZiAoc3Vic2NyaWJlZEFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgICAgICBzb2NrZXRJbnN0YW5jZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVjb25uZWN0KHNvY2tldEluc3RhbmNlSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgICAgIGluc3RhbmNlLnN1YnNjcmliZUxvY2sgPSB7XG4gICAgICAgICAgcmVjb21tZW5kZWRSZXRyeVRpbWU6IG1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lLFxuICAgICAgICAgIHR5cGU6IG1ldGFkYXRhLnR5cGUsXG4gICAgICAgICAgbG9ja2VkQXRBY2NvdW50czogc3Vic2NyaWJlZEFjY291bnRzLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBNZXRhQXBpIHNlcnZlciB2aWEgc29ja2V0LmlvIHByb3RvY29sXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBsZXQgY2xpZW50SWQgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzLmxlbmd0aDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgIGlkOiBzb2NrZXRJbnN0YW5jZUluZGV4LFxuICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RSZXNvbHZlczoge30sXG4gICAgICByZXNvbHZlZDogZmFsc2UsXG4gICAgICBjb25uZWN0UmVzdWx0OiByZXN1bHQsXG4gICAgICBzZXNzaW9uSWQ6IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMiksXG4gICAgICBpc1JlY29ubmVjdGluZzogZmFsc2UsXG4gICAgICBzb2NrZXQ6IG51bGwsXG4gICAgICBzeW5jaHJvbml6YXRpb25UaHJvdHRsZXI6IG5ldyBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIodGhpcywgc29ja2V0SW5zdGFuY2VJbmRleCxcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyksXG4gICAgICBzdWJzY3JpYmVMb2NrOiBudWxsXG4gICAgfTtcbiAgICBpbnN0YW5jZS5jb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICBjb25zdCBzZXJ2ZXJVcmwgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJVcmwoKTtcbiAgICBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuc3RhcnQoKTtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHNvY2tldElPKHNlcnZlclVybCwge1xuICAgICAgcGF0aDogJy93cycsXG4gICAgICByZWNvbm5lY3Rpb246IHRydWUsXG4gICAgICByZWNvbm5lY3Rpb25EZWxheTogMTAwMCxcbiAgICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiA1MDAwLFxuICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IEluZmluaXR5LFxuICAgICAgdGltZW91dDogdGhpcy5fY29ubmVjdFRpbWVvdXQsXG4gICAgICBleHRyYUhlYWRlcnM6IHtcbiAgICAgICAgJ0NsaWVudC1JZCc6IGNsaWVudElkXG4gICAgICB9LFxuICAgICAgcXVlcnk6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlbixcbiAgICAgICAgY2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgICBwcm90b2NvbDogMlxuICAgICAgfVxuICAgIH0pO1xuICAgIGluc3RhbmNlLnNvY2tldCA9IHNvY2tldEluc3RhbmNlO1xuICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLnN0YXJ0KCk7XG4gICAgfSBcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLl9sb2dnZXIuaW5mbygnTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3RlZCB0byB0aGUgTWV0YUFwaSBzZXJ2ZXInKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIGluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdyZWNvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5fZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlLmlkKTtcbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignY29ubmVjdF9lcnJvcicsIChlcnIpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ01ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBjb25uZWN0aW9uIGVycm9yJywgZXJyKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3RfdGltZW91dCcsICh0aW1lb3V0KSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiB0aW1lb3V0Jyk7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiB0aW1lZCBvdXQnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Rpc2Nvbm5lY3QnLCBhc3luYyAocmVhc29uKSA9PiB7XG4gICAgICBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIub25EaXNjb25uZWN0KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oJ01ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgTWV0YUFwaSAnICtcbiAgICAgICAgJ3NlcnZlciBiZWNhdXNlIG9mICcgKyByZWFzb24pO1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZS5pZCk7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Vycm9yJywgYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZXJyb3InLCBlcnJvcik7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5fcmVjb25uZWN0KGluc3RhbmNlLmlkKTtcbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbigncmVzcG9uc2UnLCBkYXRhID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoKCkgPT4gYCR7ZGF0YS5hY2NvdW50SWR9OiBSZXNwb25zZSByZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHRpbWVzdGFtcHM6IGRhdGEudGltZXN0YW1wc30pfWApO1xuICAgICAgbGV0IHJlcXVlc3RSZXNvbHZlID0gKGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tkYXRhLnJlcXVlc3RJZF0gfHwge3Jlc29sdmU6ICgpID0+IHt9LCByZWplY3Q6ICgpID0+IHt9fSk7XG4gICAgICBkZWxldGUgaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXTtcbiAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKGRhdGEpO1xuICAgICAgcmVxdWVzdFJlc29sdmUucmVzb2x2ZShkYXRhKTtcbiAgICAgIGlmIChkYXRhLnRpbWVzdGFtcHMgJiYgcmVxdWVzdFJlc29sdmUudHlwZSkge1xuICAgICAgICBkYXRhLnRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ0ZpbmlzaGVkID0gbmV3IERhdGUoKTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycykge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiByZXF1ZXN0UmVzb2x2ZS50eXBlID09PSAndHJhZGUnID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIub25UcmFkZShkYXRhLmFjY291bnRJZCwgZGF0YS50aW1lc3RhbXBzKSA6XG4gICAgICAgICAgICAgIGxpc3RlbmVyLm9uUmVzcG9uc2UoZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RSZXNvbHZlLnR5cGUsIGRhdGEudGltZXN0YW1wcykpXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBvblJlc3BvbnNlIGV2ZW50IGZvciBhY2NvdW50ICcgK1xuICAgICAgICAgICAgICBkYXRhLmFjY291bnRJZCArICcsIHJlcXVlc3QgdHlwZSAnICsgcmVxdWVzdFJlc29sdmUudHlwZSwgZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdwcm9jZXNzaW5nRXJyb3InLCBkYXRhID0+IHtcbiAgICAgIGxldCByZXF1ZXN0UmVzb2x2ZSA9IChpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdIHx8IHtyZXNvbHZlOiAoKSA9PiB7fSwgcmVqZWN0OiAoKSA9PiB7fX0pO1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tkYXRhLnJlcXVlc3RJZF07XG4gICAgICByZXF1ZXN0UmVzb2x2ZS5yZWplY3QodGhpcy5fY29udmVydEVycm9yKGRhdGEpKTtcbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignc3luY2hyb25pemF0aW9uJywgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke2RhdGEuYWNjb3VudElkfToke2RhdGEuaW5zdGFuY2VJbmRleH06IFN5bmMgcGFja2V0IHJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdHlwZTogZGF0YS50eXBlLCBzZXF1ZW5jZU51bWJlcjogZGF0YS5zZXF1ZW5jZU51bWJlciwgc2VxdWVuY2VUaW1lc3RhbXA6IGRhdGEuc2VxdWVuY2VUaW1lc3RhbXAsXG4gICAgICAgIHN5bmNocm9uaXphdGlvbklkOiBkYXRhLnN5bmNocm9uaXphdGlvbklkLCBhcHBsaWNhdGlvbjogZGF0YS5hcHBsaWNhdGlvbiwgaG9zdDogZGF0YS5ob3N0fSl9YCk7XG4gICAgICBpZigoIWRhdGEuc3luY2hyb25pemF0aW9uSWQpIHx8XG4gICAgICBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuYWN0aXZlU3luY2hyb25pemF0aW9uSWRzXG4gICAgICAgIC5pbmNsdWRlcyhkYXRhLnN5bmNocm9uaXphdGlvbklkKSkge1xuICAgICAgICBpZih0aGlzLl9wYWNrZXRMb2dnZXIpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9wYWNrZXRMb2dnZXIubG9nUGFja2V0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ25vb3AnO1xuICAgICAgfVxuICAgICAgdGhpcy5xdWV1ZVBhY2tldChkYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBjb25uZWN0aW9uIHRvIE1ldGFBcGkgc2VydmVyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXMuZm9yRWFjaChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgaW5zdGFuY2UuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IGluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICBmb3IgKGxldCByZXF1ZXN0UmVzb2x2ZSBvZiBPYmplY3QudmFsdWVzKGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlcykpIHtcbiAgICAgICAgICByZXF1ZXN0UmVzb2x2ZS5yZWplY3QobmV3IEVycm9yKCdNZXRhQXBpIGNvbm5lY3Rpb24gY2xvc2VkJykpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlcyA9IHt9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzID0ge307XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzID0gW107XG4gICAgdGhpcy5fcGFja2V0T3JkZXJlci5zdG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBhY2NvdW50IGluZm9ybWF0aW9uIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9uLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcGxhdGZvcm0gcGxhdGZvcm0gaWQgKG10NCBvciBtdDUpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXIgYnJva2VyIG5hbWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGN1cnJlbmN5IGFjY291bnQgYmFzZSBjdXJyZW5jeSBJU08gY29kZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc2VydmVyIGJyb2tlciBzZXJ2ZXIgbmFtZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYmFsYW5jZSBhY2NvdW50IGJhbGFuY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGVxdWl0eSBhY2NvdW50IGxpcXVpZGF0aW9uIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXJnaW4gdXNlZCBtYXJnaW5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyZWVNYXJnaW4gZnJlZSBtYXJnaW5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxldmVyYWdlIGFjY291bnQgbGV2ZXJhZ2UgY29lZmZpY2llbnRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1hcmdpbkxldmVsIG1hcmdpbiBsZXZlbCBjYWxjdWxhdGVkIGFzICUgb2YgZXF1aXR5L21hcmdpblxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHRyYWRlQWxsb3dlZCBmbGFnIGluZGljYXRpbmcgdGhhdCB0cmFkaW5nIGlzIGFsbG93ZWRcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbaW52ZXN0b3JNb2RlXSBmbGFnIGluZGljYXRpbmcgdGhhdCBpbnZlc3RvciBwYXNzd29yZCB3YXMgdXNlZCAoc3VwcG9ydGVkIGZvciBnMiBvbmx5KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWFyZ2luTW9kZSBtYXJnaW4gY2FsY3VsYXRpb24gbW9kZSwgb25lIG9mIEFDQ09VTlRfTUFSR0lOX01PREVfRVhDSEFOR0UsXG4gICAqIEFDQ09VTlRfTUFSR0lOX01PREVfUkVUQUlMX05FVFRJTkcsIEFDQ09VTlRfTUFSR0lOX01PREVfUkVUQUlMX0hFREdJTkdcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWUgQWNjb3VudCBvd25lciBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsb2dpbiBBY2NvdW50IGxvZ2luXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjcmVkaXQgQWNjb3VudCBjcmVkaXQgaW4gdGhlIGRlcG9zaXQgY3VycmVuY3lcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCBpbmZvcm1hdGlvbiBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRBY2NvdW50SW5mb3JtYXRpb24vKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9ybWF0aW9uKGFjY291bnRJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0QWNjb3VudEluZm9ybWF0aW9uJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5hY2NvdW50SW5mb3JtYXRpb247XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBwb3NpdGlvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyUG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkIHBvc2l0aW9uIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBwb3NpdGlvbiB0eXBlIChvbmUgb2YgUE9TSVRJT05fVFlQRV9CVVksIFBPU0lUSU9OX1RZUEVfU0VMTClcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN5bWJvbCBwb3NpdGlvbiBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1hZ2ljIHBvc2l0aW9uIG1hZ2ljIG51bWJlciwgaWRlbnRpZmllcyB0aGUgRUEgd2hpY2ggb3BlbmVkIHRoZSBwb3NpdGlvblxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgdGltZSBwb3NpdGlvbiB3YXMgb3BlbmVkIGF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXJUaW1lIHRpbWUgcG9zaXRpb24gd2FzIG9wZW5lZCBhdCwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtEYXRlfSB1cGRhdGVUaW1lIGxhc3QgcG9zaXRpb24gbW9kaWZpY2F0aW9uIHRpbWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wZW5QcmljZSBwb3NpdGlvbiBvcGVuIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50UHJpY2UgY3VycmVudCBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudFRpY2tWYWx1ZSBjdXJyZW50IHRpY2sgdmFsdWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdG9wTG9zc10gb3B0aW9uYWwgcG9zaXRpb24gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGFrZVByb2ZpdF0gb3B0aW9uYWwgcG9zaXRpb24gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZvbHVtZSBwb3NpdGlvbiB2b2x1bWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN3YXAgcG9zaXRpb24gY3VtdWxhdGl2ZSBzd2FwXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwcm9maXQgcG9zaXRpb24gY3VtdWxhdGl2ZSBwcm9maXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBvcHRpb25hbCBwb3NpdGlvbiBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZFxuICAgKiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBvcHRpb25hbCBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1bnJlYWxpemVkUHJvZml0IHByb2ZpdCBvZiB0aGUgcGFydCBvZiB0aGUgcG9zaXRpb24gd2hpY2ggaXMgbm90IHlldCBjbG9zZWQsIGluY2x1ZGluZyBzd2FwXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWFsaXplZFByb2ZpdCBwcm9maXQgb2YgdGhlIGFscmVhZHkgY2xvc2VkIHBhcnQsIGluY2x1ZGluZyBjb21taXNzaW9ucyBhbmQgc3dhcFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gY29tbWlzc2lvbiBwb3NpdGlvbiBjb21taXNzaW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZWFzb24gcG9zaXRpb24gb3BlbmluZyByZWFzb24uIE9uZSBvZiBQT1NJVElPTl9SRUFTT05fQ0xJRU5ULCBQT1NJVElPTl9SRUFTT05fRVhQRVJULFxuICAgKiBQT1NJVElPTl9SRUFTT05fTU9CSUxFLCBQT1NJVElPTl9SRUFTT05fV0VCLCBQT1NJVElPTl9SRUFTT05fVU5LTk9XTi4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvcG9zaXRpb25wcm9wZXJ0aWVzI2VudW1fcG9zaXRpb25fcmVhc29uJyxcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3JpZ2luYWxDb21tZW50XSBwb3NpdGlvbiBvcmlnaW5hbCBjb21tZW50IChwcmVzZW50IGlmIHBvc3NpYmxlIHRvIHJlc3RvcmUgZnJvbSBoaXN0b3J5KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3VwZGF0ZVBlbmRpbmddIGZsYWcgaW5kaWNhdGluZyB0aGF0IHBvc2l0aW9uIG9yaWdpbmFsIGNvbW1lbnQgYW5kIGNsaWVudElkIHdhcyBub3QgaWRlbnRpZmllZFxuICAgKiB5ZXQgYW5kIHdpbGwgYmUgdXBkYXRlZCBpbiBhIGZ1dHVyZSBwYWNrZXRcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgcG9zaXRpb25zIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFBvc2l0aW9ucy8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyUG9zaXRpb24+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGFycmF5IG9mIG9wZW4gcG9zaXRpb25zXG4gICAqL1xuICBhc3luYyBnZXRQb3NpdGlvbnMoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRQb3NpdGlvbnMnfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnBvc2l0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNwZWNpZmljIHBvc2l0aW9uIGZvciBhIE1ldGFUcmFkZXIgYWNjb3VudCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlYWRUcmFkaW5nVGVybWluYWxTdGF0ZS9yZWFkUG9zaXRpb24vKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyUG9zaXRpb24+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIE1ldGFUcmFkZXIgcG9zaXRpb24gZm91bmRcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9uKGFjY291bnRJZCwgcG9zaXRpb25JZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0UG9zaXRpb24nLCBwb3NpdGlvbklkfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgb3JkZXJcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlck9yZGVyXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgb3JkZXIgdHlwZSAob25lIG9mIE9SREVSX1RZUEVfU0VMTCwgT1JERVJfVFlQRV9CVVksIE9SREVSX1RZUEVfQlVZX0xJTUlULFxuICAgKiBPUkRFUl9UWVBFX1NFTExfTElNSVQsIE9SREVSX1RZUEVfQlVZX1NUT1AsIE9SREVSX1RZUEVfU0VMTF9TVE9QKS4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvb3JkZXJwcm9wZXJ0aWVzI2VudW1fb3JkZXJfdHlwZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RhdGUgb3JkZXIgc3RhdGUgb25lIG9mIChPUkRFUl9TVEFURV9TVEFSVEVELCBPUkRFUl9TVEFURV9QTEFDRUQsIE9SREVSX1NUQVRFX0NBTkNFTEVELFxuICAgKiBPUkRFUl9TVEFURV9QQVJUSUFMLCBPUkRFUl9TVEFURV9GSUxMRUQsIE9SREVSX1NUQVRFX1JFSkVDVEVELCBPUkRFUl9TVEFURV9FWFBJUkVELCBPUkRFUl9TVEFURV9SRVFVRVNUX0FERCxcbiAgICogT1JERVJfU1RBVEVfUkVRVUVTVF9NT0RJRlksIE9SREVSX1NUQVRFX1JFUVVFU1RfQ0FOQ0VMKS4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvb3JkZXJwcm9wZXJ0aWVzI2VudW1fb3JkZXJfc3RhdGVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1hZ2ljIG9yZGVyIG1hZ2ljIG51bWJlciwgaWRlbnRpZmllcyB0aGUgRUEgd2hpY2ggY3JlYXRlZCB0aGUgb3JkZXJcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHRpbWUgb3JkZXIgd2FzIGNyZWF0ZWQgYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSB0aW1lIG9yZGVyIHdhcyBjcmVhdGVkIGF0LCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge0RhdGV9IFtkb25lVGltZV0gdGltZSBvcmRlciB3YXMgZXhlY3V0ZWQgb3IgY2FuY2VsZWQgYXQuIFdpbGwgYmUgc3BlY2lmaWVkIGZvclxuICAgKiBjb21wbGV0ZWQgb3JkZXJzIG9ubHlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtkb25lQnJva2VyVGltZV0gdGltZSBvcmRlciB3YXMgZXhlY3V0ZWQgb3IgY2FuY2VsZWQgYXQsIGluIGJyb2tlciB0aW1lem9uZSxcbiAgICogWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0LiBXaWxsIGJlIHNwZWNpZmllZCBmb3IgY29tcGxldGVkIG9yZGVycyBvbmx5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgb3JkZXIgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgb3BlbiBwcmljZSAobWFya2V0IHByaWNlIGZvciBtYXJrZXQgb3JkZXJzLCBsaW1pdCBwcmljZSBmb3IgbGltaXQgb3JkZXJzIG9yIHN0b3BcbiAgICogcHJpY2UgZm9yIHN0b3Agb3JkZXJzKVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudFByaWNlIGN1cnJlbnQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdG9wTG9zc10gb3JkZXIgc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGFrZVByb2ZpdF0gb3JkZXIgdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZvbHVtZSBvcmRlciByZXF1ZXN0ZWQgcXVhbnRpdHlcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRWb2x1bWUgb3JkZXIgcmVtYWluaW5nIHF1YW50aXR5LCBpLmUuIHJlcXVlc3RlZCBxdWFudGl0eSAtIGZpbGxlZCBxdWFudGl0eVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9zaXRpb25JZCBvcmRlciBwb3NpdGlvbiBpZC4gUHJlc2VudCBvbmx5IGlmIHRoZSBvcmRlciBoYXMgYSBwb3NpdGlvbiBhdHRhY2hlZCB0byBpdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbW1lbnRdIG9yZGVyIGNvbW1lbnQuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGUgY29tbWVudCBhbmQgdGhlIGNsaWVudElkXG4gICAqIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvcmlnaW5hbENvbW1lbnQgb3B0aW9uYWwgb3JkZXIgb3JpZ2luYWwgY29tbWVudCAocHJlc2VudCBpZiBwb3NzaWJsZSB0byByZXN0b3JlIG9yaWdpbmFsIGNvbW1lbnRcbiAgICogZnJvbSBoaXN0b3J5KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwbGF0Zm9ybSBwbGF0Zm9ybSBpZCAobXQ0IG9yIG10NSlcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdXBkYXRlUGVuZGluZ10gZmxhZyBpbmRpY2F0aW5nIHRoYXQgb3JkZXIgY2xpZW50IGlkIGFuZCBvcmlnaW5hbCBjb21tZW50IHdhcyBub3RcbiAgICogaWRlbnRpZmllZCB5ZXQgYW5kIHdpbGwgYmUgdXBkYXRlZCBpbiBhIGZ1dHVyZSBzeW5jaHJvbml6YXRpb24gcGFja2V0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZWFzb24gb3JkZXIgb3BlbmluZyByZWFzb24uIE9uZSBvZiBPUkRFUl9SRUFTT05fQ0xJRU5ULCBPUkRFUl9SRUFTT05fTU9CSUxFLCBPUkRFUl9SRUFTT05fV0VCLFxuICAgKiBPUkRFUl9SRUFTT05fRVhQRVJULCBPUkRFUl9SRUFTT05fU0wsIE9SREVSX1JFQVNPTl9UUCwgT1JERVJfUkVBU09OX1NPLCBPUkRFUl9SRUFTT05fVU5LTk9XTi4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvb3JkZXJwcm9wZXJ0aWVzI2VudW1fb3JkZXJfcmVhc29uLlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZmlsbGluZ01vZGUgb3JkZXIgZmlsbGluZyBtb2RlLiBPbmUgb2YgT1JERVJfRklMTElOR19GT0ssIE9SREVSX0ZJTExJTkdfSU9DLFxuICAgKiBPUkRFUl9GSUxMSU5HX1JFVFVSTi4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvb3JkZXJwcm9wZXJ0aWVzI2VudW1fb3JkZXJfdHlwZV9maWxsaW5nLlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZXhwaXJhdGlvblR5cGUgb3JkZXIgZXhwaXJhdGlvbiB0eXBlLiBPbmUgb2YgT1JERVJfVElNRV9HVEMsIE9SREVSX1RJTUVfREFZLFxuICAgKiBPUkRFUl9USU1FX1NQRUNJRklFRCwgT1JERVJfVElNRV9TUEVDSUZJRURfREFZLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX3RpbWVcbiAgICogQHByb3BlcnR5IHtEYXRlfSBleHBpcmF0aW9uVGltZSBvcHRpb25hbCBvcmRlciBleHBpcmF0aW9uIHRpbWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xvc2VCeVBvc2l0aW9uSWRdIGlkZW50aWZpZXIgb2YgYW4gb3Bwb3NpdGUgcG9zaXRpb24gdXNlZCBmb3IgY2xvc2luZyBieSBvcmRlclxuICAgKiBPUkRFUl9UWVBFX0NMT1NFX0JZXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3RvcExpbWl0UHJpY2VdIHRoZSBMaW1pdCBvcmRlciBwcmljZSBmb3IgdGhlIFN0b3BMaW1pdCBvcmRlclxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBvcGVuIG9yZGVycyBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlcnMvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyT3JkZXI+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcGVuIE1ldGFUcmFkZXIgb3JkZXJzXG4gICAqL1xuICBhc3luYyBnZXRPcmRlcnMoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRPcmRlcnMnfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLm9yZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNwZWNpZmljIG9wZW4gb3JkZXIgZm9yIGEgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlci8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyT3JkZXI+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1ldGF0cmFkZXIgb3JkZXIgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldE9yZGVyKGFjY291bnRJZCwgb3JkZXJJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0T3JkZXInLCBvcmRlcklkfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLm9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgaGlzdG9yeSBvcmRlcnMgc2VhcmNoIHF1ZXJ5IHJlc3BvbnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlck9yZGVyPn0gaGlzdG9yeU9yZGVycyBhcnJheSBvZiBoaXN0b3J5IG9yZGVycyByZXR1cm5lZFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHN5bmNocm9uaXppbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgaGlzdG9yeSBvcmRlciBpbml0aWFsIHN5bmNocm9uaXphdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuICAgKiBhbmQgdGh1cyBzZWFyY2ggcmVzdWx0cyBtYXkgYmUgaW5jb21wbGV0ZVxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHRpY2tldCBudW1iZXIgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWRIaXN0b3J5T3JkZXJzQnlUaWNrZXQvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRpY2tldCB0aWNrZXQgbnVtYmVyIChvcmRlciBpZClcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQoYWNjb3VudElkLCB0aWNrZXQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEhpc3RvcnlPcmRlcnNCeVRpY2tldCcsIHRpY2tldH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5UG9zaXRpb24vKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKGFjY291bnRJZCwgcG9zaXRpb25JZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24nLFxuICAgICAgcG9zaXRpb25JZH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHRpbWUgcmFuZ2UgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UvKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0VGltZSBzdGFydCBvZiB0aW1lIHJhbmdlLCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtEYXRlfSBlbmRUaW1lIGVuZCBvZiB0aW1lIHJhbmdlLCBleGNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBwYWdpbmF0aW9uIG9mZnNldCwgZGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBwYWdpbmF0aW9uIGxpbWl0LCBkZWZhdWx0IGlzIDEwMDBcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UoYWNjb3VudElkLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTAwMCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlJyxcbiAgICAgIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0LCBsaW1pdH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBoaXN0b3J5IGRlYWxzIHNlYXJjaCBxdWVyeSByZXNwb25zZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyRGVhbHNcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyRGVhbD59IGRlYWxzIGFycmF5IG9mIGhpc3RvcnkgZGVhbHMgcmV0dXJuZWRcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBzeW5jaHJvbml6aW5nIGZsYWcgaW5kaWNhdGluZyB0aGF0IGRlYWwgaW5pdGlhbCBzeW5jaHJvbml6YXRpb24gaXMgc3RpbGwgaW4gcHJvZ3Jlc3NcbiAgICogYW5kIHRodXMgc2VhcmNoIHJlc3VsdHMgbWF5IGJlIGluY29tcGxldGVcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgZGVhbFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyRGVhbFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gaWQgZGVhbCBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgZGVhbCB0eXBlIChvbmUgb2YgREVBTF9UWVBFX0JVWSwgREVBTF9UWVBFX1NFTEwsIERFQUxfVFlQRV9CQUxBTkNFLCBERUFMX1RZUEVfQ1JFRElULFxuICAgKiBERUFMX1RZUEVfQ0hBUkdFLCBERUFMX1RZUEVfQ09SUkVDVElPTiwgREVBTF9UWVBFX0JPTlVTLCBERUFMX1RZUEVfQ09NTUlTU0lPTiwgREVBTF9UWVBFX0NPTU1JU1NJT05fREFJTFksXG4gICAqIERFQUxfVFlQRV9DT01NSVNTSU9OX01PTlRITFksIERFQUxfVFlQRV9DT01NSVNTSU9OX0FHRU5UX0RBSUxZLCBERUFMX1RZUEVfQ09NTUlTU0lPTl9BR0VOVF9NT05USExZLFxuICAgKiBERUFMX1RZUEVfSU5URVJFU1QsIERFQUxfVFlQRV9CVVlfQ0FOQ0VMRUQsIERFQUxfVFlQRV9TRUxMX0NBTkNFTEVELCBERUFMX0RJVklERU5ELCBERUFMX0RJVklERU5EX0ZSQU5LRUQsXG4gICAqIERFQUxfVEFYKS4gU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvZGVhbHByb3BlcnRpZXMjZW51bV9kZWFsX3R5cGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGVudHJ5VHlwZSBkZWFsIGVudHJ5IHR5cGUgKG9uZSBvZiBERUFMX0VOVFJZX0lOLCBERUFMX0VOVFJZX09VVCwgREVBTF9FTlRSWV9JTk9VVCxcbiAgICogREVBTF9FTlRSWV9PVVRfQlkpLiBTZWUgaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9kZWFscHJvcGVydGllcyNlbnVtX2RlYWxfZW50cnlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzeW1ib2xdIHN5bWJvbCBkZWFsIHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYWdpY10gZGVhbCBtYWdpYyBudW1iZXIsIGlkZW50aWZpZXMgdGhlIEVBIHdoaWNoIGluaXRpYXRlZCB0aGUgZGVhbFxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgdGltZSB0aGUgZGVhbCB3YXMgY29uZHVjdGVkIGF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXJUaW1lIHRpbWUgdGltZSB0aGUgZGVhbCB3YXMgY29uZHVjdGVkIGF0LCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3ZvbHVtZV0gZGVhbCB2b2x1bWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwcmljZV0gdGhlIHByaWNlIHRoZSBkZWFsIHdhcyBjb25kdWN0ZWQgYXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb21taXNzaW9uXSBkZWFsIGNvbW1pc3Npb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzd2FwXSBkZWFsIHN3YXBcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByb2ZpdCBkZWFsIHByb2ZpdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3Bvc2l0aW9uSWRdIGlkIG9mIHBvc2l0aW9uIHRoZSBkZWFsIHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcmRlcklkXSBpZCBvZiBvcmRlciB0aGUgZGVhbCByZWxhdGVzIHRvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29tbWVudF0gZGVhbCBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZFxuICAgKiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW29yaWdpbmFsQ29tbWVudF0gZGVhbCBvcmlnaW5hbCBjb21tZW50IChwcmVzZW50IGlmIHBvc3NpYmxlIHRvIHJlc3RvcmUgb3JpZ2luYWwgY29tbWVudFxuICAgKiBmcm9tIGhpc3RvcnkpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBsYXRmb3JtIHBsYXRmb3JtIGlkIChtdDQgb3IgbXQ1KVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt1cGRhdGVQZW5kaW5nXSBmbGFnIGluZGljYXRpbmcgdGhhdCBkZWFsIGNsaWVudCBpZCBhbmQgb3JpZ2luYWwgY29tbWVudCB3YXMgbm90XG4gICAqIGlkZW50aWZpZWQgeWV0IGFuZCB3aWxsIGJlIHVwZGF0ZWQgaW4gYSBmdXR1cmUgc3luY2hyb25pemF0aW9uIHBhY2tldFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3JlYXNvbl0gb3B0aW9uYWwgZGVhbCBleGVjdXRpb24gcmVhc29uLiBPbmUgb2YgREVBTF9SRUFTT05fQ0xJRU5ULCBERUFMX1JFQVNPTl9NT0JJTEUsXG4gICAqIERFQUxfUkVBU09OX1dFQiwgREVBTF9SRUFTT05fRVhQRVJULCBERUFMX1JFQVNPTl9TTCwgREVBTF9SRUFTT05fVFAsIERFQUxfUkVBU09OX1NPLCBERUFMX1JFQVNPTl9ST0xMT1ZFUixcbiAgICogREVBTF9SRUFTT05fVk1BUkdJTiwgREVBTF9SRUFTT05fU1BMSVQsIERFQUxfUkVBU09OX1VOS05PV04uIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL2RlYWxwcm9wZXJ0aWVzI2VudW1fZGVhbF9yZWFzb24uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlXSBjdXJyZW50IGV4Y2hhbmdlIHJhdGUgb2YgYWNjb3VudCBjdXJyZW5jeSBpbnRvIGFjY291bnQgYmFzZVxuICAgKiBjdXJyZW5jeSAoVVNEIGlmIHlvdSBkaWQgbm90IG92ZXJyaWRlIGl0KVxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggYSBzcGVjaWZpYyB0aWNrZXQgbnVtYmVyIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVRpY2tldC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGlja2V0IHRpY2tldCBudW1iZXIgKGRlYWwgaWQgZm9yIE1UNSBvciBvcmRlciBpZCBmb3IgTVQ0KVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyRGVhbHM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGRlYWxzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXREZWFsc0J5VGlja2V0KGFjY291bnRJZCwgdGlja2V0KSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5VGlja2V0JywgdGlja2V0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yeSBkZWFscyBmb3IgYSBzcGVjaWZpYyBwb3NpdGlvbiBpZCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlQb3NpdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyRGVhbHM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGRlYWxzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXREZWFsc0J5UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5UG9zaXRpb24nLCBwb3NpdGlvbklkfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yeSBkZWFscyB3aXRoIGZvciBhIHNwZWNpZmljIHRpbWUgcmFuZ2UgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWREZWFsc0J5VGltZVJhbmdlLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRUaW1lIHN0YXJ0IG9mIHRpbWUgcmFuZ2UsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge0RhdGV9IGVuZFRpbWUgZW5kIG9mIHRpbWUgcmFuZ2UsIGV4Y2x1c2l2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IHBhZ2luYXRpb24gb2Zmc2V0LCBkZWZhdWx0IGlzIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IHBhZ2luYXRpb24gbGltaXQsIGRlZmF1bHQgaXMgMTAwMFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyRGVhbHM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGRlYWxzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXREZWFsc0J5VGltZVJhbmdlKGFjY291bnRJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQgPSAwLCBsaW1pdCA9IDEwMDApIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldERlYWxzQnlUaW1lUmFuZ2UnLCBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgb3JkZXIgYW5kIHRyYW5zYWN0aW9uIGhpc3Rvcnkgb2YgYSBzcGVjaWZpZWQgYXBwbGljYXRpb24gc28gdGhhdCBpdCBjYW4gYmUgc3luY2hyb25pemVkIGZyb20gc2NyYXRjaFxuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlbW92ZUhpc3RvcnkvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJlbW92ZSBoaXN0b3J5IGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwcGxpY2F0aW9uXSBhcHBsaWNhdGlvbiB0byByZW1vdmUgaGlzdG9yeSBmb3JcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgaGlzdG9yeSBpcyBjbGVhcmVkXG4gICAqL1xuICByZW1vdmVIaXN0b3J5KGFjY291bnRJZCwgYXBwbGljYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbiwgdHlwZTogJ3JlbW92ZUhpc3RvcnknfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcmRlciBhbmQgdHJhbnNhY3Rpb24gaGlzdG9yeSBvZiBhIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBhbmQgcmVtb3ZlcyB0aGUgYXBwbGljYXRpb24gKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZW1vdmVBcHBsaWNhdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmVtb3ZlIGhpc3RvcnkgYW5kIGFwcGxpY2F0aW9uIGZvclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWRcbiAgICovXG4gIHJlbW92ZUFwcGxpY2F0aW9uKGFjY291bnRJZCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdyZW1vdmVBcHBsaWNhdGlvbid9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHRyYWRlIHJlc3BvbnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJUcmFkZVJlc3BvbnNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBudW1lcmljQ29kZSBudW1lcmljIHJlc3BvbnNlIGNvZGUsIHNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lcnJvcnN3YXJuaW5ncy9lbnVtX3RyYWRlX3JldHVybl9jb2RlcyBhbmRcbiAgICogaHR0cHM6Ly9ib29rLm1xbDQuY29tL2FwcGVuZGl4L2Vycm9ycy4gUmVzcG9uc2UgY29kZXMgd2hpY2ggaW5kaWNhdGUgc3VjY2VzcyBhcmUgMCwgMTAwMDgtMTAwMTAsIDEwMDI1LiBUaGUgcmVzdFxuICAgKiBjb2RlcyBhcmUgZXJyb3JzXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdHJpbmdDb2RlIHN0cmluZyByZXNwb25zZSBjb2RlLCBzZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZXJyb3Jzd2FybmluZ3MvZW51bV90cmFkZV9yZXR1cm5fY29kZXMgYW5kXG4gICAqIGh0dHBzOi8vYm9vay5tcWw0LmNvbS9hcHBlbmRpeC9lcnJvcnMuIFJlc3BvbnNlIGNvZGVzIHdoaWNoIGluZGljYXRlIHN1Y2Nlc3MgYXJlIEVSUl9OT19FUlJPUixcbiAgICogVFJBREVfUkVUQ09ERV9QTEFDRUQsIFRSQURFX1JFVENPREVfRE9ORSwgVFJBREVfUkVUQ09ERV9ET05FX1BBUlRJQUwsIFRSQURFX1JFVENPREVfTk9fQ0hBTkdFUy4gVGhlIHJlc3QgY29kZXMgYXJlXG4gICAqIGVycm9ycy5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2UgaHVtYW4tcmVhZGFibGUgcmVzcG9uc2UgbWVzc2FnZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCB3aGljaCB3YXMgY3JlYXRlZC9tb2RpZmllZCBkdXJpbmcgdGhlIHRyYWRlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHdoaWNoIHdhcyBtb2RpZmllZCBkdXJpbmcgdGhlIHRyYWRlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgdHJhZGUgb24gYSBjb25uZWN0ZWQgTWV0YVRyYWRlciBhY2NvdW50IChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIGV4ZWN1dGUgdHJhZGUgZm9yXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlclRyYWRlfSB0cmFkZSB0cmFkZSB0byBleGVjdXRlIChzZWUgZG9jcyBmb3IgcG9zc2libGUgdHJhZGUgdHlwZXMpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgYXN5bmMgdHJhZGUoYWNjb3VudElkLCB0cmFkZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3RyYWRlJywgdHJhZGV9KTtcbiAgICByZXNwb25zZS5yZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlIHx8IHt9O1xuICAgIHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgPSByZXNwb25zZS5yZXNwb25zZS5zdHJpbmdDb2RlIHx8IHJlc3BvbnNlLnJlc3BvbnNlLmRlc2NyaXB0aW9uO1xuICAgIHJlc3BvbnNlLnJlc3BvbnNlLm51bWVyaWNDb2RlID0gcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgIT09IHVuZGVmaW5lZCA/IHJlc3BvbnNlLnJlc3BvbnNlLm51bWVyaWNDb2RlIDpcbiAgICAgIHJlc3BvbnNlLnJlc3BvbnNlLmVycm9yO1xuICAgIGlmIChbJ0VSUl9OT19FUlJPUicsICdUUkFERV9SRVRDT0RFX1BMQUNFRCcsICdUUkFERV9SRVRDT0RFX0RPTkUnLCAnVFJBREVfUkVUQ09ERV9ET05FX1BBUlRJQUwnLFxuICAgICAgJ1RSQURFX1JFVENPREVfTk9fQ0hBTkdFUyddLmluY2x1ZGVzKHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgfHwgcmVzcG9uc2UucmVzcG9uc2UuZGVzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzcG9uc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUcmFkZUVycm9yKHJlc3BvbnNlLnJlc3BvbnNlLm1lc3NhZ2UsIHJlc3BvbnNlLnJlc3BvbnNlLm51bWVyaWNDb2RlLCByZXNwb25zZS5yZXNwb25zZS5zdHJpbmdDb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhc2sgdGhhdCBlbnN1cmVzIHRoZSBhY2NvdW50IGdldHMgc3Vic2NyaWJlZCB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZCB0byBzdWJzY3JpYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbnN0YW5jZU51bWJlcl0gaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqL1xuICBlbnN1cmVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuc3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gdGhlIE1ldGF0cmFkZXIgdGVybWluYWwgZXZlbnRzIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvc3Vic2NyaWJlLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzdWJzY3JpYmUgdG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbnN0YW5jZU51bWJlcl0gaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3N1YnNjcmliZScsIGluc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb25uZWN0cyB0byB0aGUgTWV0YXRyYWRlciB0ZXJtaW5hbCAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlY29ubmVjdC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmVjb25uZWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gcmVjb25uZWN0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHJlY29ubmVjdChhY2NvdW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAncmVjb25uZWN0J30pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSB0ZXJtaW5hbCB0byBzdGFydCBzeW5jaHJvbml6YXRpb24gcHJvY2Vzc1xuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvc3luY2hyb25pemluZy9zeW5jaHJvbml6ZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc3luY2hyb25pemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlSW5kZXggaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3QgbmFtZSBvZiBob3N0IHRvIHN5bmNocm9uaXplIHdpdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lIGZyb20gd2hhdCBkYXRlIHRvIHN0YXJ0IHN5bmNocm9uaXppbmcgaGlzdG9yeSBvcmRlcnMgZnJvbS4gSWYgbm90IHNwZWNpZmllZCxcbiAgICogdGhlIGVudGlyZSBvcmRlciBoaXN0b3J5IHdpbGwgYmUgZG93bmxvYWRlZC5cbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydGluZ0RlYWxUaW1lIGZyb20gd2hhdCBkYXRlIHRvIHN0YXJ0IGRlYWwgc3luY2hyb25pemF0aW9uIGZyb20uIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYWxsXG4gICAqIGhpc3RvcnkgZGVhbHMgd2lsbCBiZSBkb3dubG9hZGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlY2lmaWNhdGlvbnNNZDUgc3BlY2lmaWNhdGlvbnMgTUQ1IGhhc2hcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uc01kNSBwb3NpdGlvbnMgTUQ1IGhhc2hcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyc01kNSBvcmRlcnMgTUQ1IGhhc2hcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gc3RhcnRlZFxuICAgKi9cbiAgc3luY2hyb25pemUoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4LCBob3N0LCBzeW5jaHJvbml6YXRpb25JZCwgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lLCBzdGFydGluZ0RlYWxUaW1lLCBcbiAgICBzcGVjaWZpY2F0aW9uc01kNSwgcG9zaXRpb25zTWQ1LCBvcmRlcnNNZDUpIHtcbiAgICBjb25zdCBzeW5jVGhyb3R0bGVyID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3RoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXV0uc3luY2hyb25pemF0aW9uVGhyb3R0bGVyO1xuICAgIHJldHVybiBzeW5jVGhyb3R0bGVyLnNjaGVkdWxlU3luY2hyb25pemUoYWNjb3VudElkLCB7cmVxdWVzdElkOiBzeW5jaHJvbml6YXRpb25JZCwgXG4gICAgICB0eXBlOiAnc3luY2hyb25pemUnLCBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUsIHN0YXJ0aW5nRGVhbFRpbWUsIGluc3RhbmNlSW5kZXgsIGhvc3QsXG4gICAgICBzcGVjaWZpY2F0aW9uc01kNSwgcG9zaXRpb25zTWQ1LCBvcmRlcnNNZDV9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3Igc2VydmVyLXNpZGUgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIHRvIGNvbXBsZXRlLlxuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvc3luY2hyb25pemluZy93YWl0U3luY2hyb25pemVkLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzeW5jaHJvbml6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBsaWNhdGlvblBhdHRlcm4gTWV0YUFwaSBhcHBsaWNhdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiwgZGVmYXVsdCBpcyAuKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dEluU2Vjb25kcyB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgMzAwIHNlY29uZHNcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gc3RhcnRlZFxuICAgKi9cbiAgd2FpdFN5bmNocm9uaXplZChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAnd2FpdFN5bmNocm9uaXplZCcsIGFwcGxpY2F0aW9uUGF0dGVybiwgdGltZW91dEluU2Vjb25kcyxcbiAgICAgIGluc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSxcbiAgICB0aW1lb3V0SW5TZWNvbmRzICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogTWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmtldERhdGFTdWJzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgc3Vic2NyaXB0aW9uIHR5cGUsIG9uZSBvZiBxdW90ZXMsIGNhbmRsZXMsIHRpY2tzLCBvciBtYXJrZXREZXB0aFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpbWVmcmFtZV0gd2hlbiBzdWJzY3JpcHRpb24gdHlwZSBpcyBjYW5kbGVzLCBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZVxuICAgKiBjYW5kbGVzIG11c3QgYmUgZ2VuZXJhdGVkLiBBbGxvd2VkIHZhbHVlcyBmb3IgTVQ1IGFyZSAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSwgMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCxcbiAgICogNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtbi4gQWxsb3dlZCB2YWx1ZXMgZm9yIE1UNCBhcmUgMW0sIDVtLCAxNW0gMzBtLCAxaCwgNGgsIDFkLCAxdywgMW1uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW50ZXJ2YWxJbk1pbGxpc2Vjb25kc10gZGVmaW5lcyBob3cgZnJlcXVlbnRseSB0aGUgdGVybWluYWwgd2lsbCBzdHJlYW0gZGF0YSB0byBjbGllbnQuIElmIG5vdFxuICAgKiBzZXQsIHRoZW4gdGhlIHZhbHVlIGNvbmZpZ3VyZWQgaW4gYWNjb3VudCB3aWxsIGJlIHVzZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvbWFya2V0RGF0YVN0cmVhbWluZy9zdWJzY3JpYmVUb01hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb24gdG8gY3JlYXRlIG9yIHVwZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHN1YnNjcmliZVRvTWFya2V0RGF0YShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAnc3Vic2NyaWJlVG9NYXJrZXREYXRhJywgc3ltYm9sLCBzdWJzY3JpcHRpb25zLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBvbiB0aGUgc2VydmVyIHRvIHByZXZlbnQgdGhlbSBmcm9tIGV4cGlyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNjcmlwdGlvbnMgYXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyB0byByZWZyZXNoXG4gICAqL1xuICByZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgc3Vic2NyaXB0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdyZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMnLCBzdWJzY3JpcHRpb25zLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZXQgZGF0YSB1bnN1YnNjcmlwdGlvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXJrZXREYXRhVW5zdWJzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgc3Vic2NyaXB0aW9uIHR5cGUsIG9uZSBvZiBxdW90ZXMsIGNhbmRsZXMsIHRpY2tzLCBvciBtYXJrZXREZXB0aFxuICAgKi9cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvbWFya2V0RGF0YVN0cmVhbWluZy91bnN1YnNjcmliZUZyb21NYXJrZXREYXRhLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdW5zdWJzY3JpcHRpb24gcmVxdWVzdCB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICB1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICd1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhJywgc3ltYm9sLCBzdWJzY3JpcHRpb25zLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgc3ltYm9scyBhdmFpbGFibGUgb24gYW4gYWNjb3VudCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9scy8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9scyBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW1ib2xzIGFyZSByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFN5bWJvbHMoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xzJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5zeW1ib2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzcGVjaWZpY2F0aW9uIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9sU3BlY2lmaWNhdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNwZWNpZmljYXRpb24gaXMgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRTeW1ib2xTcGVjaWZpY2F0aW9uKGFjY291bnRJZCwgc3ltYm9sKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xTcGVjaWZpY2F0aW9uJywgc3ltYm9sfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnNwZWNpZmljYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHByaWNlIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9sUHJpY2UvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbCBwcmljZSBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgcHJpY2UgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xQcmljZT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBwcmljZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFN5bWJvbFByaWNlKGFjY291bnRJZCwgc3ltYm9sKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xQcmljZScsIHN5bWJvbH0pO1xuICAgIHJldHVybiByZXNwb25zZS5wcmljZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJpY2UgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRDYW5kbGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIGNhbmRsZSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgY2FuZGxlIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZWZyYW1lIGRlZmluZXMgdGhlIHRpbWVmcmFtZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGNhbmRsZSBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXMgZm9yXG4gICAqIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWQgdmFsdWVzXG4gICAqIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQ2FuZGxlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNhbmRsZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldENhbmRsZShhY2NvdW50SWQsIHN5bWJvbCwgdGltZWZyYW1lKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRDYW5kbGUnLCBzeW1ib2wsIHRpbWVmcmFtZX0pO1xuICAgIHJldHVybiByZXNwb25zZS5jYW5kbGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGxhdGVzdCB0aWNrIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkVGljay8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHRpY2sgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2sgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUaWNrPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRpY2sgaXMgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRUaWNrKGFjY291bnRJZCwgc3ltYm9sKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRUaWNrJywgc3ltYm9sfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRpY2s7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGxhdGVzdCBvcmRlciBib29rIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkQm9vay8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIG9yZGVyIGJvb2sgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIG9yZGVyIGJvb2sgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJCb29rPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIG9yZGVyIGJvb2sgaXMgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRCb29rKGFjY291bnRJZCwgc3ltYm9sKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRCb29rJywgc3ltYm9sfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvb2s7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHVwdGltZSBzdGF0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHByaWNlIGZvclxuICAgKiBAcGFyYW0ge09iamVjdH0gdXB0aW1lIHVwdGltZSBzdGF0aXN0aWNzIHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHVwdGltZSBzdGF0aXN0aWNzIGlzIHN1Ym1pdHRlZFxuICAgKi9cbiAgc2F2ZVVwdGltZShhY2NvdW50SWQsIHVwdGltZSkge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdzYXZlVXB0aW1lJywgdXB0aW1lfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvc3luY2hyb25pemluZy91bnN1YnNjcmliZSkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgcHJpY2UgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc29ja2V0IHVuc3Vic2NyaWJlZFxuICAgKi9cbiAgYXN5bmMgdW5zdWJzY3JpYmUoYWNjb3VudElkKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5jYW5jZWxBY2NvdW50KGFjY291bnRJZCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3Vuc3Vic2NyaWJlJ30pO1xuICAgICAgZGVsZXRlIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmKCEoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciBmb3Igc3BlY2lmaWMgYWNjb3VudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25MaXN0ZW5lcn0gbGlzdGVuZXIgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIHRvIGFkZFxuICAgKi9cbiAgYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudElkLCBsaXN0ZW5lcikge1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXSA9IGxpc3RlbmVycztcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50SWQsIGxpc3RlbmVyKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXSA9IGxpc3RlbmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxhdGVuY3kgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtMYXRlbmN5TGlzdGVuZXJ9IGxpc3RlbmVyIGxhdGVuY3kgbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRMYXRlbmN5TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGF0ZW5jeSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0xhdGVuY3lMaXN0ZW5lcn0gbGlzdGVuZXIgbGF0ZW5jeSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUxhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHJlY29ubmVjdCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1JlY29ubmVjdExpc3RlbmVyfSBsaXN0ZW5lciByZWNvbm5lY3QgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZCBvZiBsaXN0ZW5lclxuICAgKi9cbiAgYWRkUmVjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIsIGFjY291bnRJZCkge1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycy5wdXNoKHthY2NvdW50SWQsIGxpc3RlbmVyfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyByZWNvbm5lY3QgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtSZWNvbm5lY3RMaXN0ZW5lcn0gbGlzdGVuZXIgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycyA9IHRoaXMuX3JlY29ubmVjdExpc3RlbmVycy5maWx0ZXIobCA9PiBsLmxpc3RlbmVyICE9PSBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJbnRlbmRlZCBmb3IgdXNlIGluIHVuaXQgdGVzdHMuXG4gICAqL1xuICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBRdWV1ZXMgYW4gYWNjb3VudCBwYWNrZXQgZm9yIHByb2Nlc3NpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBwYWNrZXQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgcXVldWVQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYWNjb3VudElkID0gcGFja2V0LmFjY291bnRJZDtcbiAgICBjb25zdCBwYWNrZXRzID0gdGhpcy5fcGFja2V0T3JkZXJlci5yZXN0b3JlT3JkZXIocGFja2V0KS5maWx0ZXIocCA9PiBwLnR5cGUgIT09ICdub29wJyk7XG4gICAgaWYodGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyAmJiBwYWNrZXQuc2VxdWVuY2VOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZXZlbnRzID0gcGFja2V0cy5tYXAocGFja2V0SXRlbSA9PiAoKSA9PiBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0SXRlbSkpKTtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSkge1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gZXZlbnRzO1xuICAgICAgICB0aGlzLl9jYWxsQWNjb3VudEV2ZW50cyhhY2NvdW50SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSA9IHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0uY29uY2F0KGV2ZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldHMuZm9yRWFjaChwYWNrZXRJdGVtID0+IHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0SXRlbSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZXMgYWNjb3VudCBldmVudCBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtQcm9taXNlfSBldmVudCBldmVudCB0byBleGVjdXRlXG4gICAqL1xuICBxdWV1ZUV2ZW50KGFjY291bnRJZCwgZXZlbnQpIHtcbiAgICBpZih0aGlzLl9zZXF1ZW50aWFsRXZlbnRQcm9jZXNzaW5nKSB7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0pIHsgXG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0gPSBbZXZlbnRdO1xuICAgICAgICB0aGlzLl9jYWxsQWNjb3VudEV2ZW50cyhhY2NvdW50SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXS5wdXNoKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfY2FsbEFjY291bnRFdmVudHMoYWNjb3VudElkKSB7XG4gICAgaWYodGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSkge1xuICAgICAgd2hpbGUodGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXS5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXVswXSgpO1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfcmVjb25uZWN0KHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgd2hpbGUgKCFpbnN0YW5jZS5zb2NrZXQuY29ubmVjdGVkICYmICFpbnN0YW5jZS5pc1JlY29ubmVjdGluZyAmJiBpbnN0YW5jZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdHJ5UmVjb25uZWN0KHNvY2tldEluc3RhbmNlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF90cnlSZWNvbm5lY3Qoc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCAmJiAhaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgJiYgaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2Vzc2lvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmlvLm9wdHMuZXh0cmFIZWFkZXJzWydDbGllbnQtSWQnXSA9IGNsaWVudElkO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby5vcHRzLnF1ZXJ5LmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby51cmkgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJVcmwoKTtcbiAgICAgICAgICBpbnN0YW5jZS5zb2NrZXQuY29ubmVjdCgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9LCAxMDAwKSk7XG4gIH1cblxuICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICBhc3luYyBfcnBjUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBsZXQgc29ja2V0SW5zdGFuY2VJbmRleCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1thY2NvdW50SWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAodGhpcy5fc3Vic2NyaWJlTG9jayAmJiAoKG5ldyBEYXRlKHRoaXMuX3N1YnNjcmliZUxvY2sucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKSA+IERhdGUubm93KCkgJiYgXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoKS5sZW5ndGggPCB0aGlzLl9zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpIHx8IFxuICAgICAgICAobmV3IERhdGUodGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdFRpbWUpLmdldFRpbWUoKSArIHRoaXMuX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzICogMTAwMCA+IFxuICAgICAgICBEYXRlLm5vdygpICYmIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoKS5sZW5ndGggPj0gdGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdEFjY291bnRzKSkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fc29ja2V0SW5zdGFuY2VzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBhY2NvdW50Q291bnRlciA9IHRoaXMuZ2V0QXNzaWduZWRBY2NvdW50cyhpbmRleCkubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW2luZGV4XTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2spIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSX1BFUl9TRVJWRVInICYmIFxuICAgICAgICAgIChuZXcgRGF0ZShpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpIHx8IFxuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5kZXgpLmxlbmd0aCA+PSBpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2sudHlwZSA9PT0gJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfU0VSVkVSJyAmJiBcbiAgICAgICAgICBuZXcgRGF0ZShpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpICYmXG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbmRleCkubGVuZ3RoID49IGluc3RhbmNlLnN1YnNjcmliZUxvY2subG9ja2VkQXRBY2NvdW50cykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFjY291bnRDb3VudGVyIDwgdGhpcy5fbWF4QWNjb3VudHNQZXJJbnN0YW5jZSkge1xuICAgICAgICAgIHNvY2tldEluc3RhbmNlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gPSBzb2NrZXRJbnN0YW5jZUluZGV4O1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1tzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICBpZiAoIWluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgfSBlbHNlIGlmKCF0aGlzLmNvbm5lY3RlZChzb2NrZXRJbnN0YW5jZUluZGV4KSkge1xuICAgICAgYXdhaXQgaW5zdGFuY2UuY29ubmVjdFJlc3VsdDtcbiAgICB9XG4gICAgaWYocmVxdWVzdC50eXBlID09PSAnc3Vic2NyaWJlJykge1xuICAgICAgcmVxdWVzdC5zZXNzaW9uSWQgPSBpbnN0YW5jZS5zZXNzaW9uSWQ7XG4gICAgfVxuICAgIGlmKFsndHJhZGUnLCAnc3Vic2NyaWJlJ10uaW5jbHVkZXMocmVxdWVzdC50eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KGFjY291bnRJZCwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICAgIGxldCByZXRyeUNvdW50ZXIgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9tYWtlUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgaWYoZXJyLm5hbWUgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgICAgICBsZXQgY2FsY1JldHJ5Q291bnRlciA9IHJldHJ5Q291bnRlcjtcbiAgICAgICAgICBsZXQgY2FsY1JlcXVlc3RUaW1lID0gMDtcbiAgICAgICAgICB3aGlsZShjYWxjUmV0cnlDb3VudGVyIDwgdGhpcy5fcmV0cmllcykge1xuICAgICAgICAgICAgY2FsY1JldHJ5Q291bnRlcisrO1xuICAgICAgICAgICAgY2FsY1JlcXVlc3RUaW1lICs9IE1hdGgubWluKE1hdGgucG93KDIsIGNhbGNSZXRyeUNvdW50ZXIpICogdGhpcy5fbWluUmV0cnlEZWxheUluU2Vjb25kcyxcbiAgICAgICAgICAgICAgdGhpcy5fbWF4UmV0cnlEZWxheUluU2Vjb25kcykgKiAxMDAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXRyeVRpbWUgPSBuZXcgRGF0ZShlcnIubWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSArIGNhbGNSZXF1ZXN0VGltZSA+IHJldHJ5VGltZSAmJiByZXRyeUNvdW50ZXIgPCB0aGlzLl9yZXRyaWVzKSB7XG4gICAgICAgICAgICBpZihEYXRlLm5vdygpIDwgcmV0cnlUaW1lKSB7XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgcmV0cnlUaW1lIC0gRGF0ZS5ub3coKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudGVyKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihbJ05vdFN5bmNocm9uaXplZEVycm9yJywgJ1RpbWVvdXRFcnJvcicsICdOb3RBdXRoZW50aWNhdGVkRXJyb3InLFxuICAgICAgICAgICdJbnRlcm5hbEVycm9yJ10uaW5jbHVkZXMoZXJyLm5hbWUpICYmIFxuICAgICAgICAgIHJldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5Q291bnRlcikgKiBcbiAgICAgICAgICAgIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMsIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMpICogMTAwMCkpO1xuICAgICAgICAgIHJldHJ5Q291bnRlcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9tYWtlUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1t0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF1dO1xuICAgIGxldCByZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZCB8fCByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHJlcXVlc3QudGltZXN0YW1wcyA9IHtjbGllbnRQcm9jZXNzaW5nU3RhcnRlZDogbmV3IERhdGUoKX07XG4gICAgbGV0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzb2NrZXRJbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbcmVxdWVzdElkXSA9IFxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0LCB0eXBlOiByZXF1ZXN0LnR5cGV9KSxcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBUaW1lb3V0RXJyb3IoJ01ldGFBcGkgd2Vic29ja2V0IGNsaWVudCAnICsgXG4gICAgICAgIGByZXF1ZXN0ICR7cmVxdWVzdC5yZXF1ZXN0SWR9IG9mIHR5cGUgJHtyZXF1ZXN0LnR5cGV9IHRpbWVkIG91dC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGFjY291bnQgaXMgY29ubmVjdGVkIGAgK1xuICAgICAgICAgICd0byBicm9rZXIgYmVmb3JlIHJldHJ5aW5nIHlvdXIgcmVxdWVzdC4nKSksICh0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgfHwgdGhpcy5fcmVxdWVzdFRpbWVvdXQpKVxuICAgIF0pO1xuICAgIHJlcXVlc3QuYWNjb3VudElkID0gYWNjb3VudElkO1xuICAgIHJlcXVlc3QuYXBwbGljYXRpb24gPSByZXF1ZXN0LmFwcGxpY2F0aW9uIHx8IHRoaXMuX2FwcGxpY2F0aW9uO1xuICAgIGlmICghcmVxdWVzdC5yZXF1ZXN0SWQpIHtcbiAgICAgIHJlcXVlc3QucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoKCkgPT4gYCR7YWNjb3VudElkfTogU2VuZGluZyByZXF1ZXN0OiAke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QpfWApO1xuICAgIHNvY2tldEluc3RhbmNlLnNvY2tldC5lbWl0KCdyZXF1ZXN0JywgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9jb252ZXJ0RXJyb3IoZGF0YSkge1xuICAgIGlmIChkYXRhLmVycm9yID09PSAnVmFsaWRhdGlvbkVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLmRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdOb3RTeW5jaHJvbml6ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90U3luY2hyb25pemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IFRpbWVvdXRFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEF1dGhlbnRpY2F0ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Q29ubmVjdGVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUcmFkZUVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBUcmFkZUVycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5udW1lcmljQ29kZSwgZGF0YS5zdHJpbmdDb2RlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdVbmF1dGhvcml6ZWRFcnJvcicpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLm1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgX2NvbnZlcnRJc29UaW1lVG9EYXRlKHBhY2tldCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKGxldCBmaWVsZCBpbiBwYWNrZXQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBhY2tldFtmaWVsZF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBmaWVsZC5tYXRjaCgvdGltZSR8VGltZSQvKSAmJiBcbiAgICAgICAgIWZpZWxkLm1hdGNoKC9icm9rZXJUaW1lJHxCcm9rZXJUaW1lJHx0aW1lZnJhbWUkLykpIHtcbiAgICAgICAgcGFja2V0W2ZpZWxkXSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudGltZXN0YW1wcykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgZm9yIChsZXQgZmllbGQgaW4gcGFja2V0LnRpbWVzdGFtcHMpIHtcbiAgICAgICAgcGFja2V0LnRpbWVzdGFtcHNbZmllbGRdID0gbmV3IERhdGUocGFja2V0LnRpbWVzdGFtcHNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudHlwZSA9PT0gJ3ByaWNlcycpIHtcbiAgICAgIGZvciAobGV0IHByaWNlIG9mIHBhY2tldC5wcmljZXMgfHwgW10pIHtcbiAgICAgICAgaWYgKHByaWNlLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gcHJpY2UudGltZXN0YW1wcykge1xuICAgICAgICAgICAgcHJpY2UudGltZXN0YW1wc1tmaWVsZF0gPSBuZXcgRGF0ZShwcmljZS50aW1lc3RhbXBzW2ZpZWxkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgc3ltYm9sIHNwZWNpZmljYXRpb24uIENvbnRhaW5zIHN5bWJvbCBzcGVjaWZpY2F0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbi8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpY2tTaXplIHRpY2sgc2l6ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWluVm9sdW1lIG1pbmltdW0gb3JkZXIgdm9sdW1lIGZvciB0aGUgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhWb2x1bWUgbWF4aW11bSBvcmRlciB2b2x1bWUgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZvbHVtZVN0ZXAgb3JkZXIgdm9sdW1lIHN0ZXAgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtBcnJheTxTdHJpbmc+fSBsaXN0IG9mIGFsbG93ZWQgb3JkZXIgZmlsbGluZyBtb2Rlcy4gQ2FuIGNvbnRhaW4gT1JERVJfRklMTElOR19GT0ssIE9SREVSX0ZJTExJTkdfSU9DIG9yXG4gICAqIGJvdGguIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9maWxsaW5nX21vZGUgZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlYWwgZXhlY3V0aW9uIG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgU1lNQk9MX1RSQURFX0VYRUNVVElPTl9SRVFVRVNULFxuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0lOU1RBTlQsIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fTUFSS0VULCBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0VYQ0hBTkdFLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9leGVjdXRpb24gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRyYWN0U2l6ZSB0cmFkZSBjb250cmFjdCBzaXplXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSBxdW90ZVNlc3Npb25zIHF1b3RlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSB0cmFkZVNlc3Npb25zIHRyYWRlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdHJhZGVNb2RlXSBvcmRlciBleGVjdXRpb24gdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSBTWU1CT0xfVFJBREVfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1RSQURFX01PREVfTE9OR09OTFksIFNZTUJPTF9UUkFERV9NT0RFX1NIT1JUT05MWSwgU1lNQk9MX1RSQURFX01PREVfQ0xPU0VPTkxZLCBTWU1CT0xfVFJBREVfTU9ERV9GVUxMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtib25kQWNjcnVlZEludGVyZXN0XSBhY2NydWVkIGludGVyZXN0IOKAkyBhY2N1bXVsYXRlZCBjb3Vwb24gaW50ZXJlc3QsIGkuZS4gcGFydCBvZiB0aGUgY291cG9uXG4gICAqIGludGVyZXN0IGNhbGN1bGF0ZWQgaW4gcHJvcG9ydGlvbiB0byB0aGUgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIGNvdXBvbiBib25kIGlzc3VhbmNlIG9yIHRoZSBsYXN0IGNvdXBvbiBpbnRlcmVzdFxuICAgKiBwYXltZW50XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYm9uZEZhY2VWYWx1ZV0gZmFjZSB2YWx1ZSDigJMgaW5pdGlhbCBib25kIHZhbHVlIHNldCBieSB0aGUgaXNzdWVyXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbb3B0aW9uU3RyaWtlXSB0aGUgc3RyaWtlIHByaWNlIG9mIGFuIG9wdGlvbi4gVGhlIHByaWNlIGF0IHdoaWNoIGFuIG9wdGlvbiBidXllciBjYW4gYnV5IChpbiBhXG4gICAqIENhbGwgb3B0aW9uKSBvciBzZWxsIChpbiBhIFB1dCBvcHRpb24pIHRoZSB1bmRlcmx5aW5nIGFzc2V0LCBhbmQgdGhlIG9wdGlvbiBzZWxsZXIgaXMgb2JsaWdlZCB0byBzZWxsIG9yIGJ1eSB0aGVcbiAgICogYXBwcm9wcmlhdGUgYW1vdW50IG9mIHRoZSB1bmRlcmx5aW5nIGFzc2V0LlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW29wdGlvblByaWNlU2Vuc2l2aXR5XSBvcHRpb24vd2FycmFudCBzZW5zaXRpdml0eSBzaG93cyBieSBob3cgbWFueSBwb2ludHMgdGhlIHByaWNlIG9mIHRoZVxuICAgKiBvcHRpb24ncyB1bmRlcmx5aW5nIGFzc2V0IHNob3VsZCBjaGFuZ2Ugc28gdGhhdCB0aGUgcHJpY2Ugb2YgdGhlIG9wdGlvbiBjaGFuZ2VzIGJ5IG9uZSBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xpcXVpZGl0eVJhdGVdIGxpcXVpZGl0eSBSYXRlIGlzIHRoZSBzaGFyZSBvZiB0aGUgYXNzZXQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIG1hcmdpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaW5pdGlhbE1hcmdpbiBpbml0aWFsIG1hcmdpbiBtZWFucyB0aGUgYW1vdW50IGluIHRoZSBtYXJnaW4gY3VycmVuY3kgcmVxdWlyZWQgZm9yIG9wZW5pbmcgYVxuICAgKiBwb3NpdGlvbiB3aXRoIHRoZSB2b2x1bWUgb2Ygb25lIGxvdC4gSXQgaXMgdXNlZCBmb3IgY2hlY2tpbmcgYSBjbGllbnQncyBhc3NldHMgd2hlbiBoZSBvciBzaGUgZW50ZXJzIHRoZSBtYXJrZXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1haW50ZW5hbmNlTWFyZ2luIHRoZSBtYWludGVuYW5jZSBtYXJnaW4uIElmIGl0IGlzIHNldCwgaXQgc2V0cyB0aGUgbWFyZ2luIGFtb3VudCBpbiB0aGUgbWFyZ2luXG4gICAqIGN1cnJlbmN5IG9mIHRoZSBzeW1ib2wsIGNoYXJnZWQgZnJvbSBvbmUgbG90LiBJdCBpcyB1c2VkIGZvciBjaGVja2luZyBhIGNsaWVudCdzIGFzc2V0cyB3aGVuIGhpcy9oZXIgYWNjb3VudCBzdGF0ZVxuICAgKiBjaGFuZ2VzLiBJZiB0aGUgbWFpbnRlbmFuY2UgbWFyZ2luIGlzIGVxdWFsIHRvIDAsIHRoZSBpbml0aWFsIG1hcmdpbiBpcyB1c2VkXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWRnZWRNYXJnaW4gY29udHJhY3Qgc2l6ZSBvciBtYXJnaW4gdmFsdWUgcGVyIG9uZSBsb3Qgb2YgaGVkZ2VkIHBvc2l0aW9ucyAob3Bwb3NpdGVseSBkaXJlY3RlZFxuICAgKiBwb3NpdGlvbnMgb2Ygb25lIHN5bWJvbCkuIFR3byBtYXJnaW4gY2FsY3VsYXRpb24gbWV0aG9kcyBhcmUgcG9zc2libGUgZm9yIGhlZGdlZCBwb3NpdGlvbnMuIFRoZSBjYWxjdWxhdGlvbiBtZXRob2RcbiAgICogaXMgZGVmaW5lZCBieSB0aGUgYnJva2VyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2hlZGdlZE1hcmdpblVzZXNMYXJnZXJMZWddIGNhbGN1bGF0aW5nIGhlZGdpbmcgbWFyZ2luIHVzaW5nIHRoZSBsYXJnZXIgbGVnIChCdXkgb3IgU2VsbClcbiAgICogQHByb3BlcnRpZXMge1N0cmluZ30gbWFyZ2luQ3VycmVuY3kgbWFyZ2luIGN1cnJlbmN5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcmljZUNhbGN1bGF0aW9uTW9kZSBjb250cmFjdCBwcmljZSBjYWxjdWxhdGlvbiBtb2RlLiBPbmUgb2YgU1lNQk9MX0NBTENfTU9ERV9VTktOT1dOLFxuICAgKiBTWU1CT0xfQ0FMQ19NT0RFX0ZPUkVYLCBTWU1CT0xfQ0FMQ19NT0RFX0ZPUkVYX05PX0xFVkVSQUdFLCBTWU1CT0xfQ0FMQ19NT0RFX0ZVVFVSRVMsIFNZTUJPTF9DQUxDX01PREVfQ0ZELFxuICAgKiBTWU1CT0xfQ0FMQ19NT0RFX0NGRElOREVYLCBTWU1CT0xfQ0FMQ19NT0RFX0NGRExFVkVSQUdFLCBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfU1RPQ0tTLFxuICAgKiBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfRlVUVVJFUywgU1lNQk9MX0NBTENfTU9ERV9FWENIX0ZVVFVSRVNfRk9SVFMsIFNZTUJPTF9DQUxDX01PREVfRVhDSF9CT05EUyxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9FWENIX1NUT0NLU19NT0VYLCBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfQk9ORFNfTU9FWCwgU1lNQk9MX0NBTENfTU9ERV9TRVJWX0NPTExBVEVSQUwuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI2VudW1fc3ltYm9sX2NhbGNfbW9kZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYXNlQ3VycmVuY3kgYmFzZSBjdXJyZW5jeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3Byb2ZpdEN1cnJlbmN5XSBwcm9maXQgY3VycmVuY3lcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN3YXBNb2RlIHN3YXAgY2FsY3VsYXRpb24gbW9kZWwuIEFsbG93ZWQgdmFsdWVzIGFyZSBTWU1CT0xfU1dBUF9NT0RFX0RJU0FCTEVELFxuICAgKiBTWU1CT0xfU1dBUF9NT0RFX1BPSU5UUywgU1lNQk9MX1NXQVBfTU9ERV9DVVJSRU5DWV9TWU1CT0wsIFNZTUJPTF9TV0FQX01PREVfQ1VSUkVOQ1lfTUFSR0lOLFxuICAgKiBTWU1CT0xfU1dBUF9NT0RFX0NVUlJFTkNZX0RFUE9TSVQsIFNZTUJPTF9TV0FQX01PREVfSU5URVJFU1RfQ1VSUkVOVCwgU1lNQk9MX1NXQVBfTU9ERV9JTlRFUkVTVF9PUEVOLFxuICAgKiBTWU1CT0xfU1dBUF9NT0RFX1JFT1BFTl9DVVJSRU5ULCBTWU1CT0xfU1dBUF9NT0RFX1JFT1BFTl9CSUQuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI2VudW1fc3ltYm9sX3N3YXBfbW9kZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3dhcExvbmddIGxvbmcgc3dhcCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBTaG9ydF0gc2hvcnQgc3dhcCB2YWx1ZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N3YXBSb2xsb3ZlcjNEYXlzXSBkYXkgb2Ygd2VlayB0byBjaGFyZ2UgMyBkYXlzIHN3YXAgcm9sbG92ZXIuIEFsbG93ZWQgdmFsdWVzIGFyZSBTVU5EQVksXG4gICAqIE1PTkRBWSwgVFVFU0RBWSwgV0VETkVTREFZLCBUSFVSREFZLCBGUklEQVksIFNBVFVSREFZLCBOT05FXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gYWxsb3dlZEV4cGlyYXRpb25Nb2RlcyBhbGxvd2VkIG9yZGVyIGV4cGlyYXRpb24gbW9kZXMuIEFsbG93ZWQgdmFsdWVzIGFyZVxuICAgKiBTWU1CT0xfRVhQSVJBVElPTl9HVEMsIFNZTUJPTF9FWFBJUkFUSU9OX0RBWSwgU1lNQk9MX0VYUElSQVRJT05fU1BFQ0lGSUVELCBTWU1CT0xfRVhQSVJBVElPTl9TUEVDSUZJRURfREFZLlxuICAgKiBTZWUgaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNzeW1ib2xfZXhwaXJhdGlvbl9tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtBcnJheTxTdHJpbmc+fSBhbGxvd2VkT3JkZXJUeXBlcyBhbGxvd2VkIG9yZGVyIHR5cGVzLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX09SREVSX01BUktFVCxcbiAgICogU1lNQk9MX09SREVSX0xJTUlULCBTWU1CT0xfT1JERVJfU1RPUCwgU1lNQk9MX09SREVSX1NUT1BfTElNSVQsIFNZTUJPTF9PUkRFUl9TTCwgU1lNQk9MX09SREVSX1RQLFxuICAgKiBTWU1CT0xfT1JERVJfQ0xPU0VCWS4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjc3ltYm9sX29yZGVyX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gb3JkZXJHVENNb2RlIGlmIHRoZSBleHBpcmF0aW9uTW9kZSBwcm9wZXJ0eSBpcyBzZXQgdG8gU1lNQk9MX0VYUElSQVRJT05fR1RDIChnb29kIHRpbGxcbiAgICogY2FuY2VsZWQpLCB0aGUgZXhwaXJhdGlvbiBvZiBwZW5kaW5nIG9yZGVycywgYXMgd2VsbCBhcyBvZiBTdG9wIExvc3MvVGFrZSBQcm9maXQgb3JkZXJzIHNob3VsZCBiZSBhZGRpdGlvbmFsbHkgc2V0XG4gICAqIHVzaW5nIHRoaXMgZW51bWVyYXRpb24uIEFsbG93ZWQgdmFsdWVzIGFyZSBTWU1CT0xfT1JERVJTX0dUQywgU1lNQk9MX09SREVSU19EQUlMWSxcbiAgICogU1lNQk9MX09SREVSU19EQUlMWV9FWENMVURJTkdfU1RPUFMuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI2VudW1fc3ltYm9sX29yZGVyX2d0Y19tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRpZ2l0cyBkaWdpdHMgYWZ0ZXIgYSBkZWNpbWFsIHBvaW50XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcGF0aF0gcGF0aCBpbiB0aGUgc3ltYm9sIHRyZWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlc2NyaXB0aW9uIHN5bWJvbCBkZXNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge0RhdGV9IFtzdGFydFRpbWVdIGRhdGUgb2YgdGhlIHN5bWJvbCB0cmFkZSBiZWdpbm5pbmcgKHVzdWFsbHkgdXNlZCBmb3IgZnV0dXJlcylcbiAgICogQHByb3BlcnR5IHtEYXRlfSBbZXhwaXJhdGlvblRpbWVdIGRhdGUgb2YgdGhlIHN5bWJvbCB0cmFkZSBlbmQgKHVzdWFsbHkgdXNlZCBmb3IgZnV0dXJlcylcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGF0cmFkZXIgdHJhZGUgb3IgcXVvdGUgc2Vzc2lvbiBjb250YWluZXIsIGluZGV4ZWQgYnkgd2Vla2RheVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyU2Vzc2lvbnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtTVU5EQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBTVU5EQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtNT05EQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBNT05EQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtUVUVTREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgVFVFU0RBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1dFRE5FU0RBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFdFRE5FU0RBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1RIVVJTREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgVEhVUlNEQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtGUklEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBGUklEQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtTQVRVUkRBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFNBVFVSREFZXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhdHJhZGVyIHRyYWRlIG9yIHF1b3RlIHNlc3Npb25cbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclNlc3Npb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZyb20gc2Vzc2lvbiBzdGFydCB0aW1lLCBpbiBoaC5tbS5zcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0byBzZXNzaW9uIGVuZCB0aW1lLCBpbiBoaC5tbS5zcy5TU1MgZm9ybWF0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHN5bWJvbCBwcmljZS4gQ29udGFpbnMgY3VycmVudCBwcmljZSBmb3IgYSBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvbW9kZWxzL21ldGF0cmFkZXJTeW1ib2xQcmljZS8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTeW1ib2xQcmljZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBiaWQgYmlkIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhc2sgYXNrIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwcm9maXRUaWNrVmFsdWUgdGljayB2YWx1ZSBmb3IgYSBwcm9maXRhYmxlIHBvc2l0aW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsb3NzVGlja1ZhbHVlIHRpY2sgdmFsdWUgZm9yIGEgbG9zaW5nIHBvc2l0aW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlXSBjdXJyZW50IGV4Y2hhbmdlIHJhdGUgb2YgYWNjb3VudCBjdXJyZW5jeSBpbnRvIGFjY291bnQgYmFzZVxuICAgKiBjdXJyZW5jeSAoVVNEIGlmIHlvdSBkaWQgbm90IG92ZXJyaWRlIGl0KVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgcXVvdGUgdGltZSwgaW4gSVNPIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSB0aW1lIHF1b3RlIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIGNhbmRsZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyQ2FuZGxlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aW1lZnJhbWUgdGltZWZyYW1lIGNhbmRsZSB3YXMgZ2VuZXJhdGVkIGZvciwgZS5nLiAxaC4gT25lIG9mIDFtLCAybSwgM20sIDRtLCA1bSwgNm0sIDEwbSwgMTJtLFxuICAgKiAxNW0sIDIwbSwgMzBtLCAxaCwgMmgsIDNoLCA0aCwgNmgsIDhoLCAxMmgsIDFkLCAxdywgMW1uXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSBjYW5kbGUgb3BlbmluZyB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBicm9rZXJUaW1lIGNhbmRsZSBvcGVuaW5nIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcGVuIG9wZW4gcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggaGlnaCBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbG93IGxvdyBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY2xvc2UgY2xvc2UgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpY2tWb2x1bWUgdGljayB2b2x1bWUsIGkuZS4gbnVtYmVyIG9mIHRpY2tzIGluc2lkZSB0aGUgY2FuZGxlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzcHJlYWQgc3ByZWFkIGluIHBvaW50c1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gdm9sdW1lIHRyYWRlIHZvbHVtZVxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciB0aWNrIGRhdGFcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclRpY2tcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gYSBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgdGltZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gYnJva2VyVGltZSB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2JpZF0gYmlkIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYXNrXSBhc2sgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0XSBsYXN0IGRlYWwgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2b2x1bWVdIHZvbHVtZSBmb3IgdGhlIGN1cnJlbnQgbGFzdCBkZWFsIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWRlIGlzIHRpY2sgYSByZXN1bHQgb2YgYnV5IG9yIHNlbGwgZGVhbCwgb25lIG9mIGJ1eSBvciBzZWxsXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIG9yZGVyIGJvb2tcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckJvb2tcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gYSBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgdGltZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gYnJva2VyVGltZSB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJCb29rRW50cnk+fSBib29rIGxpc3Qgb2Ygb3JkZXIgYm9vayBlbnRyaWVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIG9yZGVyIGJvb2sgZW50cnlcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckJvb2tFbnRyeVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBlbnRyeSB0eXBlLCBvbmUgb2YgQk9PS19UWVBFX1NFTEwsIEJPT0tfVFlQRV9CVVksIEJPT0tfVFlQRV9TRUxMX01BUktFVCxcbiAgICogQk9PS19UWVBFX0JVWV9NQVJLRVRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHByaWNlIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b2x1bWUgdm9sdW1lXG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzXG4gIGFzeW5jIF9wcm9jZXNzU3luY2hyb25pemF0aW9uUGFja2V0KGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc29ja2V0SW5zdGFuY2UgPSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tkYXRhLmFjY291bnRJZF1dO1xuICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgc29ja2V0SW5zdGFuY2UpIHtcbiAgICAgICAgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnVwZGF0ZVN5bmNocm9uaXphdGlvbklkKGRhdGEuc3luY2hyb25pemF0aW9uSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSBkYXRhLmluc3RhbmNlSW5kZXggfHwgMDtcbiAgICAgIGxldCBpbnN0YW5jZUlkID0gZGF0YS5hY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlciArICc6JyArIChkYXRhLmhvc3QgfHwgMCk7XG4gICAgICBsZXQgaW5zdGFuY2VJbmRleCA9IGluc3RhbmNlTnVtYmVyICsgJzonICsgKGRhdGEuaG9zdCB8fCAwKTtcblxuICAgICAgY29uc3QgaXNPbmx5QWN0aXZlSW5zdGFuY2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUluc3RhbmNlSWRzID0gT2JqZWN0LmtleXModGhpcy5fY29ubmVjdGVkSG9zdHMpLmZpbHRlcihpbnN0YW5jZSA9PiBcbiAgICAgICAgICBpbnN0YW5jZS5zdGFydHNXaXRoKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpKTtcbiAgICAgICAgcmV0dXJuICFhY3RpdmVJbnN0YW5jZUlkcy5sZW5ndGggfHwgYWN0aXZlSW5zdGFuY2VJZHMubGVuZ3RoID09PSAxICYmIGFjdGl2ZUluc3RhbmNlSWRzWzBdID09PSBpbnN0YW5jZUlkO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FuY2VsRGlzY29ubmVjdFRpbWVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc2V0RGlzY29ubmVjdFRpbWVyID0gKCkgPT4ge1xuICAgICAgICBjYW5jZWxEaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgdGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYoaXNPbmx5QWN0aXZlSW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5vblRpbWVvdXQoZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5xdWV1ZUV2ZW50KGRhdGEuYWNjb3VudElkLCAoKSA9PiBQcm9taXNlLnJlc29sdmUob25EaXNjb25uZWN0ZWQodHJ1ZSkpKTtcbiAgICAgICAgfSwgNjAwMDApO1xuICAgICAgfTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gYXN5bmMgKGlzVGltZW91dCA9IGZhbHNlKSA9PiB7IFxuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBpZihpc09ubHlBY3RpdmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZFByb21pc2VzID0gW107XG4gICAgICAgICAgICBpZighaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIG9uRGlzY29ubmVjdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkKGluc3RhbmNlSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgICAnYWJvdXQgZGlzY29ubmVjdGVkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uRGlzY29ubmVjdGVkUHJvbWlzZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvblN0cmVhbUNsb3NlZFByb21pc2VzID0gW107XG4gICAgICAgICAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLm9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSWQpO1xuICAgICAgICAgICAgaWYoc29ja2V0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnJlbW92ZUlkQnlQYXJhbWV0ZXJzKGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgZGF0YS5ob3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgICAgb25TdHJlYW1DbG9zZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN0cmVhbUNsb3NlZChpbnN0YW5jZUluZGV4KSlcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICAgJ2Fib3V0IHN0cmVhbSBjbG9zZWQgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25TdHJlYW1DbG9zZWRQcm9taXNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb25uZWN0ZWRIb3N0c1tpbnN0YW5jZUlkXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdhdXRoZW50aWNhdGVkJykge1xuICAgICAgICByZXNldERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICBpZigoIWRhdGEuc2Vzc2lvbklkKSB8fCBzb2NrZXRJbnN0YW5jZSAmJiAoZGF0YS5zZXNzaW9uSWQgPT09IHNvY2tldEluc3RhbmNlLnNlc3Npb25JZCkpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWRIb3N0c1tpbnN0YW5jZUlkXSA9IGRhdGEuaG9zdDtcbiAgICAgICAgICBjb25zdCBvbkNvbm5lY3RlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25Db25uZWN0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5yZXBsaWNhcykpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICsgXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgY29ubmVjdGVkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uQ29ubmVjdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgY2FuY2VsRGlzY29ubmVjdFRpbWVyKCk7XG4gICAgICAgIGF3YWl0IG9uRGlzY29ubmVjdGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bmNocm9uaXphdGlvblN0YXJ0ZWQnKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdID0ge1xuICAgICAgICAgIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsXG4gICAgICAgICAgcG9zaXRpb25zVXBkYXRlZDogZGF0YS5wb3NpdGlvbnNVcGRhdGVkICE9PSB1bmRlZmluZWQgPyBkYXRhLnBvc2l0aW9uc1VwZGF0ZWQgOiB0cnVlLFxuICAgICAgICAgIG9yZGVyc1VwZGF0ZWQ6IGRhdGEub3JkZXJzVXBkYXRlZCAhPT0gdW5kZWZpbmVkID8gZGF0YS5vcmRlcnNVcGRhdGVkIDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBhd2FpdCBsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgXG4gICAgICAgICAgICAgICAgZGF0YS5zcGVjaWZpY2F0aW9uc1VwZGF0ZWQgIT09IHVuZGVmaW5lZCA/IGRhdGEuc3BlY2lmaWNhdGlvbnNVcGRhdGVkIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uc1VwZGF0ZWQgIT09IHVuZGVmaW5lZCA/IGRhdGEucG9zaXRpb25zVXBkYXRlZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YS5vcmRlcnNVcGRhdGVkICE9PSB1bmRlZmluZWQgPyBkYXRhLm9yZGVyc1VwZGF0ZWQgOiB0cnVlKTtcbiAgICAgICAgICAgIH0pKCkpXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICdhYm91dCBzeW5jaHJvbml6YXRpb24gc3RhcnRlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2FjY291bnRJbmZvcm1hdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBsaXN0ZW5lci5vbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5hY2NvdW50SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdLnBvc2l0aW9uc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZighdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgYWNjb3VudEluZm9ybWF0aW9uIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZGVhbHMnKSB7XG4gICAgICAgIGZvciAobGV0IGRlYWwgb2YgKGRhdGEuZGVhbHMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25EZWFsQWRkZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uRGVhbEFkZGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uRGVhbEFkZGVkKGluc3RhbmNlSW5kZXgsIGRlYWwpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgZGVhbHMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25EZWFsQWRkZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnb3JkZXJzJykge1xuICAgICAgICBjb25zdCBvblBlbmRpbmdPcmRlcnNSZXBsYWNlZFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICBvblBlbmRpbmdPcmRlcnNSZXBsYWNlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgYXdhaXQgbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5vcmRlcnMgfHwgW10pO1xuICAgICAgICAgICAgICBhd2FpdCBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAnYWJvdXQgb3JkZXJzIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uUGVuZGluZ09yZGVyc1JlcGxhY2VkUHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdoaXN0b3J5T3JkZXJzJykge1xuICAgICAgICBmb3IgKGxldCBoaXN0b3J5T3JkZXIgb2YgKGRhdGEuaGlzdG9yeU9yZGVycyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQoaW5zdGFuY2VJbmRleCwgaGlzdG9yeU9yZGVyKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IGhpc3RvcnlPcmRlcnMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25IaXN0b3J5T3JkZXJBZGRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdwb3NpdGlvbnMnKSB7XG4gICAgICAgIGNvbnN0IG9uUG9zaXRpb25zUmVwbGFjZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25Qb3NpdGlvbnNSZXBsYWNlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgYXdhaXQgbGlzdGVuZXIub25Qb3NpdGlvbnNSZXBsYWNlZChpbnN0YW5jZUluZGV4LCBkYXRhLnBvc2l0aW9ucyB8fCBbXSk7XG4gICAgICAgICAgICAgIGF3YWl0IGxpc3RlbmVyLm9uUG9zaXRpb25zU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpO1xuICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgJ2Fib3V0IHBvc2l0aW9ucyBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBvc2l0aW9uc1JlcGxhY2VkUHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgIGlmIChkYXRhLmFjY291bnRJbmZvcm1hdGlvbikge1xuICAgICAgICAgIGNvbnN0IG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLmFjY291bnRJbmZvcm1hdGlvbikpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCB1cGRhdGUgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uIG9mIChkYXRhLnVwZGF0ZWRQb3NpdGlvbnMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25Qb3NpdGlvblVwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uUG9zaXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uUG9zaXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBvc2l0aW9uVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbklkIG9mIChkYXRhLnJlbW92ZWRQb3NpdGlvbklkcyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblBvc2l0aW9uUmVtb3ZlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25Qb3NpdGlvblJlbW92ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25Qb3NpdGlvblJlbW92ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb25JZCkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCB1cGRhdGUgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25Qb3NpdGlvblJlbW92ZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgb3JkZXIgb2YgKGRhdGEudXBkYXRlZE9yZGVycyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblBlbmRpbmdPcmRlclVwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uUGVuZGluZ09yZGVyVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblBlbmRpbmdPcmRlclVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgb3JkZXIpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgdXBkYXRlIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uUGVuZGluZ09yZGVyVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcmRlcklkIG9mIChkYXRhLmNvbXBsZXRlZE9yZGVySWRzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uUGVuZGluZ09yZGVyQ29tcGxldGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblBlbmRpbmdPcmRlckNvbXBsZXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblBlbmRpbmdPcmRlckNvbXBsZXRlZChpbnN0YW5jZUluZGV4LCBvcmRlcklkKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBlbmRpbmdPcmRlckNvbXBsZXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoaXN0b3J5T3JkZXIgb2YgKGRhdGEuaGlzdG9yeU9yZGVycyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQoaW5zdGFuY2VJbmRleCwgaGlzdG9yeU9yZGVyKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGRlYWwgb2YgKGRhdGEuZGVhbHMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25EZWFsQWRkZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uRGVhbEFkZGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uRGVhbEFkZGVkKGluc3RhbmNlSW5kZXgsIGRlYWwpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgdXBkYXRlIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uRGVhbEFkZGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICBkYXRhLnRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ0ZpbmlzaGVkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBjb25zdCBvblVwZGF0ZVByb21pc2VzID0gW107XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgfHwgW10pIHtcbiAgICAgICAgICAgIG9uVXBkYXRlUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uVXBkYXRlKGRhdGEuYWNjb3VudElkLCBkYXRhLnRpbWVzdGFtcHMpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGF0ZW5jeSBgICtcbiAgICAgICAgICAgICAgICAgICdsaXN0ZW5lciBhYm91dCB1cGRhdGUgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25VcGRhdGVQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZGVhbFN5bmNocm9uaXphdGlvbkZpbmlzaGVkJykge1xuICAgICAgICBjb25zdCBvbkRlYWxzU3luY2hyb25pemVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGlmKHNvY2tldEluc3RhbmNlKSB7XG4gICAgICAgICAgICBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIucmVtb3ZlU3luY2hyb25pemF0aW9uSWQoZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uRGVhbHNTeW5jaHJvbml6ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCkpXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGFib3V0IGAgK1xuICAgICAgICAgICAgICAgICAgJ2RlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkRlYWxzU3luY2hyb25pemVkUHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdvcmRlclN5bmNocm9uaXphdGlvbkZpbmlzaGVkJykge1xuICAgICAgICBjb25zdCBvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCkpXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGFib3V0IGAgK1xuICAgICAgICAgICAgICAgICAgJ29yZGVyU3luY2hyb25pemF0aW9uRmluaXNoZWQgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkUHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBpZih0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0gJiYgZGF0YS5hdXRoZW50aWNhdGVkICYmIFxuICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZShkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHx8IFxuICAgICAgICAgICAgICAhdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc0FjY291bnRTdWJzY3JpYmluZyhkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5jYW5jZWxTdWJzY3JpYmUoZGF0YS5hY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlcik7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwKSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oJ2l0IHNlZW1zIGxpa2Ugd2UgYXJlIG5vdCBjb25uZWN0ZWQgdG8gYSBydW5uaW5nIEFQSSAnICtcbiAgICAgICAgICAgICAgJ3NlcnZlciB5ZXQsIHJldHJ5aW5nIHN1YnNjcmlwdGlvbiBmb3IgYWNjb3VudCAnICsgaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVN1YnNjcmliZShkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICAgIGNvbnN0IG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZChpbnN0YW5jZUluZGV4LCAhIWRhdGEuY29ubmVjdGVkKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGArIFxuICAgICAgICAgICAgICAgICAgJ2xpc3RlbmVyIGFib3V0IGJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRQcm9taXNlcyk7XG4gICAgICAgICAgaWYgKGRhdGEuaGVhbHRoU3RhdHVzKSB7XG4gICAgICAgICAgICBjb25zdCBvbkhlYWx0aFN0YXR1c1Byb21pc2VzID0gW107XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICAgIG9uSGVhbHRoU3RhdHVzUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25IZWFsdGhTdGF0dXMoaW5zdGFuY2VJbmRleCwgZGF0YS5oZWFsdGhTdGF0dXMpKVxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGAgKyBcbiAgICAgICAgICAgICAgICAgICAgJ2xpc3RlbmVyIGFib3V0IHNlcnZlci1zaWRlIGhlYWx0aFN0YXR1cyBldmVudCcsIGVycikpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkhlYWx0aFN0YXR1c1Byb21pc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZG93bmdyYWRlU3Vic2NyaXB0aW9uJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogTWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3Igc3ltYm9sIGAgK1xuICAgICAgICAgIGAke2RhdGEuc3ltYm9sfSB3ZXJlIGRvd25ncmFkZWQgYnkgdGhlIHNlcnZlciBkdWUgdG8gcmF0ZSBsaW1pdHMuIFVwZGF0ZWQgc3Vic2NyaXB0aW9uczogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoZGF0YS51cGRhdGVzKX0sIHJlbW92ZWQgc3Vic2NyaXB0aW9uczogJHtKU09OLnN0cmluZ2lmeShkYXRhLnVuc3Vic2NyaXB0aW9ucyl9LiBgICtcbiAgICAgICAgICAnUGxlYXNlIHJlYWQgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3JhdGVMaW1pdGluZy8gZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgICAgY29uc3Qgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnN5bWJvbCwgZGF0YS51cGRhdGVzLFxuICAgICAgICAgICAgICBkYXRhLnVuc3Vic2NyaXB0aW9ucykpXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICdhYm91dCBzdWJzY3JpcHRpb24gZG93bmdyYWRlIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uU3Vic2NyaXB0aW9uRG93bmdyYWRlUHJvbWlzZXMpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzcGVjaWZpY2F0aW9ucycpIHtcbiAgICAgICAgY29uc3Qgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3BlY2lmaWNhdGlvbnMgfHwgW10sXG4gICAgICAgICAgICAgIGRhdGEucmVtb3ZlZFN5bWJvbHMgfHwgW10pKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgJ2Fib3V0IHNwZWNpZmljYXRpb25zIHVwZGF0ZWQgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWRQcm9taXNlcyk7XG4gICAgICAgIGZvciAobGV0IHNwZWNpZmljYXRpb24gb2YgKGRhdGEuc3BlY2lmaWNhdGlvbnMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIHNwZWNpZmljYXRpb24pKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgc3BlY2lmaWNhdGlvbiB1cGRhdGVkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcmVtb3ZlZFN5bWJvbCBvZiAoZGF0YS5yZW1vdmVkU3ltYm9scyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQoaW5zdGFuY2VJbmRleCwgcmVtb3ZlZFN5bWJvbCkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBzcGVjaWZpY2F0aW9ucyByZW1vdmVkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAncHJpY2VzJykge1xuICAgICAgICBsZXQgcHJpY2VzID0gZGF0YS5wcmljZXMgfHwgW107XG4gICAgICAgIGxldCBjYW5kbGVzID0gZGF0YS5jYW5kbGVzIHx8IFtdO1xuICAgICAgICBsZXQgdGlja3MgPSBkYXRhLnRpY2tzIHx8IFtdO1xuICAgICAgICBsZXQgYm9va3MgPSBkYXRhLmJvb2tzIHx8IFtdO1xuICAgICAgICBjb25zdCBvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgaWYgKHByaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN5bWJvbFByaWNlc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcHJpY2VzLCBkYXRhLmVxdWl0eSwgZGF0YS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5mcmVlTWFyZ2luLCBkYXRhLm1hcmdpbkxldmVsLCBkYXRhLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBwcmljZXMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25DYW5kbGVzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBjYW5kbGVzLCBkYXRhLmVxdWl0eSwgZGF0YS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5mcmVlTWFyZ2luLCBkYXRhLm1hcmdpbkxldmVsLCBkYXRhLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBjYW5kbGVzIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblRpY2tzVXBkYXRlZChpbnN0YW5jZUluZGV4LCB0aWNrcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEuZnJlZU1hcmdpbiwgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgdGlja3MgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJvb2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgb25TeW1ib2xQcmljZXNVcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uQm9va3NVcGRhdGVkKGluc3RhbmNlSW5kZXgsIGJvb2tzLCBkYXRhLmVxdWl0eSwgZGF0YS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5mcmVlTWFyZ2luLCBkYXRhLm1hcmdpbkxldmVsLCBkYXRhLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBib29rcyBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcyk7XG4gICAgICAgIGZvciAobGV0IHByaWNlIG9mIHByaWNlcykge1xuICAgICAgICAgIGNvbnN0IG9uU3ltYm9sUHJpY2VVcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblN5bWJvbFByaWNlVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN5bWJvbFByaWNlVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZSkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBwcmljZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFByaWNlVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMpIHtcbiAgICAgICAgICBpZiAocHJpY2UudGltZXN0YW1wcykge1xuICAgICAgICAgICAgcHJpY2UudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3Qgb25TeW1ib2xQcmljZVByb21pc2VzID0gW107XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzIHx8IFtdKSB7XG4gICAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN5bWJvbFByaWNlKGRhdGEuYWNjb3VudElkLCBwcmljZS5zeW1ib2wsIHByaWNlLnRpbWVzdGFtcHMpKVxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxhdGVuY3kgYCArXG4gICAgICAgICAgICAgICAgICAgICdsaXN0ZW5lciBhYm91dCBwcmljZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFByaWNlUHJvbWlzZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgaW5jb21pbmcgc3luY2hyb25pemF0aW9uIHBhY2tldCcsIGVycik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2ZpcmVSZWNvbm5lY3RlZChzb2NrZXRJbnN0YW5jZUluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlY29ubmVjdExpc3RlbmVycyA9IFtdO1xuICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2xpc3RlbmVyLmFjY291bnRJZF0gPT09IHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICAgICAgICByZWNvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzKS5mb3JFYWNoKHN5bmNocm9uaXphdGlvbklkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3Nbc3luY2hyb25pemF0aW9uSWRdLmFjY291bnRJZF1cbiAgICAgICAgICAgID09PSBzb2NrZXRJbnN0YW5jZUluZGV4KSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW3N5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZWNvbm5lY3RBY2NvdW50SWRzID0gcmVjb25uZWN0TGlzdGVuZXJzLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lci5hY2NvdW50SWQpO1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5vblJlY29ubmVjdGVkKHNvY2tldEluc3RhbmNlSW5kZXgsIHJlY29ubmVjdEFjY291bnRJZHMpO1xuICAgICAgdGhpcy5fcGFja2V0T3JkZXJlci5vblJlY29ubmVjdGVkKHJlY29ubmVjdEFjY291bnRJZHMpO1xuXG4gICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiByZWNvbm5lY3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLmxpc3RlbmVyLm9uUmVjb25uZWN0ZWQoKSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIG5vdGlmeSByZWNvbm5lY3QgbGlzdGVuZXInLCBlcnIpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgcmVjb25uZWN0ZWQgZXZlbnQnLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9nZXRTZXJ2ZXJVcmwoKSB7XG4gICAgbGV0IHVybDtcbiAgICBpZih0aGlzLl91c2VTaGFyZWRDbGllbnRBcGkpIHtcbiAgICAgIHVybCA9IHRoaXMuX3VybDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly9tdC1wcm92aXNpb25pbmctYXBpLXYxLiR7dGhpcy5fZG9tYWlufS91c2Vycy9jdXJyZW50L3NlcnZlcnMvbXQtY2xpZW50LWFwaWAsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnYXV0aC10b2tlbic6IHRoaXMuX3Rva2VuXG4gICAgICAgIH0sXG4gICAgICAgIGpzb246IHRydWUsXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9odHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgICB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgfVxuICAgIGNvbnN0IGlzU2hhcmVkQ2xpZW50QXBpID0gdXJsID09PSB0aGlzLl91cmw7XG4gICAgbGV0IGxvZ01lc3NhZ2UgPSAnQ29ubmVjdGluZyBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgdG8gdGhlIE1ldGFBcGkgc2VydmVyICcgK1xuICAgICAgYHZpYSAke3VybH0gJHtpc1NoYXJlZENsaWVudEFwaSA/ICdzaGFyZWQnIDogJ2RlZGljYXRlZCd9IHNlcnZlci5gO1xuICAgIGlmKHRoaXMuX2ZpcnN0Q29ubmVjdCAmJiAhaXNTaGFyZWRDbGllbnRBcGkpIHtcbiAgICAgIGxvZ01lc3NhZ2UgKz0gJyBQbGVhc2Ugbm90ZSB0aGF0IGl0IGNhbiB0YWtlIHVwIHRvIDMgbWludXRlcyBmb3IgeW91ciBkZWRpY2F0ZWQgc2VydmVyIHRvIHN0YXJ0IGZvciB0aGUgJyArXG4gICAgICAgICdmaXJzdCB0aW1lLiBEdXJpbmcgdGhpcyB0aW1lIGl0IGlzIE9LIGlmIHlvdSBzZWUgc29tZSBjb25uZWN0aW9uIGVycm9ycy4nO1xuICAgICAgdGhpcy5fZmlyc3RDb25uZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2xvZ2dlci5pbmZvKGxvZ01lc3NhZ2UpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxufVxuIl19