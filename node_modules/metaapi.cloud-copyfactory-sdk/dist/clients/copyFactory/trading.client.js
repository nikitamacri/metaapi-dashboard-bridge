'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _metaApi = require('../metaApi.client');

var _metaApi2 = _interopRequireDefault(_metaApi);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * metaapi.cloud CopyFactory trading API (trade copying trading API) client (see
 * https://metaapi.cloud/docs/copyfactory/)
 */
class TradingClient extends _metaApi2.default {

  /**
   * Constructs CopyFactory trading API client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {String} token authorization token
   * @param {String} domain domain to connect to, default is agiliumtrade.agiliumtrade.ai
   */
  constructor(httpClient, token, domain = 'agiliumtrade.agiliumtrade.ai') {
    super(httpClient, token, domain);
    this._host = `https://trading-api-v1.${domain}`;
  }

  /**
   * Resynchronizes the account. See
   * https://metaapi.cloud/docs/copyfactory/restApi/api/trading/resynchronize/
   * @param {String} accountId account id
   * @param {Array<String>} strategyIds optional array of strategy ids to recynchronize. Default is to synchronize all
   * strategies
   * @return {Promise} promise which resolves when resynchronization is scheduled
   */
  async resynchronize(accountId, strategyIds) {
    if (this._isNotJwtToken()) {
      return this._handleNoAccessError('resynchronize');
    }
    const opts = {
      url: `${this._host}/users/current/accounts/${accountId}/resynchronize`,
      method: 'POST',
      headers: {
        'auth-token': this._token
      },
      qs: {
        strategyId: strategyIds
      },
      json: true
    };
    return this._httpClient.request(opts);
  }

  /**
   * CopyFactory strategy stopout
   * @typedef {Object} CopyFactoryStrategyStopout
   * @property {CopyFactoryStrategyIdAndName} strategy strategy which was stopped out
   * @property {String} reason stopout reason. One of yearly-balance, monthly-balance, daily-balance, yearly-equity,
   * monthly-equity, daily-equity, max-drawdown
   * @property {String} reasonDescription human-readable description of the stopout reason
   * @property {Date} stoppedAt time the strategy was stopped at
   * @property {Date} stoppedTill time the strategy is stopped till
   */

  /**
   * Returns subscriber account stopouts. See
   * https://metaapi.cloud/docs/copyfactory/restApi/api/trading/getStopOuts/
   * @param {String} accountId account id
   * @return {Promise<Array<CopyFactoryStrategyStopout>>} promise which resolves with stopouts found
   */
  async getStopouts(accountId) {
    if (this._isNotJwtToken()) {
      return this._handleNoAccessError('getStopouts');
    }
    const opts = {
      url: `${this._host}/users/current/accounts/${accountId}/stopouts`,
      method: 'GET',
      headers: {
        'auth-token': this._token
      },
      json: true
    };
    return this._httpClient.request(opts);
  }

  /**
   * Resets strategy stopouts. See
   * https://metaapi.cloud/docs/copyfactory/restApi/api/trading/resetStopOuts/
   * @param {String} accountId account id
   * @param {String} strategyId strategy id
   * @param {String} reason stopout reason to reset. One of yearly-balance, monthly-balance, daily-balance,
   * yearly-equity, monthly-equity, daily-equity, max-drawdown
   * @return {Promise} promise which resolves when the stopouts are reset
   */
  async resetStopouts(accountId, strategyId, reason) {
    if (this._isNotJwtToken()) {
      return this._handleNoAccessError('resetStopouts');
    }
    const opts = {
      url: `${this._host}/users/current/accounts/${accountId}/strategies-subscribed/${strategyId}/stopouts/${reason}` + '/reset',
      method: 'POST',
      headers: {
        'auth-token': this._token
      },
      json: true
    };
    return this._httpClient.request(opts);
  }

  /**
   * Trade copying user log record
   * @typedef {Object} CopyFactoryUserLogRecord
   * @property {Date} time log record time
   * @property {string} level log level. One of INFO, WARN, ERROR
   * @property {string} message log message
   * @property {string} [symbol] symbol traded
   * @property {string} [strategyId] id of the strategy event relates to
   * @property {string} [strategyName] name of the strategy event relates to
   * @property {string} [positionId] position id event relates to
   * @property {string} [side] side of the trade event relates to. One of buy, sell, close
   * @property {string} [type] type of the trade event relates to. One of market, limit, stop
   * @property {number} [openPrice] open price for limit and stop orders
   */

  /**
   * Returns copy trading user log for an account and time range. See
   * https://metaapi.cloud/docs/copyfactory/restApi/api/trading/getUserLog/
   * @param {string} accountId account id
   * @param {Date} [startTime] time to start loading data from
   * @param {Date} [endTime] time to stop loading data at
   * @param {number} [offset] pagination offset. Default is 0
   * @param {number} [limit] pagination limit. Default is 1000
   * @return {Promise<Array<CopyFactoryUserLogRecord>>} promise which resolves with log records found
   */
  async getUserLog(accountId, startTime, endTime, offset = 0, limit = 1000) {
    if (this._isNotJwtToken()) {
      return this._handleNoAccessError('getUserLog');
    }
    const opts = {
      url: `${this._host}/users/current/accounts/${accountId}/user-log`,
      method: 'GET',
      qs: {
        startTime,
        endTime,
        offset,
        limit
      },
      headers: {
        'auth-token': this._token
      },
      json: true
    };
    let result = await this._httpClient.request(opts);
    if (result) {
      result.map(r => r.time = new Date(r.time));
    }
    return result;
  }

}
exports.default = TradingClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL2NvcHlGYWN0b3J5L3RyYWRpbmcuY2xpZW50LmVzNiJdLCJuYW1lcyI6WyJUcmFkaW5nQ2xpZW50IiwiTWV0YUFwaUNsaWVudCIsImNvbnN0cnVjdG9yIiwiaHR0cENsaWVudCIsInRva2VuIiwiZG9tYWluIiwiX2hvc3QiLCJyZXN5bmNocm9uaXplIiwiYWNjb3VudElkIiwic3RyYXRlZ3lJZHMiLCJfaXNOb3RKd3RUb2tlbiIsIl9oYW5kbGVOb0FjY2Vzc0Vycm9yIiwib3B0cyIsInVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJfdG9rZW4iLCJxcyIsInN0cmF0ZWd5SWQiLCJqc29uIiwiX2h0dHBDbGllbnQiLCJyZXF1ZXN0IiwiZ2V0U3RvcG91dHMiLCJyZXNldFN0b3BvdXRzIiwicmVhc29uIiwiZ2V0VXNlckxvZyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJvZmZzZXQiLCJsaW1pdCIsInJlc3VsdCIsIm1hcCIsInIiLCJ0aW1lIiwiRGF0ZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7O0FBSWUsTUFBTUEsYUFBTixTQUE0QkMsaUJBQTVCLENBQTBDOztBQUV2RDs7Ozs7O0FBTUFDLGNBQVlDLFVBQVosRUFBd0JDLEtBQXhCLEVBQStCQyxTQUFTLDhCQUF4QyxFQUF3RTtBQUN0RSxVQUFNRixVQUFOLEVBQWtCQyxLQUFsQixFQUF5QkMsTUFBekI7QUFDQSxTQUFLQyxLQUFMLEdBQWMsMEJBQXlCRCxNQUFPLEVBQTlDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsUUFBTUUsYUFBTixDQUFvQkMsU0FBcEIsRUFBK0JDLFdBQS9CLEVBQTRDO0FBQzFDLFFBQUksS0FBS0MsY0FBTCxFQUFKLEVBQTJCO0FBQ3pCLGFBQU8sS0FBS0Msb0JBQUwsQ0FBMEIsZUFBMUIsQ0FBUDtBQUNEO0FBQ0QsVUFBTUMsT0FBTztBQUNYQyxXQUFNLEdBQUUsS0FBS1AsS0FBTSwyQkFBMEJFLFNBQVUsZ0JBRDVDO0FBRVhNLGNBQVEsTUFGRztBQUdYQyxlQUFTO0FBQ1Asc0JBQWMsS0FBS0M7QUFEWixPQUhFO0FBTVhDLFVBQUk7QUFDRkMsb0JBQVlUO0FBRFYsT0FOTztBQVNYVSxZQUFNO0FBVEssS0FBYjtBQVdBLFdBQU8sS0FBS0MsV0FBTCxDQUFpQkMsT0FBakIsQ0FBeUJULElBQXpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTs7Ozs7O0FBTUEsUUFBTVUsV0FBTixDQUFrQmQsU0FBbEIsRUFBNkI7QUFDM0IsUUFBSSxLQUFLRSxjQUFMLEVBQUosRUFBMkI7QUFDekIsYUFBTyxLQUFLQyxvQkFBTCxDQUEwQixhQUExQixDQUFQO0FBQ0Q7QUFDRCxVQUFNQyxPQUFPO0FBQ1hDLFdBQU0sR0FBRSxLQUFLUCxLQUFNLDJCQUEwQkUsU0FBVSxXQUQ1QztBQUVYTSxjQUFRLEtBRkc7QUFHWEMsZUFBUztBQUNQLHNCQUFjLEtBQUtDO0FBRFosT0FIRTtBQU1YRyxZQUFNO0FBTkssS0FBYjtBQVFBLFdBQU8sS0FBS0MsV0FBTCxDQUFpQkMsT0FBakIsQ0FBeUJULElBQXpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsUUFBTVcsYUFBTixDQUFvQmYsU0FBcEIsRUFBK0JVLFVBQS9CLEVBQTJDTSxNQUEzQyxFQUFtRDtBQUNqRCxRQUFJLEtBQUtkLGNBQUwsRUFBSixFQUEyQjtBQUN6QixhQUFPLEtBQUtDLG9CQUFMLENBQTBCLGVBQTFCLENBQVA7QUFDRDtBQUNELFVBQU1DLE9BQU87QUFDWEMsV0FBTSxHQUFFLEtBQUtQLEtBQU0sMkJBQTBCRSxTQUFVLDBCQUF5QlUsVUFBVyxhQUFZTSxNQUFPLEVBQXpHLEdBQ0gsUUFGUztBQUdYVixjQUFRLE1BSEc7QUFJWEMsZUFBUztBQUNQLHNCQUFjLEtBQUtDO0FBRFosT0FKRTtBQU9YRyxZQUFNO0FBUEssS0FBYjtBQVNBLFdBQU8sS0FBS0MsV0FBTCxDQUFpQkMsT0FBakIsQ0FBeUJULElBQXpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7QUFVQSxRQUFNYSxVQUFOLENBQWlCakIsU0FBakIsRUFBNEJrQixTQUE1QixFQUF1Q0MsT0FBdkMsRUFBZ0RDLFNBQVMsQ0FBekQsRUFBNERDLFFBQVEsSUFBcEUsRUFBMEU7QUFDeEUsUUFBSSxLQUFLbkIsY0FBTCxFQUFKLEVBQTJCO0FBQ3pCLGFBQU8sS0FBS0Msb0JBQUwsQ0FBMEIsWUFBMUIsQ0FBUDtBQUNEO0FBQ0QsVUFBTUMsT0FBTztBQUNYQyxXQUFNLEdBQUUsS0FBS1AsS0FBTSwyQkFBMEJFLFNBQVUsV0FENUM7QUFFWE0sY0FBUSxLQUZHO0FBR1hHLFVBQUk7QUFDRlMsaUJBREU7QUFFRkMsZUFGRTtBQUdGQyxjQUhFO0FBSUZDO0FBSkUsT0FITztBQVNYZCxlQUFTO0FBQ1Asc0JBQWMsS0FBS0M7QUFEWixPQVRFO0FBWVhHLFlBQU07QUFaSyxLQUFiO0FBY0EsUUFBSVcsU0FBUyxNQUFNLEtBQUtWLFdBQUwsQ0FBaUJDLE9BQWpCLENBQXlCVCxJQUF6QixDQUFuQjtBQUNBLFFBQUlrQixNQUFKLEVBQVk7QUFDVkEsYUFBT0MsR0FBUCxDQUFXQyxLQUFLQSxFQUFFQyxJQUFGLEdBQVMsSUFBSUMsSUFBSixDQUFTRixFQUFFQyxJQUFYLENBQXpCO0FBQ0Q7QUFDRCxXQUFPSCxNQUFQO0FBQ0Q7O0FBaEpzRDtrQkFBcEM5QixhIiwiZmlsZSI6InRyYWRpbmcuY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgTWV0YUFwaUNsaWVudCBmcm9tICcuLi9tZXRhQXBpLmNsaWVudCc7XG5pbXBvcnQgcmFuZG9tc3RyaW5nIGZyb20gJ3JhbmRvbXN0cmluZyc7XG5cbi8qKlxuICogbWV0YWFwaS5jbG91ZCBDb3B5RmFjdG9yeSB0cmFkaW5nIEFQSSAodHJhZGUgY29weWluZyB0cmFkaW5nIEFQSSkgY2xpZW50IChzZWVcbiAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NvcHlmYWN0b3J5LylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhZGluZ0NsaWVudCBleHRlbmRzIE1ldGFBcGlDbGllbnQge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIENvcHlGYWN0b3J5IHRyYWRpbmcgQVBJIGNsaWVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0h0dHBDbGllbnR9IGh0dHBDbGllbnQgSFRUUCBjbGllbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBkb21haW4gdG8gY29ubmVjdCB0bywgZGVmYXVsdCBpcyBhZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpXG4gICAqL1xuICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50LCB0b2tlbiwgZG9tYWluID0gJ2FnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknKSB7XG4gICAgc3VwZXIoaHR0cENsaWVudCwgdG9rZW4sIGRvbWFpbik7XG4gICAgdGhpcy5faG9zdCA9IGBodHRwczovL3RyYWRpbmctYXBpLXYxLiR7ZG9tYWlufWA7XG4gIH1cblxuICAvKipcbiAgICogUmVzeW5jaHJvbml6ZXMgdGhlIGFjY291bnQuIFNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jb3B5ZmFjdG9yeS9yZXN0QXBpL2FwaS90cmFkaW5nL3Jlc3luY2hyb25pemUvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHN0cmF0ZWd5SWRzIG9wdGlvbmFsIGFycmF5IG9mIHN0cmF0ZWd5IGlkcyB0byByZWN5bmNocm9uaXplLiBEZWZhdWx0IGlzIHRvIHN5bmNocm9uaXplIGFsbFxuICAgKiBzdHJhdGVnaWVzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiByZXN5bmNocm9uaXphdGlvbiBpcyBzY2hlZHVsZWRcbiAgICovXG4gIGFzeW5jIHJlc3luY2hyb25pemUoYWNjb3VudElkLCBzdHJhdGVneUlkcykge1xuICAgIGlmICh0aGlzLl9pc05vdEp3dFRva2VuKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVOb0FjY2Vzc0Vycm9yKCdyZXN5bmNocm9uaXplJyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB1cmw6IGAke3RoaXMuX2hvc3R9L3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvJHthY2NvdW50SWR9L3Jlc3luY2hyb25pemVgLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdGhpcy5fdG9rZW5cbiAgICAgIH0sXG4gICAgICBxczoge1xuICAgICAgICBzdHJhdGVneUlkOiBzdHJhdGVneUlkc1xuICAgICAgfSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9odHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ29weUZhY3Rvcnkgc3RyYXRlZ3kgc3RvcG91dFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDb3B5RmFjdG9yeVN0cmF0ZWd5U3RvcG91dFxuICAgKiBAcHJvcGVydHkge0NvcHlGYWN0b3J5U3RyYXRlZ3lJZEFuZE5hbWV9IHN0cmF0ZWd5IHN0cmF0ZWd5IHdoaWNoIHdhcyBzdG9wcGVkIG91dFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcmVhc29uIHN0b3BvdXQgcmVhc29uLiBPbmUgb2YgeWVhcmx5LWJhbGFuY2UsIG1vbnRobHktYmFsYW5jZSwgZGFpbHktYmFsYW5jZSwgeWVhcmx5LWVxdWl0eSxcbiAgICogbW9udGhseS1lcXVpdHksIGRhaWx5LWVxdWl0eSwgbWF4LWRyYXdkb3duXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZWFzb25EZXNjcmlwdGlvbiBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgc3RvcG91dCByZWFzb25cbiAgICogQHByb3BlcnR5IHtEYXRlfSBzdG9wcGVkQXQgdGltZSB0aGUgc3RyYXRlZ3kgd2FzIHN0b3BwZWQgYXRcbiAgICogQHByb3BlcnR5IHtEYXRlfSBzdG9wcGVkVGlsbCB0aW1lIHRoZSBzdHJhdGVneSBpcyBzdG9wcGVkIHRpbGxcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3Vic2NyaWJlciBhY2NvdW50IHN0b3BvdXRzLiBTZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY29weWZhY3RvcnkvcmVzdEFwaS9hcGkvdHJhZGluZy9nZXRTdG9wT3V0cy9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8Q29weUZhY3RvcnlTdHJhdGVneVN0b3BvdXQ+Pn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHN0b3BvdXRzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRTdG9wb3V0cyhhY2NvdW50SWQpIHtcbiAgICBpZiAodGhpcy5faXNOb3RKd3RUb2tlbigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlTm9BY2Nlc3NFcnJvcignZ2V0U3RvcG91dHMnKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHVybDogYCR7dGhpcy5faG9zdH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy8ke2FjY291bnRJZH0vc3RvcG91dHNgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9odHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHN0cmF0ZWd5IHN0b3BvdXRzLiBTZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY29weWZhY3RvcnkvcmVzdEFwaS9hcGkvdHJhZGluZy9yZXNldFN0b3BPdXRzL1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmF0ZWd5SWQgc3RyYXRlZ3kgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiBzdG9wb3V0IHJlYXNvbiB0byByZXNldC4gT25lIG9mIHllYXJseS1iYWxhbmNlLCBtb250aGx5LWJhbGFuY2UsIGRhaWx5LWJhbGFuY2UsXG4gICAqIHllYXJseS1lcXVpdHksIG1vbnRobHktZXF1aXR5LCBkYWlseS1lcXVpdHksIG1heC1kcmF3ZG93blxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIHN0b3BvdXRzIGFyZSByZXNldFxuICAgKi9cbiAgYXN5bmMgcmVzZXRTdG9wb3V0cyhhY2NvdW50SWQsIHN0cmF0ZWd5SWQsIHJlYXNvbikge1xuICAgIGlmICh0aGlzLl9pc05vdEp3dFRva2VuKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVOb0FjY2Vzc0Vycm9yKCdyZXNldFN0b3BvdXRzJyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICB1cmw6IGAke3RoaXMuX2hvc3R9L3VzZXJzL2N1cnJlbnQvYWNjb3VudHMvJHthY2NvdW50SWR9L3N0cmF0ZWdpZXMtc3Vic2NyaWJlZC8ke3N0cmF0ZWd5SWR9L3N0b3BvdXRzLyR7cmVhc29ufWAgK1xuICAgICAgICAnL3Jlc2V0JyxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRoaXMuX3Rva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFkZSBjb3B5aW5nIHVzZXIgbG9nIHJlY29yZFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDb3B5RmFjdG9yeVVzZXJMb2dSZWNvcmRcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIGxvZyByZWNvcmQgdGltZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGV2ZWwgbG9nIGxldmVsLiBPbmUgb2YgSU5GTywgV0FSTiwgRVJST1JcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgbG9nIG1lc3NhZ2VcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzeW1ib2xdIHN5bWJvbCB0cmFkZWRcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHJhdGVneUlkXSBpZCBvZiB0aGUgc3RyYXRlZ3kgZXZlbnQgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0cmF0ZWd5TmFtZV0gbmFtZSBvZiB0aGUgc3RyYXRlZ3kgZXZlbnQgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Bvc2l0aW9uSWRdIHBvc2l0aW9uIGlkIGV2ZW50IHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaWRlXSBzaWRlIG9mIHRoZSB0cmFkZSBldmVudCByZWxhdGVzIHRvLiBPbmUgb2YgYnV5LCBzZWxsLCBjbG9zZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdIHR5cGUgb2YgdGhlIHRyYWRlIGV2ZW50IHJlbGF0ZXMgdG8uIE9uZSBvZiBtYXJrZXQsIGxpbWl0LCBzdG9wXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BlblByaWNlXSBvcGVuIHByaWNlIGZvciBsaW1pdCBhbmQgc3RvcCBvcmRlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29weSB0cmFkaW5nIHVzZXIgbG9nIGZvciBhbiBhY2NvdW50IGFuZCB0aW1lIHJhbmdlLiBTZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY29weWZhY3RvcnkvcmVzdEFwaS9hcGkvdHJhZGluZy9nZXRVc2VyTG9nL1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtEYXRlfSBbc3RhcnRUaW1lXSB0aW1lIHRvIHN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2VuZFRpbWVdIHRpbWUgdG8gc3RvcCBsb2FkaW5nIGRhdGEgYXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRdIHBhZ2luYXRpb24gb2Zmc2V0LiBEZWZhdWx0IGlzIDBcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gcGFnaW5hdGlvbiBsaW1pdC4gRGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8Q29weUZhY3RvcnlVc2VyTG9nUmVjb3JkPj59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBsb2cgcmVjb3JkcyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckxvZyhhY2NvdW50SWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0ID0gMCwgbGltaXQgPSAxMDAwKSB7XG4gICAgaWYgKHRoaXMuX2lzTm90Snd0VG9rZW4oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU5vQWNjZXNzRXJyb3IoJ2dldFVzZXJMb2cnKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHVybDogYCR7dGhpcy5faG9zdH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy8ke2FjY291bnRJZH0vdXNlci1sb2dgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHFzOiB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsaW1pdFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLl9odHRwQ2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzdWx0Lm1hcChyID0+IHIudGltZSA9IG5ldyBEYXRlKHIudGltZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn1cbiJdfQ==