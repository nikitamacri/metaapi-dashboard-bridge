'use strict';

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _configuration = require('./configuration.client');

var _configuration2 = _interopRequireDefault(_configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const copyFactoryApiUrl = 'https://trading-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {ConfigurationClient}
 */
describe('ConfigurationClient', () => {

  let sandbox;
  let copyFactoryClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let requestStub;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    copyFactoryClient = new _configuration2.default(httpClient, token);
    requestStub = sandbox.stub(httpClient, 'request');
  });

  afterEach(() => {
    sandbox.restore();
  });

  /**
   * @test {MetatraderAccountClient#generateAccountId}
   */
  it('should generate account id', async () => {
    copyFactoryClient.generateAccountId().length.should.equal(64);
  });

  /**
   * @test {ConfigurationClient#updateAccount}
   */
  it('should update CopyFactory account via API', async () => {
    await copyFactoryClient.updateAccount('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', {
      name: 'Demo account',
      connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
      reservedMarginFraction: 0.25,
      subscriptions: [{
        strategyId: 'ABCD',
        multiplier: 1
      }]
    });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/accounts/` + '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        name: 'Demo account',
        connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
        reservedMarginFraction: 0.25,
        subscriptions: [{
          strategyId: 'ABCD',
          multiplier: 1
        }]
      }
    });
  });

  /**
   * @test {ConfigurationClient#updateAccount}
   */
  it('should not update CopyFactory account via API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.updateAccount('id', {});
    } catch (error) {
      error.message.should.equal('You can not invoke updateAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getAccounts}
   */
  it('should retrieve CopyFactory accounts from API', async () => {
    let expected = [{
      _id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      subscriberId: 'subscriberId',
      name: 'Demo account',
      connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
      reservedMarginFraction: 0.25,
      subscriptions: [{
        strategyId: 'ABCD',
        multiplier: 1
      }]
    }];
    requestStub.resolves(expected);
    let accounts = await copyFactoryClient.getAccounts();
    accounts.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/accounts`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getAccounts}
   */
  it('should not retrieve CopyFactory accounts from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getAccounts();
    } catch (error) {
      error.message.should.equal('You can not invoke getAccounts method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getAccount}
   */
  it('should retrieve CopyFactory account from API', async () => {
    let expected = {
      _id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      subscriberId: 'subscriberId',
      name: 'Demo account',
      connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
      reservedMarginFraction: 0.25,
      subscriptions: [{
        strategyId: 'ABCD',
        multiplier: 1
      }]
    };
    requestStub.resolves(expected);
    let accounts = await copyFactoryClient.getAccount('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef');
    accounts.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/accounts/` + '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getAccount}
   */
  it('should not retrieve CopyFactory account from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getAccount('test');
    } catch (error) {
      error.message.should.equal('You can not invoke getAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#removeAccount}
   */
  it('should remove CopyFactory account via API', async () => {
    await copyFactoryClient.removeAccount('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/accounts/` + '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#removeAccount}
   */
  it('should not remove CopyFactory account from via with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.removeAccount('id');
    } catch (error) {
      error.message.should.equal('You can not invoke removeAccount method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#generateStrategyId}
   */
  it('should generate strategy id', async () => {
    let expected = {
      id: 'ABCD'
    };
    requestStub.resolves(expected);
    let id = await copyFactoryClient.generateStrategyId();
    id.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/unused-strategy-id`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#generateStrategyId}
   */
  it('should not generate strategy id with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.generateStrategyId();
    } catch (error) {
      error.message.should.equal('You can not invoke generateStrategyId method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#updateStrategy}
   */
  it('should update strategy via API', async () => {
    await copyFactoryClient.updateStrategy('ABCD', {
      name: 'Test strategy',
      positionLifecycle: 'hedging',
      connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
      maxTradeRisk: 0.1,
      stopOutRisk: {
        value: 0.4,
        startTime: '2020-08-24T00:00:00.000Z'
      },
      timeSettings: {
        lifetimeInHours: 192,
        openingIntervalInMinutes: 5
      }
    });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/strategies/ABCD`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        name: 'Test strategy',
        positionLifecycle: 'hedging',
        connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
        maxTradeRisk: 0.1,
        stopOutRisk: {
          value: 0.4,
          startTime: '2020-08-24T00:00:00.000Z'
        },
        timeSettings: {
          lifetimeInHours: 192,
          openingIntervalInMinutes: 5
        }
      }
    });
  });

  /**
   * @test {ConfigurationClient#updateStrategy}
   */
  it('should not update strategy via API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.updateStrategy('ABCD', {});
    } catch (error) {
      error.message.should.equal('You can not invoke updateStrategy method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getStrategies}
   */
  it('should retrieve strategies from API', async () => {
    let expected = [{
      _id: 'ABCD',
      providerId: 'providerId',
      platformCommissionRate: 0.01,
      name: 'Test strategy',
      positionLifecycle: 'hedging',
      connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
      maxTradeRisk: 0.1,
      stopOutRisk: {
        value: 0.4,
        startTime: '2020-08-24T00:00:00.000Z'
      },
      timeSettings: {
        lifetimeInHours: 192,
        openingIntervalInMinutes: 5
      }
    }];
    requestStub.resolves(expected);
    let strategies = await copyFactoryClient.getStrategies();
    strategies.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/strategies`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getStrategies}
   */
  it('should not retrieve strategies from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getStrategies();
    } catch (error) {
      error.message.should.equal('You can not invoke getStrategies method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getStrategy}
   */
  it('should retrieve strategy from API', async () => {
    let expected = {
      _id: 'ABCD',
      providerId: 'providerId',
      platformCommissionRate: 0.01,
      name: 'Test strategy',
      positionLifecycle: 'hedging',
      connectionId: 'e8867baa-5ec2-45ae-9930-4d5cea18d0d6',
      maxTradeRisk: 0.1,
      stopOutRisk: {
        value: 0.4,
        startTime: '2020-08-24T00:00:00.000Z'
      },
      timeSettings: {
        lifetimeInHours: 192,
        openingIntervalInMinutes: 5
      }
    };
    requestStub.resolves(expected);
    let strategies = await copyFactoryClient.getStrategy('ABCD');
    strategies.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/strategies/ABCD`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getStrategy}
   */
  it('should not retrieve strategy from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getStrategy('ABCD');
    } catch (error) {
      error.message.should.equal('You can not invoke getStrategy method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#removeStrategy}
   */
  it('should remove strategy via API', async () => {
    await copyFactoryClient.removeStrategy('ABCD');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/strategies/ABCD`,
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#removeStrategy}
   */
  it('should not remove strategy from via with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.removeStrategy('ABCD');
    } catch (error) {
      error.message.should.equal('You can not invoke removeStrategy method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getPortfolioStrategies}
   */
  it('should retrieve portfolio strategies from API', async () => {
    let expected = [{
      _id: 'ABCD',
      providerId: 'providerId',
      platformCommissionRate: 0.01,
      name: 'Test strategy',
      members: [{
        strategyId: 'BCDE'
      }],
      maxTradeRisk: 0.1,
      stopOutRisk: {
        value: 0.4,
        startTime: '2020-08-24T00:00:00.000Z'
      }
    }];
    requestStub.resolves(expected);
    let strategies = await copyFactoryClient.getPortfolioStrategies();
    strategies.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/portfolio-strategies`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getPortfolioStrategies}
   */
  it('should not retrieve portfolio strategies from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getPortfolioStrategies();
    } catch (error) {
      error.message.should.equal('You can not invoke getPortfolioStrategies method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getPortfolioStrategy}
   */
  it('should retrieve portfolio strategy from API', async () => {
    let expected = {
      _id: 'ABCD',
      providerId: 'providerId',
      platformCommissionRate: 0.01,
      name: 'Test strategy',
      members: [{
        strategyId: 'BCDE'
      }],
      maxTradeRisk: 0.1,
      stopOutRisk: {
        value: 0.4,
        startTime: '2020-08-24T00:00:00.000Z'
      }
    };
    requestStub.resolves(expected);
    let strategies = await copyFactoryClient.getPortfolioStrategy('ABCD');
    strategies.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/portfolio-strategies/ABCD`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getPortfolioStrategy}
   */
  it('should not retrieve portfolio strategy from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getPortfolioStrategy('ABCD');
    } catch (error) {
      error.message.should.equal('You can not invoke getPortfolioStrategy method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#updatePortfolioStrategy}
   */
  it('should update portfolio strategy via API', async () => {
    await copyFactoryClient.updatePortfolioStrategy('ABCD', {
      name: 'Test strategy',
      members: [{
        strategyId: 'BCDE'
      }],
      maxTradeRisk: 0.1,
      stopOutRisk: {
        value: 0.4,
        startTime: '2020-08-24T00:00:00.000Z'
      }
    });
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/portfolio-strategies/ABCD`,
      method: 'PUT',
      headers: {
        'auth-token': token
      },
      json: true,
      body: {
        name: 'Test strategy',
        members: [{
          strategyId: 'BCDE'
        }],
        maxTradeRisk: 0.1,
        stopOutRisk: {
          value: 0.4,
          startTime: '2020-08-24T00:00:00.000Z'
        }
      }
    });
  });

  /**
   * @test {ConfigurationClient#updatePortfolioStrategy}
   */
  it('should not update portfolio strategy via API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.updatePortfolioStrategy('ABCD', {});
    } catch (error) {
      error.message.should.equal('You can not invoke updatePortfolioStrategy method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#removePortfolioStrategy}
   */
  it('should remove portfolio strategy via API', async () => {
    await copyFactoryClient.removePortfolioStrategy('ABCD');
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/portfolio-strategies/ABCD`,
      method: 'DELETE',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#removePortfolioStrategy}
   */
  it('should not remove portfolio strategy from via with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.removePortfolioStrategy('ABCD');
    } catch (error) {
      error.message.should.equal('You can not invoke removePortfolioStrategy method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {ConfigurationClient#getActiveResynchronizationTasks}
   */
  it('should retrieve active resynchronization tasks via API', async () => {
    let expected = [{
      _id: 'ABCD',
      type: 'CREATE_STRATEGY',
      createdAt: '2020-08-25T00:00:00.000Z',
      status: 'EXECUTING'
    }];
    requestStub.resolves(expected);
    let tasks = await copyFactoryClient.getActiveResynchronizationTasks('accountId');
    tasks.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/configuration/connections/` + 'accountId/active-resynchronization-tasks',
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {ConfigurationClient#getActiveResynchronizationTasks}
   */
  it('should not retrieve active resynchronization tasks from API with account token', async () => {
    copyFactoryClient = new _configuration2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getActiveResynchronizationTasks('accountId');
    } catch (error) {
      error.message.should.equal('You can not invoke getActiveResynchronizationTasks method, because you have connected with account ' + 'access token. Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  describe('ConfigurationClient.waitResynchronizationTasksCompleted', () => {

    /**
     * @test {ConfigurationClient#waitResynchronizationTasksCompleted}
     */
    it('should wait until active resynchronization tasks are completed', async () => {
      let activeTasks = [{
        _id: 'ABCD',
        type: 'CREATE_STRATEGY',
        createdAt: '2020-08-25T00:00:00.000Z',
        status: 'EXECUTING'
      }];
      requestStub.onFirstCall().resolves(activeTasks).onSecondCall().resolves(activeTasks).onThirdCall().resolves([]);

      await copyFactoryClient.waitResynchronizationTasksCompleted('accountId', 1, 50);
      _sinon2.default.assert.calledWith(httpClient.request, {
        url: `${copyFactoryApiUrl}/users/current/configuration/connections/` + 'accountId/active-resynchronization-tasks',
        method: 'GET',
        headers: {
          'auth-token': token
        },
        json: true
      });
      _sinon2.default.assert.calledThrice(httpClient.request);
    });

    /**
     * @test {ConfigurationClient#waitResynchronizationTasksCompleted}
     */
    it('should time out waiting for active resynchronization tasks are completed', async () => {
      let activeTasks = [{
        _id: 'ABCD',
        type: 'CREATE_STRATEGY',
        createdAt: '2020-08-25T00:00:00.000Z',
        status: 'EXECUTING'
      }];
      requestStub.resolves(activeTasks);
      try {
        await copyFactoryClient.waitResynchronizationTasksCompleted('accountId', 1, 50);
        throw new Error('TimeoutError is expected');
      } catch (err) {
        err.name.should.equal('TimeoutError');
      }
      _sinon2.default.assert.calledWith(httpClient.request, {
        url: `${copyFactoryApiUrl}/users/current/configuration/connections/` + 'accountId/active-resynchronization-tasks',
        method: 'GET',
        headers: {
          'auth-token': token
        },
        json: true
      });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL2NvcHlGYWN0b3J5L2NvbmZpZ3VyYXRpb24uY2xpZW50LnNwZWMuZXM2Il0sIm5hbWVzIjpbImNvcHlGYWN0b3J5QXBpVXJsIiwiZGVzY3JpYmUiLCJzYW5kYm94IiwiY29weUZhY3RvcnlDbGllbnQiLCJ0b2tlbiIsImh0dHBDbGllbnQiLCJIdHRwQ2xpZW50IiwicmVxdWVzdFN0dWIiLCJiZWZvcmUiLCJzaW5vbiIsImNyZWF0ZVNhbmRib3giLCJiZWZvcmVFYWNoIiwiQ29uZmlndXJhdGlvbkNsaWVudCIsInN0dWIiLCJhZnRlckVhY2giLCJyZXN0b3JlIiwiaXQiLCJnZW5lcmF0ZUFjY291bnRJZCIsImxlbmd0aCIsInNob3VsZCIsImVxdWFsIiwidXBkYXRlQWNjb3VudCIsIm5hbWUiLCJjb25uZWN0aW9uSWQiLCJyZXNlcnZlZE1hcmdpbkZyYWN0aW9uIiwic3Vic2NyaXB0aW9ucyIsInN0cmF0ZWd5SWQiLCJtdWx0aXBsaWVyIiwiYXNzZXJ0IiwiY2FsbGVkT25jZVdpdGhFeGFjdGx5IiwicmVxdWVzdCIsInVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJqc29uIiwiYm9keSIsImVycm9yIiwibWVzc2FnZSIsImV4cGVjdGVkIiwiX2lkIiwic3Vic2NyaWJlcklkIiwicmVzb2x2ZXMiLCJhY2NvdW50cyIsImdldEFjY291bnRzIiwiZ2V0QWNjb3VudCIsInJlbW92ZUFjY291bnQiLCJpZCIsImdlbmVyYXRlU3RyYXRlZ3lJZCIsInVwZGF0ZVN0cmF0ZWd5IiwicG9zaXRpb25MaWZlY3ljbGUiLCJtYXhUcmFkZVJpc2siLCJzdG9wT3V0UmlzayIsInZhbHVlIiwic3RhcnRUaW1lIiwidGltZVNldHRpbmdzIiwibGlmZXRpbWVJbkhvdXJzIiwib3BlbmluZ0ludGVydmFsSW5NaW51dGVzIiwicHJvdmlkZXJJZCIsInBsYXRmb3JtQ29tbWlzc2lvblJhdGUiLCJzdHJhdGVnaWVzIiwiZ2V0U3RyYXRlZ2llcyIsImdldFN0cmF0ZWd5IiwicmVtb3ZlU3RyYXRlZ3kiLCJtZW1iZXJzIiwiZ2V0UG9ydGZvbGlvU3RyYXRlZ2llcyIsImdldFBvcnRmb2xpb1N0cmF0ZWd5IiwidXBkYXRlUG9ydGZvbGlvU3RyYXRlZ3kiLCJyZW1vdmVQb3J0Zm9saW9TdHJhdGVneSIsInR5cGUiLCJjcmVhdGVkQXQiLCJzdGF0dXMiLCJ0YXNrcyIsImdldEFjdGl2ZVJlc3luY2hyb25pemF0aW9uVGFza3MiLCJhY3RpdmVUYXNrcyIsIm9uRmlyc3RDYWxsIiwib25TZWNvbmRDYWxsIiwib25UaGlyZENhbGwiLCJ3YWl0UmVzeW5jaHJvbml6YXRpb25UYXNrc0NvbXBsZXRlZCIsImNhbGxlZFdpdGgiLCJjYWxsZWRUaHJpY2UiLCJFcnJvciIsImVyciJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLG9CQUFvQixxREFBMUI7O0FBRUE7OztBQUdBQyxTQUFTLHFCQUFULEVBQWdDLE1BQU07O0FBRXBDLE1BQUlDLE9BQUo7QUFDQSxNQUFJQyxpQkFBSjtBQUNBLFFBQU1DLFFBQVEscUJBQWQ7QUFDQSxNQUFJQyxhQUFhLElBQUlDLG9CQUFKLEVBQWpCO0FBQ0EsTUFBSUMsV0FBSjs7QUFFQUMsU0FBTyxNQUFNO0FBQ1hOLGNBQVVPLGdCQUFNQyxhQUFOLEVBQVY7QUFDRCxHQUZEOztBQUlBQyxhQUFXLE1BQU07QUFDZlIsd0JBQW9CLElBQUlTLHVCQUFKLENBQXdCUCxVQUF4QixFQUFvQ0QsS0FBcEMsQ0FBcEI7QUFDQUcsa0JBQWNMLFFBQVFXLElBQVIsQ0FBYVIsVUFBYixFQUF5QixTQUF6QixDQUFkO0FBQ0QsR0FIRDs7QUFLQVMsWUFBVSxNQUFNO0FBQ2RaLFlBQVFhLE9BQVI7QUFDRCxHQUZEOztBQUlBOzs7QUFHQUMsS0FBRyw0QkFBSCxFQUFpQyxZQUFZO0FBQzNDYixzQkFBa0JjLGlCQUFsQixHQUFzQ0MsTUFBdEMsQ0FBNkNDLE1BQTdDLENBQW9EQyxLQUFwRCxD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QixpQkFBa0IsMkNBQXJCLEdBQ0QsMENBRnNDO0FBRzFDZ0MsZ0JBQVEsS0FIa0M7QUFJMUNDLGlCQUFTO0FBQ1Asd0JBQWM3QjtBQURQLFNBSmlDO0FBTzFDOEIsY0FBTTtBQVBvQyxPQUE1QztBQVNBekIsc0JBQU1tQixNQUFOLENBQWFtRCxZQUFiLENBQTBCMUUsV0FBV3lCLE9BQXJDO0FBQ0QsS0F2QkQ7O0FBeUJBOzs7QUFHQWQsT0FBRywwRUFBSCxFQUErRSxZQUFZO0FBQ3pGLFVBQUl5RCxjQUFjLENBQUM7QUFDakJsQyxhQUFLLE1BRFk7QUFFakI2QixjQUFNLGlCQUZXO0FBR2pCQyxtQkFBVywwQkFITTtBQUlqQkMsZ0JBQVE7QUFKUyxPQUFELENBQWxCO0FBTUEvRCxrQkFBWWtDLFFBQVosQ0FBcUJnQyxXQUFyQjtBQUNBLFVBQUk7QUFDRixjQUFNdEUsa0JBQWtCMEUsbUNBQWxCLENBQXNELFdBQXRELEVBQW1FLENBQW5FLEVBQXNFLEVBQXRFLENBQU47QUFDQSxjQUFNLElBQUlHLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0QsT0FIRCxDQUdFLE9BQU9DLEdBQVAsRUFBWTtBQUNaQSxZQUFJM0QsSUFBSixDQUFTSCxNQUFULENBQWdCQyxLQUFoQixDQUFzQixjQUF0QjtBQUNEO0FBQ0RYLHNCQUFNbUIsTUFBTixDQUFha0QsVUFBYixDQUF3QnpFLFdBQVd5QixPQUFuQyxFQUE0QztBQUMxQ0MsYUFBTSxHQUFFL0IsaUJBQWtCLDJDQUFyQixHQUNELDBDQUZzQztBQUcxQ2dDLGdCQUFRLEtBSGtDO0FBSTFDQyxpQkFBUztBQUNQLHdCQUFjN0I7QUFEUCxTQUppQztBQU8xQzhCLGNBQU07QUFQb0MsT0FBNUM7QUFTRCxLQXZCRDtBQXlCRCxHQTFERDtBQTRERCxDQS9yQkQiLCJmaWxlIjoiY29uZmlndXJhdGlvbi5jbGllbnQuc3BlYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHNob3VsZCBmcm9tICdzaG91bGQnO1xuaW1wb3J0IHNpbm9uIGZyb20gJ3Npbm9uJztcbmltcG9ydCBIdHRwQ2xpZW50IGZyb20gJy4uL2h0dHBDbGllbnQnO1xuaW1wb3J0IENvbmZpZ3VyYXRpb25DbGllbnQgZnJvbSAnLi9jb25maWd1cmF0aW9uLmNsaWVudCc7XG5cbmNvbnN0IGNvcHlGYWN0b3J5QXBpVXJsID0gJ2h0dHBzOi8vdHJhZGluZy1hcGktdjEuYWdpbGl1bXRyYWRlLmFnaWxpdW10cmFkZS5haSc7XG5cbi8qKlxuICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnR9XG4gKi9cbmRlc2NyaWJlKCdDb25maWd1cmF0aW9uQ2xpZW50JywgKCkgPT4ge1xuXG4gIGxldCBzYW5kYm94O1xuICBsZXQgY29weUZhY3RvcnlDbGllbnQ7XG4gIGNvbnN0IHRva2VuID0gJ2hlYWRlci5wYXlsb2FkLnNpZ24nO1xuICBsZXQgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KCk7XG4gIGxldCByZXF1ZXN0U3R1YjtcblxuICBiZWZvcmUoKCkgPT4ge1xuICAgIHNhbmRib3ggPSBzaW5vbi5jcmVhdGVTYW5kYm94KCk7XG4gIH0pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IENvbmZpZ3VyYXRpb25DbGllbnQoaHR0cENsaWVudCwgdG9rZW4pO1xuICAgIHJlcXVlc3RTdHViID0gc2FuZGJveC5zdHViKGh0dHBDbGllbnQsICdyZXF1ZXN0Jyk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YXRyYWRlckFjY291bnRDbGllbnQjZ2VuZXJhdGVBY2NvdW50SWR9XG4gICAqL1xuICBpdCgnc2hvdWxkIGdlbmVyYXRlIGFjY291bnQgaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQuZ2VuZXJhdGVBY2NvdW50SWQoKS5sZW5ndGguc2hvdWxkLmVxdWFsKDY0KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I3VwZGF0ZUFjY291bnR9XG4gICAqL1xuICBpdCgnc2hvdWxkIHVwZGF0ZSBDb3B5RmFjdG9yeSBhY2NvdW50IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQudXBkYXRlQWNjb3VudCgnMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZicsIHtcbiAgICAgIG5hbWU6ICdEZW1vIGFjY291bnQnLFxuICAgICAgY29ubmVjdGlvbklkOiAnZTg4NjdiYWEtNWVjMi00NWFlLTk5MzAtNGQ1Y2VhMThkMGQ2JyxcbiAgICAgIHJlc2VydmVkTWFyZ2luRnJhY3Rpb246IDAuMjUsXG4gICAgICBzdWJzY3JpcHRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzdHJhdGVneUlkOiAnQUJDRCcsXG4gICAgICAgICAgbXVsdGlwbGllcjogMVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9hY2NvdW50cy9gICtcbiAgICAgICAgICAgICAgJzAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYnLFxuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWU6ICdEZW1vIGFjY291bnQnLFxuICAgICAgICBjb25uZWN0aW9uSWQ6ICdlODg2N2JhYS01ZWMyLTQ1YWUtOTkzMC00ZDVjZWExOGQwZDYnLFxuICAgICAgICByZXNlcnZlZE1hcmdpbkZyYWN0aW9uOiAwLjI1LFxuICAgICAgICBzdWJzY3JpcHRpb25zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RyYXRlZ3lJZDogJ0FCQ0QnLFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjdXBkYXRlQWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVwZGF0ZSBDb3B5RmFjdG9yeSBhY2NvdW50IHZpYSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IENvbmZpZ3VyYXRpb25DbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LnVwZGF0ZUFjY291bnQoJ2lkJywge30pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSB1cGRhdGVBY2NvdW50IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0QWNjb3VudHN9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIENvcHlGYWN0b3J5IGFjY291bnRzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBfaWQ6ICcwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgICAgIHN1YnNjcmliZXJJZDogJ3N1YnNjcmliZXJJZCcsXG4gICAgICBuYW1lOiAnRGVtbyBhY2NvdW50JyxcbiAgICAgIGNvbm5lY3Rpb25JZDogJ2U4ODY3YmFhLTVlYzItNDVhZS05OTMwLTRkNWNlYTE4ZDBkNicsXG4gICAgICByZXNlcnZlZE1hcmdpbkZyYWN0aW9uOiAwLjI1LFxuICAgICAgc3Vic2NyaXB0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgc3RyYXRlZ3lJZDogJ0FCQ0QnLFxuICAgICAgICAgIG11bHRpcGxpZXI6IDFcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1dO1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgYWNjb3VudHMgPSBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5nZXRBY2NvdW50cygpO1xuICAgIGFjY291bnRzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9hY2NvdW50c2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I2dldEFjY291bnRzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmV0cmlldmUgQ29weUZhY3RvcnkgYWNjb3VudHMgZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IENvbmZpZ3VyYXRpb25DbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldEFjY291bnRzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldEFjY291bnRzIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0QWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgQ29weUZhY3RvcnkgYWNjb3VudCBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSB7XG4gICAgICBfaWQ6ICcwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgICAgIHN1YnNjcmliZXJJZDogJ3N1YnNjcmliZXJJZCcsXG4gICAgICBuYW1lOiAnRGVtbyBhY2NvdW50JyxcbiAgICAgIGNvbm5lY3Rpb25JZDogJ2U4ODY3YmFhLTVlYzItNDVhZS05OTMwLTRkNWNlYTE4ZDBkNicsXG4gICAgICByZXNlcnZlZE1hcmdpbkZyYWN0aW9uOiAwLjI1LFxuICAgICAgc3Vic2NyaXB0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgc3RyYXRlZ3lJZDogJ0FCQ0QnLFxuICAgICAgICAgIG11bHRpcGxpZXI6IDFcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBhY2NvdW50cyA9IGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50XG4gICAgICAuZ2V0QWNjb3VudCgnMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZicpO1xuICAgIGFjY291bnRzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9hY2NvdW50cy9gICtcbiAgICAgICAgICAgICAgJzAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYnLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNnZXRBY2NvdW50fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmV0cmlldmUgQ29weUZhY3RvcnkgYWNjb3VudCBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0QWNjb3VudCgndGVzdCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZXRBY2NvdW50IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjcmVtb3ZlQWNjb3VudH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVtb3ZlIENvcHlGYWN0b3J5IGFjY291bnQgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5yZW1vdmVBY2NvdW50KCcwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmJyk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9hY2NvdW50cy9gICtcbiAgICAgICAgICAgICAgJzAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYnLFxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNyZW1vdmVBY2NvdW50fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmVtb3ZlIENvcHlGYWN0b3J5IGFjY291bnQgZnJvbSB2aWEgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IENvbmZpZ3VyYXRpb25DbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LnJlbW92ZUFjY291bnQoJ2lkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIHJlbW92ZUFjY291bnQgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNnZW5lcmF0ZVN0cmF0ZWd5SWR9XG4gICAqL1xuICBpdCgnc2hvdWxkIGdlbmVyYXRlIHN0cmF0ZWd5IGlkJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IHtcbiAgICAgIGlkOiAnQUJDRCdcbiAgICB9O1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgaWQgPSBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5nZW5lcmF0ZVN0cmF0ZWd5SWQoKTtcbiAgICBpZC5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L2NvbmZpZ3VyYXRpb24vdW51c2VkLXN0cmF0ZWd5LWlkYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2VuZXJhdGVTdHJhdGVneUlkfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgZ2VuZXJhdGUgc3RyYXRlZ3kgaWQgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IENvbmZpZ3VyYXRpb25DbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdlbmVyYXRlU3RyYXRlZ3lJZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZW5lcmF0ZVN0cmF0ZWd5SWQgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCN1cGRhdGVTdHJhdGVneX1cbiAgICovXG4gIGl0KCdzaG91bGQgdXBkYXRlIHN0cmF0ZWd5IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQudXBkYXRlU3RyYXRlZ3koJ0FCQ0QnLCB7XG4gICAgICBuYW1lOiAnVGVzdCBzdHJhdGVneScsXG4gICAgICBwb3NpdGlvbkxpZmVjeWNsZTogJ2hlZGdpbmcnLFxuICAgICAgY29ubmVjdGlvbklkOiAnZTg4NjdiYWEtNWVjMi00NWFlLTk5MzAtNGQ1Y2VhMThkMGQ2JyxcbiAgICAgIG1heFRyYWRlUmlzazogMC4xLFxuICAgICAgc3RvcE91dFJpc2s6IHtcbiAgICAgICAgdmFsdWU6IDAuNCxcbiAgICAgICAgc3RhcnRUaW1lOiAnMjAyMC0wOC0yNFQwMDowMDowMC4wMDBaJ1xuICAgICAgfSxcbiAgICAgIHRpbWVTZXR0aW5nczoge1xuICAgICAgICBsaWZldGltZUluSG91cnM6IDE5MixcbiAgICAgICAgb3BlbmluZ0ludGVydmFsSW5NaW51dGVzOiA1XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9zdHJhdGVnaWVzL0FCQ0RgLFxuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG5hbWU6ICdUZXN0IHN0cmF0ZWd5JyxcbiAgICAgICAgcG9zaXRpb25MaWZlY3ljbGU6ICdoZWRnaW5nJyxcbiAgICAgICAgY29ubmVjdGlvbklkOiAnZTg4NjdiYWEtNWVjMi00NWFlLTk5MzAtNGQ1Y2VhMThkMGQ2JyxcbiAgICAgICAgbWF4VHJhZGVSaXNrOiAwLjEsXG4gICAgICAgIHN0b3BPdXRSaXNrOiB7XG4gICAgICAgICAgdmFsdWU6IDAuNCxcbiAgICAgICAgICBzdGFydFRpbWU6ICcyMDIwLTA4LTI0VDAwOjAwOjAwLjAwMFonXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVTZXR0aW5nczoge1xuICAgICAgICAgIGxpZmV0aW1lSW5Ib3VyczogMTkyLFxuICAgICAgICAgIG9wZW5pbmdJbnRlcnZhbEluTWludXRlczogNVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCN1cGRhdGVTdHJhdGVneX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVwZGF0ZSBzdHJhdGVneSB2aWEgQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBjb3B5RmFjdG9yeUNsaWVudCA9IG5ldyBDb25maWd1cmF0aW9uQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC51cGRhdGVTdHJhdGVneSgnQUJDRCcsIHt9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgdXBkYXRlU3RyYXRlZ3kgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNnZXRTdHJhdGVnaWVzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBzdHJhdGVnaWVzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBfaWQ6ICdBQkNEJyxcbiAgICAgIHByb3ZpZGVySWQ6ICdwcm92aWRlcklkJyxcbiAgICAgIHBsYXRmb3JtQ29tbWlzc2lvblJhdGU6IDAuMDEsXG4gICAgICBuYW1lOiAnVGVzdCBzdHJhdGVneScsXG4gICAgICBwb3NpdGlvbkxpZmVjeWNsZTogJ2hlZGdpbmcnLFxuICAgICAgY29ubmVjdGlvbklkOiAnZTg4NjdiYWEtNWVjMi00NWFlLTk5MzAtNGQ1Y2VhMThkMGQ2JyxcbiAgICAgIG1heFRyYWRlUmlzazogMC4xLFxuICAgICAgc3RvcE91dFJpc2s6IHtcbiAgICAgICAgdmFsdWU6IDAuNCxcbiAgICAgICAgc3RhcnRUaW1lOiAnMjAyMC0wOC0yNFQwMDowMDowMC4wMDBaJ1xuICAgICAgfSxcbiAgICAgIHRpbWVTZXR0aW5nczoge1xuICAgICAgICBsaWZldGltZUluSG91cnM6IDE5MixcbiAgICAgICAgb3BlbmluZ0ludGVydmFsSW5NaW51dGVzOiA1XG4gICAgICB9XG4gICAgfV07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBzdHJhdGVnaWVzID0gYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0U3RyYXRlZ2llcygpO1xuICAgIHN0cmF0ZWdpZXMuc2hvdWxkLmVxdWFsKGV4cGVjdGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtjb3B5RmFjdG9yeUFwaVVybH0vdXNlcnMvY3VycmVudC9jb25maWd1cmF0aW9uL3N0cmF0ZWdpZXNgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNnZXRTdHJhdGVnaWVzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmV0cmlldmUgc3RyYXRlZ2llcyBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0U3RyYXRlZ2llcygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZXRTdHJhdGVnaWVzIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0U3RyYXRlZ3l9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHN0cmF0ZWd5IGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IHtcbiAgICAgIF9pZDogJ0FCQ0QnLFxuICAgICAgcHJvdmlkZXJJZDogJ3Byb3ZpZGVySWQnLFxuICAgICAgcGxhdGZvcm1Db21taXNzaW9uUmF0ZTogMC4wMSxcbiAgICAgIG5hbWU6ICdUZXN0IHN0cmF0ZWd5JyxcbiAgICAgIHBvc2l0aW9uTGlmZWN5Y2xlOiAnaGVkZ2luZycsXG4gICAgICBjb25uZWN0aW9uSWQ6ICdlODg2N2JhYS01ZWMyLTQ1YWUtOTkzMC00ZDVjZWExOGQwZDYnLFxuICAgICAgbWF4VHJhZGVSaXNrOiAwLjEsXG4gICAgICBzdG9wT3V0Umlzazoge1xuICAgICAgICB2YWx1ZTogMC40LFxuICAgICAgICBzdGFydFRpbWU6ICcyMDIwLTA4LTI0VDAwOjAwOjAwLjAwMFonXG4gICAgICB9LFxuICAgICAgdGltZVNldHRpbmdzOiB7XG4gICAgICAgIGxpZmV0aW1lSW5Ib3VyczogMTkyLFxuICAgICAgICBvcGVuaW5nSW50ZXJ2YWxJbk1pbnV0ZXM6IDVcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgc3RyYXRlZ2llcyA9IGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFN0cmF0ZWd5KCdBQkNEJyk7XG4gICAgc3RyYXRlZ2llcy5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L2NvbmZpZ3VyYXRpb24vc3RyYXRlZ2llcy9BQkNEYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0U3RyYXRlZ3l9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBzdHJhdGVneSBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0U3RyYXRlZ3koJ0FCQ0QnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgZ2V0U3RyYXRlZ3kgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNyZW1vdmVTdHJhdGVneX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVtb3ZlIHN0cmF0ZWd5IHZpYSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQucmVtb3ZlU3RyYXRlZ3koJ0FCQ0QnKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtjb3B5RmFjdG9yeUFwaVVybH0vdXNlcnMvY3VycmVudC9jb25maWd1cmF0aW9uL3N0cmF0ZWdpZXMvQUJDRGAsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I3JlbW92ZVN0cmF0ZWd5fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmVtb3ZlIHN0cmF0ZWd5IGZyb20gdmlhIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBjb3B5RmFjdG9yeUNsaWVudCA9IG5ldyBDb25maWd1cmF0aW9uQ2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5yZW1vdmVTdHJhdGVneSgnQUJDRCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSByZW1vdmVTdHJhdGVneSBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I2dldFBvcnRmb2xpb1N0cmF0ZWdpZXN9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHBvcnRmb2xpbyBzdHJhdGVnaWVzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBfaWQ6ICdBQkNEJyxcbiAgICAgIHByb3ZpZGVySWQ6ICdwcm92aWRlcklkJyxcbiAgICAgIHBsYXRmb3JtQ29tbWlzc2lvblJhdGU6IDAuMDEsXG4gICAgICBuYW1lOiAnVGVzdCBzdHJhdGVneScsXG4gICAgICBtZW1iZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzdHJhdGVneUlkOiAnQkNERSdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1heFRyYWRlUmlzazogMC4xLFxuICAgICAgc3RvcE91dFJpc2s6IHtcbiAgICAgICAgdmFsdWU6IDAuNCxcbiAgICAgICAgc3RhcnRUaW1lOiAnMjAyMC0wOC0yNFQwMDowMDowMC4wMDBaJ1xuICAgICAgfVxuICAgIH1dO1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgc3RyYXRlZ2llcyA9IGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFBvcnRmb2xpb1N0cmF0ZWdpZXMoKTtcbiAgICBzdHJhdGVnaWVzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9wb3J0Zm9saW8tc3RyYXRlZ2llc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I2dldFBvcnRmb2xpb1N0cmF0ZWdpZXN9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBwb3J0Zm9saW8gc3RyYXRlZ2llcyBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0UG9ydGZvbGlvU3RyYXRlZ2llcygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZXRQb3J0Zm9saW9TdHJhdGVnaWVzIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0UG9ydGZvbGlvU3RyYXRlZ3l9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHBvcnRmb2xpbyBzdHJhdGVneSBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSB7XG4gICAgICBfaWQ6ICdBQkNEJyxcbiAgICAgIHByb3ZpZGVySWQ6ICdwcm92aWRlcklkJyxcbiAgICAgIHBsYXRmb3JtQ29tbWlzc2lvblJhdGU6IDAuMDEsXG4gICAgICBuYW1lOiAnVGVzdCBzdHJhdGVneScsXG4gICAgICBtZW1iZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzdHJhdGVneUlkOiAnQkNERSdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1heFRyYWRlUmlzazogMC4xLFxuICAgICAgc3RvcE91dFJpc2s6IHtcbiAgICAgICAgdmFsdWU6IDAuNCxcbiAgICAgICAgc3RhcnRUaW1lOiAnMjAyMC0wOC0yNFQwMDowMDowMC4wMDBaJ1xuICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBzdHJhdGVnaWVzID0gYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0UG9ydGZvbGlvU3RyYXRlZ3koJ0FCQ0QnKTtcbiAgICBzdHJhdGVnaWVzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9wb3J0Zm9saW8tc3RyYXRlZ2llcy9BQkNEYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0UG9ydGZvbGlvU3RyYXRlZ3l9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBwb3J0Zm9saW8gc3RyYXRlZ3kgZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IENvbmZpZ3VyYXRpb25DbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFBvcnRmb2xpb1N0cmF0ZWd5KCdBQkNEJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldFBvcnRmb2xpb1N0cmF0ZWd5IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjdXBkYXRlUG9ydGZvbGlvU3RyYXRlZ3l9XG4gICAqL1xuICBpdCgnc2hvdWxkIHVwZGF0ZSBwb3J0Zm9saW8gc3RyYXRlZ3kgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC51cGRhdGVQb3J0Zm9saW9TdHJhdGVneSgnQUJDRCcsIHtcbiAgICAgIG5hbWU6ICdUZXN0IHN0cmF0ZWd5JyxcbiAgICAgIG1lbWJlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHN0cmF0ZWd5SWQ6ICdCQ0RFJ1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgbWF4VHJhZGVSaXNrOiAwLjEsXG4gICAgICBzdG9wT3V0Umlzazoge1xuICAgICAgICB2YWx1ZTogMC40LFxuICAgICAgICBzdGFydFRpbWU6ICcyMDIwLTA4LTI0VDAwOjAwOjAwLjAwMFonXG4gICAgICB9XG4gICAgfSk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9wb3J0Zm9saW8tc3RyYXRlZ2llcy9BQkNEYCxcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgYm9keToge1xuICAgICAgICBuYW1lOiAnVGVzdCBzdHJhdGVneScsXG4gICAgICAgIG1lbWJlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHJhdGVneUlkOiAnQkNERSdcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIG1heFRyYWRlUmlzazogMC4xLFxuICAgICAgICBzdG9wT3V0Umlzazoge1xuICAgICAgICAgIHZhbHVlOiAwLjQsXG4gICAgICAgICAgc3RhcnRUaW1lOiAnMjAyMC0wOC0yNFQwMDowMDowMC4wMDBaJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCN1cGRhdGVQb3J0Zm9saW9TdHJhdGVneX1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHVwZGF0ZSBwb3J0Zm9saW8gc3RyYXRlZ3kgdmlhIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQudXBkYXRlUG9ydGZvbGlvU3RyYXRlZ3koJ0FCQ0QnLCB7fSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIHVwZGF0ZVBvcnRmb2xpb1N0cmF0ZWd5IG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjcmVtb3ZlUG9ydGZvbGlvU3RyYXRlZ3l9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJlbW92ZSBwb3J0Zm9saW8gc3RyYXRlZ3kgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5yZW1vdmVQb3J0Zm9saW9TdHJhdGVneSgnQUJDRCcpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L2NvbmZpZ3VyYXRpb24vcG9ydGZvbGlvLXN0cmF0ZWdpZXMvQUJDRGAsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I3JlbW92ZVBvcnRmb2xpb1N0cmF0ZWd5fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBub3QgcmVtb3ZlIHBvcnRmb2xpbyBzdHJhdGVneSBmcm9tIHZpYSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQucmVtb3ZlUG9ydGZvbGlvU3RyYXRlZ3koJ0FCQ0QnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgcmVtb3ZlUG9ydGZvbGlvU3RyYXRlZ3kgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7Q29uZmlndXJhdGlvbkNsaWVudCNnZXRBY3RpdmVSZXN5bmNocm9uaXphdGlvblRhc2tzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBhY3RpdmUgcmVzeW5jaHJvbml6YXRpb24gdGFza3MgdmlhIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSBbe1xuICAgICAgX2lkOiAnQUJDRCcsXG4gICAgICB0eXBlOiAnQ1JFQVRFX1NUUkFURUdZJyxcbiAgICAgIGNyZWF0ZWRBdDogJzIwMjAtMDgtMjVUMDA6MDA6MDAuMDAwWicsXG4gICAgICBzdGF0dXM6ICdFWEVDVVRJTkcnXG4gICAgfV07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCB0YXNrcyA9IGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldEFjdGl2ZVJlc3luY2hyb25pemF0aW9uVGFza3MoJ2FjY291bnRJZCcpO1xuICAgIHRhc2tzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9jb25uZWN0aW9ucy9gIFxuICAgICAgICAgICAgICArICdhY2NvdW50SWQvYWN0aXZlLXJlc3luY2hyb25pemF0aW9uLXRhc2tzJyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjZ2V0QWN0aXZlUmVzeW5jaHJvbml6YXRpb25UYXNrc31cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJldHJpZXZlIGFjdGl2ZSByZXN5bmNocm9uaXphdGlvbiB0YXNrcyBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgQ29uZmlndXJhdGlvbkNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0QWN0aXZlUmVzeW5jaHJvbml6YXRpb25UYXNrcygnYWNjb3VudElkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldEFjdGl2ZVJlc3luY2hyb25pemF0aW9uVGFza3MgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgJyArXG4gICAgICAgICdhY2Nlc3MgdG9rZW4uIFBsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25maWd1cmF0aW9uQ2xpZW50LndhaXRSZXN5bmNocm9uaXphdGlvblRhc2tzQ29tcGxldGVkJywgKCkgPT4ge1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0NvbmZpZ3VyYXRpb25DbGllbnQjd2FpdFJlc3luY2hyb25pemF0aW9uVGFza3NDb21wbGV0ZWR9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCB3YWl0IHVudGlsIGFjdGl2ZSByZXN5bmNocm9uaXphdGlvbiB0YXNrcyBhcmUgY29tcGxldGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGFjdGl2ZVRhc2tzID0gW3tcbiAgICAgICAgX2lkOiAnQUJDRCcsXG4gICAgICAgIHR5cGU6ICdDUkVBVEVfU1RSQVRFR1knLFxuICAgICAgICBjcmVhdGVkQXQ6ICcyMDIwLTA4LTI1VDAwOjAwOjAwLjAwMFonLFxuICAgICAgICBzdGF0dXM6ICdFWEVDVVRJTkcnXG4gICAgICB9XTtcbiAgICAgIHJlcXVlc3RTdHViXG4gICAgICAgIC5vbkZpcnN0Q2FsbCgpLnJlc29sdmVzKGFjdGl2ZVRhc2tzKVxuICAgICAgICAub25TZWNvbmRDYWxsKCkucmVzb2x2ZXMoYWN0aXZlVGFza3MpXG4gICAgICAgIC5vblRoaXJkQ2FsbCgpLnJlc29sdmVzKFtdKTtcblxuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQud2FpdFJlc3luY2hyb25pemF0aW9uVGFza3NDb21wbGV0ZWQoJ2FjY291bnRJZCcsIDEsIDUwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L2NvbmZpZ3VyYXRpb24vY29ubmVjdGlvbnMvYFxuICAgICAgICAgICsgJ2FjY291bnRJZC9hY3RpdmUtcmVzeW5jaHJvbml6YXRpb24tdGFza3MnLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgICB9LFxuICAgICAgICBqc29uOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRUaHJpY2UoaHR0cENsaWVudC5yZXF1ZXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtDb25maWd1cmF0aW9uQ2xpZW50I3dhaXRSZXN5bmNocm9uaXphdGlvblRhc2tzQ29tcGxldGVkfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgdGltZSBvdXQgd2FpdGluZyBmb3IgYWN0aXZlIHJlc3luY2hyb25pemF0aW9uIHRhc2tzIGFyZSBjb21wbGV0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYWN0aXZlVGFza3MgPSBbe1xuICAgICAgICBfaWQ6ICdBQkNEJyxcbiAgICAgICAgdHlwZTogJ0NSRUFURV9TVFJBVEVHWScsXG4gICAgICAgIGNyZWF0ZWRBdDogJzIwMjAtMDgtMjVUMDA6MDA6MDAuMDAwWicsXG4gICAgICAgIHN0YXR1czogJ0VYRUNVVElORydcbiAgICAgIH1dO1xuICAgICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoYWN0aXZlVGFza3MpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQud2FpdFJlc3luY2hyb25pemF0aW9uVGFza3NDb21wbGV0ZWQoJ2FjY291bnRJZCcsIDEsIDUwKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW1lb3V0RXJyb3IgaXMgZXhwZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ1RpbWVvdXRFcnJvcicpO1xuICAgICAgfVxuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvY29uZmlndXJhdGlvbi9jb25uZWN0aW9ucy9gXG4gICAgICAgICAgKyAnYWNjb3VudElkL2FjdGl2ZS1yZXN5bmNocm9uaXphdGlvbi10YXNrcycsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICAgIH0sXG4gICAgICAgIGpzb246IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH0pO1xuXG59KTtcbiJdfQ==