'use strict';

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _history = require('./history.client');

var _history2 = _interopRequireDefault(_history);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const copyFactoryApiUrl = 'https://trading-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {TradingClient}
 */
describe('HistoryClient', () => {

  let copyFactoryClient;
  const token = 'header.payload.sign';
  let httpClient = new _httpClient2.default();
  let sandbox;
  let requestStub;

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(() => {
    copyFactoryClient = new _history2.default(httpClient, token);
    requestStub = sandbox.stub(httpClient, 'request');
  });

  afterEach(() => {
    sandbox.restore();
  });

  /**
   * @test {TradingClient#getProviders}
   */
  it('should retrieve providers from API', async () => {
    let expected = [{
      id: '577f095ab64b4d1710de34f6a28ab3bd',
      name: 'First Last',
      strategies: [{
        id: 'ABCD',
        name: 'Test strategy'
      }]
    }];
    requestStub.resolves(expected);
    let providers = await copyFactoryClient.getProviders();
    providers.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/providers`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {TradingClient#getProviders}
   */
  it('should not retrieve providers from API with account token', async () => {
    copyFactoryClient = new _history2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getProviders();
    } catch (error) {
      error.message.should.equal('You can not invoke getProviders method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {TradingClient#getSubscribers}
   */
  it('should retrieve subscribers from API', async () => {
    let expected = [{
      id: '577f095ab64b4d1710de34f6a28ab3bd',
      name: 'First Last',
      strategies: [{
        id: 'ABCD',
        name: 'Test strategy'
      }]
    }];
    requestStub.resolves(expected);
    let providers = await copyFactoryClient.getSubscribers();
    providers.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/subscribers`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {TradingClient#getSubscribers}
   */
  it('should not retrieve subscribers from API with account token', async () => {
    copyFactoryClient = new _history2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getSubscribers();
    } catch (error) {
      error.message.should.equal('You can not invoke getSubscribers method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {TradingClient#getStrategiesSubscribed}
   */
  it('should retrieve strategies subscribed to from API', async () => {
    let expected = [{
      id: 'ABCD',
      name: 'Test strategy'
    }];
    requestStub.resolves(expected);
    let strategies = await copyFactoryClient.getStrategiesSubscribed();
    strategies.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/strategies-subscribed`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {TradingClient#getStrategiesSubscribed}
   */
  it('should not retrieve strategies subscribed to from API with account token', async () => {
    copyFactoryClient = new _history2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getStrategiesSubscribed();
    } catch (error) {
      error.message.should.equal('You can not invoke getStrategiesSubscribed method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {TradingClient#getProvidedStrategies}
   */
  it('should retrieve provided strategies from API', async () => {
    let expected = [{
      id: 'ABCD',
      name: 'Test strategy'
    }];
    requestStub.resolves(expected);
    let strategies = await copyFactoryClient.getProvidedStrategies();
    strategies.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/provided-strategies`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true
    });
  });

  /**
   * @test {TradingClient#getProvidedStrategies}
   */
  it('should not retrieve provided strategies from API with account token', async () => {
    copyFactoryClient = new _history2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getProvidedStrategies();
    } catch (error) {
      error.message.should.equal('You can not invoke getProvidedStrategies method, because you have connected with account access token. ' + 'Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {TradingClient#getProvidedStrategiesTransactions}
   */
  it('should retrieve transactions performed on provided strategies from API', async () => {
    let expected = [{
      id: '64664661:close',
      type: 'DEAL_TYPE_SELL',
      time: new Date('2020-08-02T21:01:01.830Z'),
      accountId: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      symbol: 'EURJPY',
      subscriber: {
        id: 'subscriberId',
        name: 'Subscriber'
      },
      demo: false,
      provider: {
        id: 'providerId',
        name: 'Provider'
      },
      strategy: {
        id: 'ABCD'
      },
      improvement: 0,
      providerCommission: 0,
      platformCommission: 0,
      quantity: -0.04,
      lotPrice: 117566.08744776,
      tickPrice: 124.526,
      amount: -4702.643497910401,
      commission: -0.14,
      swap: -0.14,
      profit: 0.49
    }];
    let from = new Date();
    let till = new Date();
    requestStub.resolves(expected);
    let transactions = await copyFactoryClient.getProvidedStrategiesTransactions(from, till, ['ABCD'], ['accountId'], ['subscriberId'], 100, 200);
    transactions.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/provided-strategies/transactions`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      qs: {
        from,
        till,
        strategyId: ['ABCD'],
        accountId: ['accountId'],
        subscriberId: ['subscriberId'],
        offset: 100,
        limit: 200
      },
      json: true
    });
  });

  /**
   * @test {TradingClient#getProvidedStrategiesTransactions}
   */
  it('should not retrieve transactions on provided strategies from API with account token', async () => {
    copyFactoryClient = new _history2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getProvidedStrategiesTransactions(new Date(), new Date());
    } catch (error) {
      error.message.should.equal('You can not invoke getProvidedStrategiesTransactions method, because you have connected with account ' + 'access token. Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });

  /**
   * @test {TradingClient#getStrategiesSubscribedTransactions}
   */
  it('should retrieve transactions performed on strategies current user is subscribed to from API', async () => {
    let expected = [{
      id: '64664661:close',
      type: 'DEAL_TYPE_SELL',
      time: new Date('2020-08-02T21:01:01.830Z'),
      accountId: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef',
      symbol: 'EURJPY',
      subscriber: {
        id: 'subscriberId',
        name: 'Subscriber'
      },
      demo: false,
      provider: {
        id: 'providerId',
        name: 'Provider'
      },
      strategy: {
        id: 'ABCD'
      },
      improvement: 0,
      providerCommission: 0,
      platformCommission: 0,
      quantity: -0.04,
      lotPrice: 117566.08744776,
      tickPrice: 124.526,
      amount: -4702.643497910401,
      commission: -0.14,
      swap: -0.14,
      profit: 0.49
    }];
    let from = new Date();
    let till = new Date();
    requestStub.resolves(expected);
    let transactions = await copyFactoryClient.getStrategiesSubscribedTransactions(from, till, ['ABCD'], ['accountId'], ['providerId'], 100, 200);
    transactions.should.equal(expected);
    _sinon2.default.assert.calledOnceWithExactly(httpClient.request, {
      url: `${copyFactoryApiUrl}/users/current/strategies-subscribed/transactions`,
      method: 'GET',
      headers: {
        'auth-token': token
      },
      json: true,
      qs: {
        from,
        till,
        strategyId: ['ABCD'],
        accountId: ['accountId'],
        providerId: ['providerId'],
        offset: 100,
        limit: 200
      }
    });
  });

  /**
   * @test {TradingClient#getStrategiesSubscribedTransactions}
   */
  it('should not retrieve transactions on strategies subscribed to from API with account token', async () => {
    copyFactoryClient = new _history2.default(httpClient, 'token');
    try {
      await copyFactoryClient.getStrategiesSubscribedTransactions(new Date(), new Date());
    } catch (error) {
      error.message.should.equal('You can not invoke getStrategiesSubscribedTransactions method, because you have connected with account ' + 'access token. Please use API access token from https://app.metaapi.cloud/token page to invoke this method.');
    }
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL2NvcHlGYWN0b3J5L2hpc3RvcnkuY2xpZW50LnNwZWMuZXM2Il0sIm5hbWVzIjpbImNvcHlGYWN0b3J5QXBpVXJsIiwiZGVzY3JpYmUiLCJjb3B5RmFjdG9yeUNsaWVudCIsInRva2VuIiwiaHR0cENsaWVudCIsIkh0dHBDbGllbnQiLCJzYW5kYm94IiwicmVxdWVzdFN0dWIiLCJiZWZvcmUiLCJzaW5vbiIsImNyZWF0ZVNhbmRib3giLCJiZWZvcmVFYWNoIiwiSGlzdG9yeUNsaWVudCIsInN0dWIiLCJhZnRlckVhY2giLCJyZXN0b3JlIiwiaXQiLCJleHBlY3RlZCIsImlkIiwibmFtZSIsInN0cmF0ZWdpZXMiLCJyZXNvbHZlcyIsInByb3ZpZGVycyIsImdldFByb3ZpZGVycyIsInNob3VsZCIsImVxdWFsIiwiYXNzZXJ0IiwiY2FsbGVkT25jZVdpdGhFeGFjdGx5IiwicmVxdWVzdCIsInVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJqc29uIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0U3Vic2NyaWJlcnMiLCJnZXRTdHJhdGVnaWVzU3Vic2NyaWJlZCIsImdldFByb3ZpZGVkU3RyYXRlZ2llcyIsInR5cGUiLCJ0aW1lIiwiRGF0ZSIsImFjY291bnRJZCIsInN5bWJvbCIsInN1YnNjcmliZXIiLCJkZW1vIiwicHJvdmlkZXIiLCJzdHJhdGVneSIsImltcHJvdmVtZW50IiwicHJvdmlkZXJDb21taXNzaW9uIiwicGxhdGZvcm1Db21taXNzaW9uIiwicXVhbnRpdHkiLCJsb3RQcmljZSIsInRpY2tQcmljZSIsImFtb3VudCIsImNvbW1pc3Npb24iLCJzd2FwIiwicHJvZml0IiwiZnJvbSIsInRpbGwiLCJ0cmFuc2FjdGlvbnMiLCJnZXRQcm92aWRlZFN0cmF0ZWdpZXNUcmFuc2FjdGlvbnMiLCJxcyIsInN0cmF0ZWd5SWQiLCJzdWJzY3JpYmVySWQiLCJvZmZzZXQiLCJsaW1pdCIsImdldFN0cmF0ZWdpZXNTdWJzY3JpYmVkVHJhbnNhY3Rpb25zIiwicHJvdmlkZXJJZCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxvQkFBb0IscURBQTFCOztBQUVBOzs7QUFHQUMsU0FBUyxlQUFULEVBQTBCLE1BQU07O0FBRTlCLE1BQUlDLGlCQUFKO0FBQ0EsUUFBTUMsUUFBUSxxQkFBZDtBQUNBLE1BQUlDLGFBQWEsSUFBSUMsb0JBQUosRUFBakI7QUFDQSxNQUFJQyxPQUFKO0FBQ0EsTUFBSUMsV0FBSjs7QUFFQUMsU0FBTyxNQUFNO0FBQ1hGLGNBQVVHLGdCQUFNQyxhQUFOLEVBQVY7QUFDRCxHQUZEOztBQUlBQyxhQUFXLE1BQU07QUFDZlQsd0JBQW9CLElBQUlVLGlCQUFKLENBQWtCUixVQUFsQixFQUE4QkQsS0FBOUIsQ0FBcEI7QUFDQUksa0JBQWNELFFBQVFPLElBQVIsQ0FBYVQsVUFBYixFQUF5QixTQUF6QixDQUFkO0FBQ0QsR0FIRDs7QUFLQVUsWUFBVSxNQUFNO0FBQ2RSLFlBQVFTLE9BQVI7QUFDRCxHQUZEOztBQUlBOzs7QUFHQUMsS0FBRyxvQ0FBSCxFQUF5QyxZQUFZO0FBQ25ELFFBQUlDLFdBQVcsQ0FBQztBQUNkQyxVQUFJLGtDQURVO0FBRWRDLFlBQU0sWUFGUTtBQUdkQyxrQkFBWSxDQUFDO0FBQ1hGLFlBQUksTUFETztBQUVYQyxjQUFNO0FBRkssT0FBRDtBQUhFLEtBQUQsQ0FBZjtBQVFBWixnQkFBWWMsUUFBWixDQUFxQkosUUFBckI7QUFDQSxRQUFJSyxZQUFZLE1BQU1wQixrQkFBa0JxQixZQUFsQixFQUF0QjtBQUNBRCxjQUFVRSxNQUFWLENBQWlCQyxLQUFqQixDQUF1QlIsUUFBdkI7QUFDQVIsb0JBQU1pQixNQUFOLENBQWFDLHFCQUFiLENBQW1DdkIsV0FBV3dCLE9BQTlDLEVBQXVEO0FBQ3JEQyxXQUFNLEdBQUU3QixpQkFBa0IsMEJBRDJCO0FBRXJEOEIsY0FBUSxLQUY2QztBQUdyREMsZUFBUztBQUNQLHNCQUFjNUI7QUFEUCxPQUg0QztBQU1yRDZCLFlBQU07QUFOK0MsS0FBdkQ7QUFRRCxHQXBCRDs7QUFzQkE7OztBQUdBaEIsS0FBRywyREFBSCxFQUFnRSxZQUFZO0FBQzFFZCx3QkFBb0IsSUFBSVUsaUJBQUosQ0FBa0JSLFVBQWxCLEVBQThCLE9BQTlCLENBQXBCO0FBQ0EsUUFBSTtBQUNGLFlBQU1GLGtCQUFrQnFCLFlBQWxCLEVBQU47QUFDRCxLQUZELENBRUUsT0FBT1UsS0FBUCxFQUFjO0FBQ2RBLFlBQU1DLE9BQU4sQ0FBY1YsTUFBZCxDQUFxQkMsS0FBckIsQ0FDRSxtR0FDQSw4RkFGRjtBQUlEO0FBQ0YsR0FWRDs7QUFZQTs7O0FBR0FULEtBQUcsc0NBQUgsRUFBMkMsWUFBWTtBQUNyRCxRQUFJQyxXQUFXLENBQUM7QUFDZEMsVUFBSSxrQ0FEVTtBQUVkQyxZQUFNLFlBRlE7QUFHZEMsa0JBQVksQ0FBQztBQUNYRixZQUFJLE1BRE87QUFFWEMsY0FBTTtBQUZLLE9BQUQ7QUFIRSxLQUFELENBQWY7QUFRQVosZ0JBQVljLFFBQVosQ0FBcUJKLFFBQXJCO0FBQ0EsUUFBSUssWUFBWSxNQUFNcEIsa0JBQWtCaUMsY0FBbEIsRUFBdEI7QUFDQWIsY0FBVUUsTUFBVixDQUFpQkMsS0FBakIsQ0FBdUJSLFFBQXZCO0FBQ0FSLG9CQUFNaUIsTUFBTixDQUFhQyxxQkFBYixDQUFtQ3ZCLFdBQVd3QixPQUE5QyxFQUF1RDtBQUNyREMsV0FBTSxHQUFFN0IsaUJBQWtCLDRCQUQyQjtBQUVyRDhCLGNBQVEsS0FGNkM7QUFHckRDLGVBQVM7QUFDUCxzQkFBYzVCO0FBRFAsT0FINEM7QUFNckQ2QixZQUFNO0FBTitDLEtBQXZEO0FBUUQsR0FwQkQ7O0FBc0JBOzs7QUFHQWhCLEtBQUcsNkRBQUgsRUFBa0UsWUFBWTtBQUM1RWQsd0JBQW9CLElBQUlVLGlCQUFKLENBQWtCUixVQUFsQixFQUE4QixPQUE5QixDQUFwQjtBQUNBLFFBQUk7QUFDRixZQUFNRixrQkFBa0JpQyxjQUFsQixFQUFOO0FBQ0QsS0FGRCxDQUVFLE9BQU9GLEtBQVAsRUFBYztBQUNkQSxZQUFNQyxPQUFOLENBQWNWLE1BQWQsQ0FBcUJDLEtBQXJCLENBQ0UscUdBQ0EsOEZBRkY7QUFJRDtBQUNGLEdBVkQ7O0FBWUE7OztBQUdBVCxLQUFHLG1EQUFILEVBQXdELFlBQVk7QUFDbEUsUUFBSUMsV0FBVyxDQUFDO0FBQ2RDLFVBQUksTUFEVTtBQUVkQyxZQUFNO0FBRlEsS0FBRCxDQUFmO0FBSUFaLGdCQUFZYyxRQUFaLENBQXFCSixRQUFyQjtBQUNBLFFBQUlHLGFBQWEsTUFBTWxCLGtCQUFrQmtDLHVCQUFsQixFQUF2QjtBQUNBaEIsZUFBV0ksTUFBWCxDQUFrQkMsS0FBbEIsQ0FBd0JSLFFBQXhCO0FBQ0FSLG9CQUFNaUIsTUFBTixDQUFhQyxxQkFBYixDQUFtQ3ZCLFdBQVd3QixPQUE5QyxFQUF1RDtBQUNyREMsV0FBTSxHQUFFN0IsaUJBQWtCLHNDQUQyQjtBQUVyRDhCLGNBQVEsS0FGNkM7QUFHckRDLGVBQVM7QUFDUCxzQkFBYzVCO0FBRFAsT0FINEM7QUFNckQ2QixZQUFNO0FBTitDLEtBQXZEO0FBUUQsR0FoQkQ7O0FBa0JBOzs7QUFHQWhCLEtBQUcsMEVBQUgsRUFBK0UsWUFBWTtBQUN6RmQsd0JBQW9CLElBQUlVLGlCQUFKLENBQWtCUixVQUFsQixFQUE4QixPQUE5QixDQUFwQjtBQUNBLFFBQUk7QUFDRixZQUFNRixrQkFBa0JrQyx1QkFBbEIsRUFBTjtBQUNELEtBRkQsQ0FFRSxPQUFPSCxLQUFQLEVBQWM7QUFDZEEsWUFBTUMsT0FBTixDQUFjVixNQUFkLENBQXFCQyxLQUFyQixDQUNFLDhHQUNBLDhGQUZGO0FBSUQ7QUFDRixHQVZEOztBQVlBOzs7QUFHQVQsS0FBRyw4Q0FBSCxFQUFtRCxZQUFZO0FBQzdELFFBQUlDLFdBQVcsQ0FBQztBQUNkQyxVQUFJLE1BRFU7QUFFZEMsWUFBTTtBQUZRLEtBQUQsQ0FBZjtBQUlBWixnQkFBWWMsUUFBWixDQUFxQkosUUFBckI7QUFDQSxRQUFJRyxhQUFhLE1BQU1sQixrQkFBa0JtQyxxQkFBbEIsRUFBdkI7QUFDQWpCLGVBQVdJLE1BQVgsQ0FBa0JDLEtBQWxCLENBQXdCUixRQUF4QjtBQUNBUixvQkFBTWlCLE1BQU4sQ0FBYUMscUJBQWIsQ0FBbUN2QixXQUFXd0IsT0FBOUMsRUFBdUQ7QUFDckRDLFdBQU0sR0FBRTdCLGlCQUFrQixvQ0FEMkI7QUFFckQ4QixjQUFRLEtBRjZDO0FBR3JEQyxlQUFTO0FBQ1Asc0JBQWM1QjtBQURQLE9BSDRDO0FBTXJENkIsWUFBTTtBQU4rQyxLQUF2RDtBQVFELEdBaEJEOztBQWtCQTs7O0FBR0FoQixLQUFHLHFFQUFILEVBQTBFLFlBQVk7QUFDcEZkLHdCQUFvQixJQUFJVSxpQkFBSixDQUFrQlIsVUFBbEIsRUFBOEIsT0FBOUIsQ0FBcEI7QUFDQSxRQUFJO0FBQ0YsWUFBTUYsa0JBQWtCbUMscUJBQWxCLEVBQU47QUFDRCxLQUZELENBRUUsT0FBT0osS0FBUCxFQUFjO0FBQ2RBLFlBQU1DLE9BQU4sQ0FBY1YsTUFBZCxDQUFxQkMsS0FBckIsQ0FDRSw0R0FDQSw4RkFGRjtBQUlEO0FBQ0YsR0FWRDs7QUFZQTs7O0FBR0FULEtBQUcsd0VBQUgsRUFBNkUsWUFBWTtBQUN2RixRQUFJQyxXQUFXLENBQUM7QUFDZEMsVUFBSSxnQkFEVTtBQUVkb0IsWUFBTSxnQkFGUTtBQUdkQyxZQUFNLElBQUlDLElBQUosQ0FBUywwQkFBVCxDQUhRO0FBSWRDLGlCQUFXLGtFQUpHO0FBS2RDLGNBQVEsUUFMTTtBQU1kQyxrQkFBWTtBQUNWekIsWUFBSSxjQURNO0FBRVZDLGNBQU07QUFGSSxPQU5FO0FBVWR5QixZQUFNLEtBVlE7QUFXZEMsZ0JBQVU7QUFDUjNCLFlBQUksWUFESTtBQUVSQyxjQUFNO0FBRkUsT0FYSTtBQWVkMkIsZ0JBQVU7QUFDUjVCLFlBQUk7QUFESSxPQWZJO0FBa0JkNkIsbUJBQWEsQ0FsQkM7QUFtQmRDLDBCQUFvQixDQW5CTjtBQW9CZEMsMEJBQW9CLENBcEJOO0FBcUJkQyxnQkFBVSxDQUFDLElBckJHO0FBc0JkQyxnQkFBVSxlQXRCSTtBQXVCZEMsaUJBQVcsT0F2Qkc7QUF3QmRDLGNBQVEsQ0FBQyxpQkF4Qks7QUF5QmRDLGtCQUFZLENBQUMsSUF6QkM7QUEwQmRDLFlBQU0sQ0FBQyxJQTFCTztBQTJCZEMsY0FBUTtBQTNCTSxLQUFELENBQWY7QUE2QkEsUUFBSUMsT0FBTyxJQUFJakIsSUFBSixFQUFYO0FBQ0EsUUFBSWtCLE9BQU8sSUFBSWxCLElBQUosRUFBWDtBQUNBakMsZ0JBQVljLFFBQVosQ0FBcUJKLFFBQXJCO0FBQ0EsUUFBSTBDLGVBQWUsTUFBTXpELGtCQUFrQjBELGlDQUFsQixDQUFvREgsSUFBcEQsRUFBMERDLElBQTFELEVBQWdFLENBQUMsTUFBRCxDQUFoRSxFQUEwRSxDQUFDLFdBQUQsQ0FBMUUsRUFDdkIsQ0FBQyxjQUFELENBRHVCLEVBQ0wsR0FESyxFQUNBLEdBREEsQ0FBekI7QUFFQUMsaUJBQWFuQyxNQUFiLENBQW9CQyxLQUFwQixDQUEwQlIsUUFBMUI7QUFDQVIsb0JBQU1pQixNQUFOLENBQWFDLHFCQUFiLENBQW1DdkIsV0FBV3dCLE9BQTlDLEVBQXVEO0FBQ3JEQyxXQUFNLEdBQUU3QixpQkFBa0IsaURBRDJCO0FBRXJEOEIsY0FBUSxLQUY2QztBQUdyREMsZUFBUztBQUNQLHNCQUFjNUI7QUFEUCxPQUg0QztBQU1yRDBELFVBQUk7QUFDRkosWUFERTtBQUVGQyxZQUZFO0FBR0ZJLG9CQUFZLENBQUMsTUFBRCxDQUhWO0FBSUZyQixtQkFBVyxDQUFDLFdBQUQsQ0FKVDtBQUtGc0Isc0JBQWMsQ0FBQyxjQUFELENBTFo7QUFNRkMsZ0JBQVEsR0FOTjtBQU9GQyxlQUFPO0FBUEwsT0FOaUQ7QUFlckRqQyxZQUFNO0FBZitDLEtBQXZEO0FBaUJELEdBckREOztBQXVEQTs7O0FBR0FoQixLQUFHLHFGQUFILEVBQTBGLFlBQVk7QUFDcEdkLHdCQUFvQixJQUFJVSxpQkFBSixDQUFrQlIsVUFBbEIsRUFBOEIsT0FBOUIsQ0FBcEI7QUFDQSxRQUFJO0FBQ0YsWUFBTUYsa0JBQWtCMEQsaUNBQWxCLENBQW9ELElBQUlwQixJQUFKLEVBQXBELEVBQWdFLElBQUlBLElBQUosRUFBaEUsQ0FBTjtBQUNELEtBRkQsQ0FFRSxPQUFPUCxLQUFQLEVBQWM7QUFDZEEsWUFBTUMsT0FBTixDQUFjVixNQUFkLENBQXFCQyxLQUFyQixDQUNFLDBHQUNBLDRHQUZGO0FBSUQ7QUFDRixHQVZEOztBQVlBOzs7QUFHQVQsS0FBRyw2RkFBSCxFQUFrRyxZQUFZO0FBQzVHLFFBQUlDLFdBQVcsQ0FBQztBQUNkQyxVQUFJLGdCQURVO0FBRWRvQixZQUFNLGdCQUZRO0FBR2RDLFlBQU0sSUFBSUMsSUFBSixDQUFTLDBCQUFULENBSFE7QUFJZEMsaUJBQVcsa0VBSkc7QUFLZEMsY0FBUSxRQUxNO0FBTWRDLGtCQUFZO0FBQ1Z6QixZQUFJLGNBRE07QUFFVkMsY0FBTTtBQUZJLE9BTkU7QUFVZHlCLFlBQU0sS0FWUTtBQVdkQyxnQkFBVTtBQUNSM0IsWUFBSSxZQURJO0FBRVJDLGNBQU07QUFGRSxPQVhJO0FBZWQyQixnQkFBVTtBQUNSNUIsWUFBSTtBQURJLE9BZkk7QUFrQmQ2QixtQkFBYSxDQWxCQztBQW1CZEMsMEJBQW9CLENBbkJOO0FBb0JkQywwQkFBb0IsQ0FwQk47QUFxQmRDLGdCQUFVLENBQUMsSUFyQkc7QUFzQmRDLGdCQUFVLGVBdEJJO0FBdUJkQyxpQkFBVyxPQXZCRztBQXdCZEMsY0FBUSxDQUFDLGlCQXhCSztBQXlCZEMsa0JBQVksQ0FBQyxJQXpCQztBQTBCZEMsWUFBTSxDQUFDLElBMUJPO0FBMkJkQyxjQUFRO0FBM0JNLEtBQUQsQ0FBZjtBQTZCQSxRQUFJQyxPQUFPLElBQUlqQixJQUFKLEVBQVg7QUFDQSxRQUFJa0IsT0FBTyxJQUFJbEIsSUFBSixFQUFYO0FBQ0FqQyxnQkFBWWMsUUFBWixDQUFxQkosUUFBckI7QUFDQSxRQUFJMEMsZUFBZSxNQUFNekQsa0JBQWtCZ0UsbUNBQWxCLENBQXNEVCxJQUF0RCxFQUE0REMsSUFBNUQsRUFBa0UsQ0FBQyxNQUFELENBQWxFLEVBQTRFLENBQUMsV0FBRCxDQUE1RSxFQUN2QixDQUFDLFlBQUQsQ0FEdUIsRUFDUCxHQURPLEVBQ0YsR0FERSxDQUF6QjtBQUVBQyxpQkFBYW5DLE1BQWIsQ0FBb0JDLEtBQXBCLENBQTBCUixRQUExQjtBQUNBUixvQkFBTWlCLE1BQU4sQ0FBYUMscUJBQWIsQ0FBbUN2QixXQUFXd0IsT0FBOUMsRUFBdUQ7QUFDckRDLFdBQU0sR0FBRTdCLGlCQUFrQixtREFEMkI7QUFFckQ4QixjQUFRLEtBRjZDO0FBR3JEQyxlQUFTO0FBQ1Asc0JBQWM1QjtBQURQLE9BSDRDO0FBTXJENkIsWUFBTSxJQU4rQztBQU9yRDZCLFVBQUk7QUFDRkosWUFERTtBQUVGQyxZQUZFO0FBR0ZJLG9CQUFZLENBQUMsTUFBRCxDQUhWO0FBSUZyQixtQkFBVyxDQUFDLFdBQUQsQ0FKVDtBQUtGMEIsb0JBQVksQ0FBQyxZQUFELENBTFY7QUFNRkgsZ0JBQVEsR0FOTjtBQU9GQyxlQUFPO0FBUEw7QUFQaUQsS0FBdkQ7QUFpQkQsR0FyREQ7O0FBdURBOzs7QUFHQWpELEtBQUcsMEZBQUgsRUFBK0YsWUFBWTtBQUN6R2Qsd0JBQW9CLElBQUlVLGlCQUFKLENBQWtCUixVQUFsQixFQUE4QixPQUE5QixDQUFwQjtBQUNBLFFBQUk7QUFDRixZQUFNRixrQkFBa0JnRSxtQ0FBbEIsQ0FBc0QsSUFBSTFCLElBQUosRUFBdEQsRUFBa0UsSUFBSUEsSUFBSixFQUFsRSxDQUFOO0FBQ0QsS0FGRCxDQUVFLE9BQU9QLEtBQVAsRUFBYztBQUNkQSxZQUFNQyxPQUFOLENBQWNWLE1BQWQsQ0FBcUJDLEtBQXJCLENBQ0UsNEdBQ0EsNEdBRkY7QUFJRDtBQUNGLEdBVkQ7QUFZRCxDQS9URCIsImZpbGUiOiJoaXN0b3J5LmNsaWVudC5zcGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgSHR0cENsaWVudCBmcm9tICcuLi9odHRwQ2xpZW50JztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgSGlzdG9yeUNsaWVudCBmcm9tICcuL2hpc3RvcnkuY2xpZW50JztcblxuY29uc3QgY29weUZhY3RvcnlBcGlVcmwgPSAnaHR0cHM6Ly90cmFkaW5nLWFwaS12MS5hZ2lsaXVtdHJhZGUuYWdpbGl1bXRyYWRlLmFpJztcblxuLyoqXG4gKiBAdGVzdCB7VHJhZGluZ0NsaWVudH1cbiAqL1xuZGVzY3JpYmUoJ0hpc3RvcnlDbGllbnQnLCAoKSA9PiB7XG5cbiAgbGV0IGNvcHlGYWN0b3J5Q2xpZW50O1xuICBjb25zdCB0b2tlbiA9ICdoZWFkZXIucGF5bG9hZC5zaWduJztcbiAgbGV0IGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgpO1xuICBsZXQgc2FuZGJveDtcbiAgbGV0IHJlcXVlc3RTdHViO1xuXG4gIGJlZm9yZSgoKSA9PiB7XG4gICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgSGlzdG9yeUNsaWVudChodHRwQ2xpZW50LCB0b2tlbik7XG4gICAgcmVxdWVzdFN0dWIgPSBzYW5kYm94LnN0dWIoaHR0cENsaWVudCwgJ3JlcXVlc3QnKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtUcmFkaW5nQ2xpZW50I2dldFByb3ZpZGVyc31cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgcHJvdmlkZXJzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBpZDogJzU3N2YwOTVhYjY0YjRkMTcxMGRlMzRmNmEyOGFiM2JkJyxcbiAgICAgIG5hbWU6ICdGaXJzdCBMYXN0JyxcbiAgICAgIHN0cmF0ZWdpZXM6IFt7XG4gICAgICAgIGlkOiAnQUJDRCcsXG4gICAgICAgIG5hbWU6ICdUZXN0IHN0cmF0ZWd5J1xuICAgICAgfV1cbiAgICB9XTtcbiAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgbGV0IHByb3ZpZGVycyA9IGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFByb3ZpZGVycygpO1xuICAgIHByb3ZpZGVycy5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3ZpZGVyc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAganNvbjogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtUcmFkaW5nQ2xpZW50I2dldFByb3ZpZGVyc31cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJldHJpZXZlIHByb3ZpZGVycyBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgSGlzdG9yeUNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0UHJvdmlkZXJzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldFByb3ZpZGVycyBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCBhY2Nlc3MgdG9rZW4uICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBBUEkgYWNjZXNzIHRva2VuIGZyb20gaHR0cHM6Ly9hcHAubWV0YWFwaS5jbG91ZC90b2tlbiBwYWdlIHRvIGludm9rZSB0aGlzIG1ldGhvZC4nXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtUcmFkaW5nQ2xpZW50I2dldFN1YnNjcmliZXJzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBzdWJzY3JpYmVycyBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSBbe1xuICAgICAgaWQ6ICc1NzdmMDk1YWI2NGI0ZDE3MTBkZTM0ZjZhMjhhYjNiZCcsXG4gICAgICBuYW1lOiAnRmlyc3QgTGFzdCcsXG4gICAgICBzdHJhdGVnaWVzOiBbe1xuICAgICAgICBpZDogJ0FCQ0QnLFxuICAgICAgICBuYW1lOiAnVGVzdCBzdHJhdGVneSdcbiAgICAgIH1dXG4gICAgfV07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBwcm92aWRlcnMgPSBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5nZXRTdWJzY3JpYmVycygpO1xuICAgIHByb3ZpZGVycy5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L3N1YnNjcmliZXJzYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1RyYWRpbmdDbGllbnQjZ2V0U3Vic2NyaWJlcnN9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBzdWJzY3JpYmVycyBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgSGlzdG9yeUNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0U3Vic2NyaWJlcnMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgZ2V0U3Vic2NyaWJlcnMgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgYWNjZXNzIHRva2VuLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7VHJhZGluZ0NsaWVudCNnZXRTdHJhdGVnaWVzU3Vic2NyaWJlZH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgc3RyYXRlZ2llcyBzdWJzY3JpYmVkIHRvIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBpZDogJ0FCQ0QnLFxuICAgICAgbmFtZTogJ1Rlc3Qgc3RyYXRlZ3knXG4gICAgfV07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBzdHJhdGVnaWVzID0gYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0U3RyYXRlZ2llc1N1YnNjcmliZWQoKTtcbiAgICBzdHJhdGVnaWVzLnNob3VsZC5lcXVhbChleHBlY3RlZCk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2VXaXRoRXhhY3RseShodHRwQ2xpZW50LnJlcXVlc3QsIHtcbiAgICAgIHVybDogYCR7Y29weUZhY3RvcnlBcGlVcmx9L3VzZXJzL2N1cnJlbnQvc3RyYXRlZ2llcy1zdWJzY3JpYmVkYCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1RyYWRpbmdDbGllbnQjZ2V0U3RyYXRlZ2llc1N1YnNjcmliZWR9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBzdHJhdGVnaWVzIHN1YnNjcmliZWQgdG8gZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IEhpc3RvcnlDbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFN0cmF0ZWdpZXNTdWJzY3JpYmVkKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKFxuICAgICAgICAnWW91IGNhbiBub3QgaW52b2tlIGdldFN0cmF0ZWdpZXNTdWJzY3JpYmVkIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1RyYWRpbmdDbGllbnQjZ2V0UHJvdmlkZWRTdHJhdGVnaWVzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBwcm92aWRlZCBzdHJhdGVnaWVzIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBleHBlY3RlZCA9IFt7XG4gICAgICBpZDogJ0FCQ0QnLFxuICAgICAgbmFtZTogJ1Rlc3Qgc3RyYXRlZ3knXG4gICAgfV07XG4gICAgcmVxdWVzdFN0dWIucmVzb2x2ZXMoZXhwZWN0ZWQpO1xuICAgIGxldCBzdHJhdGVnaWVzID0gYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0UHJvdmlkZWRTdHJhdGVnaWVzKCk7XG4gICAgc3RyYXRlZ2llcy5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L3Byb3ZpZGVkLXN0cmF0ZWdpZXNgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7VHJhZGluZ0NsaWVudCNnZXRQcm92aWRlZFN0cmF0ZWdpZXN9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSBwcm92aWRlZCBzdHJhdGVnaWVzIGZyb20gQVBJIHdpdGggYWNjb3VudCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBjb3B5RmFjdG9yeUNsaWVudCA9IG5ldyBIaXN0b3J5Q2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb3B5RmFjdG9yeUNsaWVudC5nZXRQcm92aWRlZFN0cmF0ZWdpZXMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3IubWVzc2FnZS5zaG91bGQuZXF1YWwoXG4gICAgICAgICdZb3UgY2FuIG5vdCBpbnZva2UgZ2V0UHJvdmlkZWRTdHJhdGVnaWVzIG1ldGhvZCwgYmVjYXVzZSB5b3UgaGF2ZSBjb25uZWN0ZWQgd2l0aCBhY2NvdW50IGFjY2VzcyB0b2tlbi4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1RyYWRpbmdDbGllbnQjZ2V0UHJvdmlkZWRTdHJhdGVnaWVzVHJhbnNhY3Rpb25zfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSB0cmFuc2FjdGlvbnMgcGVyZm9ybWVkIG9uIHByb3ZpZGVkIHN0cmF0ZWdpZXMgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGV4cGVjdGVkID0gW3tcbiAgICAgIGlkOiAnNjQ2NjQ2NjE6Y2xvc2UnLFxuICAgICAgdHlwZTogJ0RFQUxfVFlQRV9TRUxMJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA4LTAyVDIxOjAxOjAxLjgzMFonKSxcbiAgICAgIGFjY291bnRJZDogJzAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYnLFxuICAgICAgc3ltYm9sOiAnRVVSSlBZJyxcbiAgICAgIHN1YnNjcmliZXI6IHtcbiAgICAgICAgaWQ6ICdzdWJzY3JpYmVySWQnLFxuICAgICAgICBuYW1lOiAnU3Vic2NyaWJlcidcbiAgICAgIH0sXG4gICAgICBkZW1vOiBmYWxzZSxcbiAgICAgIHByb3ZpZGVyOiB7XG4gICAgICAgIGlkOiAncHJvdmlkZXJJZCcsXG4gICAgICAgIG5hbWU6ICdQcm92aWRlcidcbiAgICAgIH0sXG4gICAgICBzdHJhdGVneToge1xuICAgICAgICBpZDogJ0FCQ0QnXG4gICAgICB9LFxuICAgICAgaW1wcm92ZW1lbnQ6IDAsXG4gICAgICBwcm92aWRlckNvbW1pc3Npb246IDAsXG4gICAgICBwbGF0Zm9ybUNvbW1pc3Npb246IDAsXG4gICAgICBxdWFudGl0eTogLTAuMDQsXG4gICAgICBsb3RQcmljZTogMTE3NTY2LjA4NzQ0Nzc2LFxuICAgICAgdGlja1ByaWNlOiAxMjQuNTI2LFxuICAgICAgYW1vdW50OiAtNDcwMi42NDM0OTc5MTA0MDEsXG4gICAgICBjb21taXNzaW9uOiAtMC4xNCxcbiAgICAgIHN3YXA6IC0wLjE0LFxuICAgICAgcHJvZml0OiAwLjQ5XG4gICAgfV07XG4gICAgbGV0IGZyb20gPSBuZXcgRGF0ZSgpO1xuICAgIGxldCB0aWxsID0gbmV3IERhdGUoKTtcbiAgICByZXF1ZXN0U3R1Yi5yZXNvbHZlcyhleHBlY3RlZCk7XG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFByb3ZpZGVkU3RyYXRlZ2llc1RyYW5zYWN0aW9ucyhmcm9tLCB0aWxsLCBbJ0FCQ0QnXSwgWydhY2NvdW50SWQnXSxcbiAgICAgIFsnc3Vic2NyaWJlcklkJ10sIDEwMCwgMjAwKTtcbiAgICB0cmFuc2FjdGlvbnMuc2hvdWxkLmVxdWFsKGV4cGVjdGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZVdpdGhFeGFjdGx5KGh0dHBDbGllbnQucmVxdWVzdCwge1xuICAgICAgdXJsOiBgJHtjb3B5RmFjdG9yeUFwaVVybH0vdXNlcnMvY3VycmVudC9wcm92aWRlZC1zdHJhdGVnaWVzL3RyYW5zYWN0aW9uc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRva2VuXG4gICAgICB9LFxuICAgICAgcXM6IHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdGlsbCxcbiAgICAgICAgc3RyYXRlZ3lJZDogWydBQkNEJ10sXG4gICAgICAgIGFjY291bnRJZDogWydhY2NvdW50SWQnXSxcbiAgICAgICAgc3Vic2NyaWJlcklkOiBbJ3N1YnNjcmliZXJJZCddLFxuICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgbGltaXQ6IDIwMFxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7VHJhZGluZ0NsaWVudCNnZXRQcm92aWRlZFN0cmF0ZWdpZXNUcmFuc2FjdGlvbnN9XG4gICAqL1xuICBpdCgnc2hvdWxkIG5vdCByZXRyaWV2ZSB0cmFuc2FjdGlvbnMgb24gcHJvdmlkZWQgc3RyYXRlZ2llcyBmcm9tIEFQSSB3aXRoIGFjY291bnQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29weUZhY3RvcnlDbGllbnQgPSBuZXcgSGlzdG9yeUNsaWVudChodHRwQ2xpZW50LCAndG9rZW4nKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0UHJvdmlkZWRTdHJhdGVnaWVzVHJhbnNhY3Rpb25zKG5ldyBEYXRlKCksIG5ldyBEYXRlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZXRQcm92aWRlZFN0cmF0ZWdpZXNUcmFuc2FjdGlvbnMgbWV0aG9kLCBiZWNhdXNlIHlvdSBoYXZlIGNvbm5lY3RlZCB3aXRoIGFjY291bnQgJyArIFxuICAgICAgICAnYWNjZXNzIHRva2VuLiBQbGVhc2UgdXNlIEFQSSBhY2Nlc3MgdG9rZW4gZnJvbSBodHRwczovL2FwcC5tZXRhYXBpLmNsb3VkL3Rva2VuIHBhZ2UgdG8gaW52b2tlIHRoaXMgbWV0aG9kLidcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge1RyYWRpbmdDbGllbnQjZ2V0U3RyYXRlZ2llc1N1YnNjcmliZWRUcmFuc2FjdGlvbnN9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHRyYW5zYWN0aW9ucyBwZXJmb3JtZWQgb24gc3RyYXRlZ2llcyBjdXJyZW50IHVzZXIgaXMgc3Vic2NyaWJlZCB0byBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXhwZWN0ZWQgPSBbe1xuICAgICAgaWQ6ICc2NDY2NDY2MTpjbG9zZScsXG4gICAgICB0eXBlOiAnREVBTF9UWVBFX1NFTEwnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDgtMDJUMjE6MDE6MDEuODMwWicpLFxuICAgICAgYWNjb3VudElkOiAnMDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nzg5YWJjZGVmMDEyMzQ1Njc4OWFiY2RlZicsXG4gICAgICBzeW1ib2w6ICdFVVJKUFknLFxuICAgICAgc3Vic2NyaWJlcjoge1xuICAgICAgICBpZDogJ3N1YnNjcmliZXJJZCcsXG4gICAgICAgIG5hbWU6ICdTdWJzY3JpYmVyJ1xuICAgICAgfSxcbiAgICAgIGRlbW86IGZhbHNlLFxuICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgaWQ6ICdwcm92aWRlcklkJyxcbiAgICAgICAgbmFtZTogJ1Byb3ZpZGVyJ1xuICAgICAgfSxcbiAgICAgIHN0cmF0ZWd5OiB7XG4gICAgICAgIGlkOiAnQUJDRCdcbiAgICAgIH0sXG4gICAgICBpbXByb3ZlbWVudDogMCxcbiAgICAgIHByb3ZpZGVyQ29tbWlzc2lvbjogMCxcbiAgICAgIHBsYXRmb3JtQ29tbWlzc2lvbjogMCxcbiAgICAgIHF1YW50aXR5OiAtMC4wNCxcbiAgICAgIGxvdFByaWNlOiAxMTc1NjYuMDg3NDQ3NzYsXG4gICAgICB0aWNrUHJpY2U6IDEyNC41MjYsXG4gICAgICBhbW91bnQ6IC00NzAyLjY0MzQ5NzkxMDQwMSxcbiAgICAgIGNvbW1pc3Npb246IC0wLjE0LFxuICAgICAgc3dhcDogLTAuMTQsXG4gICAgICBwcm9maXQ6IDAuNDlcbiAgICB9XTtcbiAgICBsZXQgZnJvbSA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHRpbGwgPSBuZXcgRGF0ZSgpO1xuICAgIHJlcXVlc3RTdHViLnJlc29sdmVzKGV4cGVjdGVkKTtcbiAgICBsZXQgdHJhbnNhY3Rpb25zID0gYXdhaXQgY29weUZhY3RvcnlDbGllbnQuZ2V0U3RyYXRlZ2llc1N1YnNjcmliZWRUcmFuc2FjdGlvbnMoZnJvbSwgdGlsbCwgWydBQkNEJ10sIFsnYWNjb3VudElkJ10sXG4gICAgICBbJ3Byb3ZpZGVySWQnXSwgMTAwLCAyMDApO1xuICAgIHRyYW5zYWN0aW9ucy5zaG91bGQuZXF1YWwoZXhwZWN0ZWQpO1xuICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlV2l0aEV4YWN0bHkoaHR0cENsaWVudC5yZXF1ZXN0LCB7XG4gICAgICB1cmw6IGAke2NvcHlGYWN0b3J5QXBpVXJsfS91c2Vycy9jdXJyZW50L3N0cmF0ZWdpZXMtc3Vic2NyaWJlZC90cmFuc2FjdGlvbnNgLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0aWxsLFxuICAgICAgICBzdHJhdGVneUlkOiBbJ0FCQ0QnXSxcbiAgICAgICAgYWNjb3VudElkOiBbJ2FjY291bnRJZCddLFxuICAgICAgICBwcm92aWRlcklkOiBbJ3Byb3ZpZGVySWQnXSxcbiAgICAgICAgb2Zmc2V0OiAxMDAsXG4gICAgICAgIGxpbWl0OiAyMDBcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7VHJhZGluZ0NsaWVudCNnZXRTdHJhdGVnaWVzU3Vic2NyaWJlZFRyYW5zYWN0aW9uc31cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHJldHJpZXZlIHRyYW5zYWN0aW9ucyBvbiBzdHJhdGVnaWVzIHN1YnNjcmliZWQgdG8gZnJvbSBBUEkgd2l0aCBhY2NvdW50IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvcHlGYWN0b3J5Q2xpZW50ID0gbmV3IEhpc3RvcnlDbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvcHlGYWN0b3J5Q2xpZW50LmdldFN0cmF0ZWdpZXNTdWJzY3JpYmVkVHJhbnNhY3Rpb25zKG5ldyBEYXRlKCksIG5ldyBEYXRlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5tZXNzYWdlLnNob3VsZC5lcXVhbChcbiAgICAgICAgJ1lvdSBjYW4gbm90IGludm9rZSBnZXRTdHJhdGVnaWVzU3Vic2NyaWJlZFRyYW5zYWN0aW9ucyBtZXRob2QsIGJlY2F1c2UgeW91IGhhdmUgY29ubmVjdGVkIHdpdGggYWNjb3VudCAnICsgXG4gICAgICAgICdhY2Nlc3MgdG9rZW4uIFBsZWFzZSB1c2UgQVBJIGFjY2VzcyB0b2tlbiBmcm9tIGh0dHBzOi8vYXBwLm1ldGFhcGkuY2xvdWQvdG9rZW4gcGFnZSB0byBpbnZva2UgdGhpcyBtZXRob2QuJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG59KTtcbiJdfQ==